双指针技巧秒杀七道链表题目
=============

本文讲解的例题

LeetCode

力扣

难度

| 题目名称 | 难度 | 力扣（LeetCode）网址 |
| --- | --- | --- |
| 141. 环形链表 | 🟢 | [141. 环形链表 - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle/) |
| 142. 环形链表 II | 🟠 | [142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/) |
| 160. 相交链表 | 🟢 | [160. 相交链表 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-linked-lists/) |
| 19. 删除链表的倒数第 N 个结点 | 🟠 | [19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/) |
| 21. 合并两个有序链表 | 🟢 | [21. 合并两个有序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-two-sorted-lists/) |
| 23. 合并K个升序链表 | 🔴 | [23. 合并K个升序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-k-sorted-lists/) |
| 86. 分隔链表 | 🟠 | [86. 分隔链表 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-list/) |
| 876. 链表的中间结点 | 🟢 | [876. 链表的中间结点 - 力扣（LeetCode）](https://leetcode.cn/problems/middle-of-the-linked-list/) |
| - | - | - |
| 剑指 Offer 22. 链表中倒数第k个节点 | 🟢 | [剑指 Offer 22. 链表中倒数第k个节点 - 力扣（LeetCode）](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/) |

前置知识

阅读本文前，你需要先学习：

*   [链表基础](https://labuladong.online/algo/data-structure-basic/linkedlist-basic/)

  **视频讲解** 

![](https://labuladong.online/algo/images/vod/linked-two-pointer.jpg) 

本文总结一下单链表的基本技巧，每个技巧都对应着至少一道算法题：

1、合并两个有序链表

2、链表的分解

3、合并 `k` 个有序链表

4、寻找单链表的倒数第 `k` 个节点

5、寻找单链表的中点

6、判断单链表是否包含环并找出环起点

7、判断两个单链表是否相交并找出交点

这些解法都用到了双指针技巧，所以说对于单链表相关的题目，双指针的运用是非常广泛的，下面我们就来一个一个看。

[合并两个有序链表](#)
-------------

这是最基本的链表技巧，力扣第 21 题「[合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)」就是这个问题，给你输入两个有序链表，请你把他俩合并成一个新的有序链表：

**21\. 合并两个有序链表** | [力扣](https://leetcode.cn/problems/merge-two-sorted-lists/) | [LeetCode](https://leetcode.com/problems/merge-two-sorted-lists/) |  🟢

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例 1：**

![](https://labuladong.online/algo/images/lc/uploads/2020/10/03/merge_ex1.jpg)


**题目来源：[力扣 21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)。**


cpp 🤖

    // 函数签名如下
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2);



这题比较简单，我们直接看解法：


cpp 🤖

    class Solution {
    public:
        ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
            // 虚拟头结点
            ListNode dummy(-1), *p = &dummy;
            ListNode *p1 = l1, *p2 = l2;
            
            while (p1 != nullptr && p2 != nullptr) {
                // 比较 p1 和 p2 两个指针
                // 将值较小的的节点接到 p 指针
                if (p1->val > p2->val) {
                    p->next = p2;
                    p2 = p2->next;
                } else {
                    p->next = p1;
                    p1 = p1->next;
                }
                // p 指针不断前进
                p = p->next;
            }
            
            if (p1 != nullptr) {
                p->next = p1;
            }
            
            if (p2 != nullptr) {
                p->next = p2;
            }
            
            return dummy.next;
        }
    };

我们的 while 循环每次比较 `p1` 和 `p2` 的大小，把较小的节点接到结果链表上，看如下 GIF：

![](https://labuladong.online/algo/images/linked-list-two-pointer/1.gif)

形象地理解，这个算法的逻辑类似于拉拉链，`l1, l2` 类似于拉链两侧的锯齿，指针 `p` 就好像拉链的拉索，将两个有序链表合并。


**代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是 `dummy` 节点**。你可以试试，如果不使用 `dummy` 虚拟节点，代码会复杂一些，需要额外处理指针 `p` 为空的情况。而有了 `dummy` 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性。

何时使用虚拟头结点

经常有读者问我，什么时候需要用虚拟头结点？我这里总结下：**当你需要创造一条新链表的时候，可以使用虚拟头结点简化边界情况的处理**。

比如说，让你把两条有序链表合并成一条新的有序链表，是不是要创造一条新链表？再比你想把一条链表分解成两条链表，是不是也在创造新链表？这些情况都可以使用虚拟头结点简化边界情况的处理。

[单链表的分解](#)
-----------

直接看下力扣第 86 题「[分隔链表](https://leetcode.cn/problems/partition-list/)」：

**86\. 分隔链表** | [力扣](https://leetcode.cn/problems/partition-list/) | [LeetCode](https://leetcode.com/problems/partition-list/) |  🟠

给你一个链表的头节点 `head` 和一个特定值 `x` ，请你对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前。

你应当 **保留** 两个分区中每个节点的初始相对位置。


**题目来源：[力扣 86. 分隔链表](https://leetcode.cn/problems/partition-list/)。**

在合并两个有序链表时让你合二为一，而这里需要分解让你把原链表一分为二。具体来说，我们可以把原链表分成两个小链表，一个链表中的元素大小都小于 `x`，另一个链表中的元素都大于等于 `x`，最后再把这两条链表接到一起，就得到了题目想要的结果。

整体逻辑和合并有序链表非常相似，细节直接看代码吧，注意虚拟头结点的运用：

cpp 🤖

    class Solution {
    public:
        ListNode* partition(ListNode* head, int x) {
            // 存放小于 x 的链表的虚拟头结点
            ListNode* dummy1 = new ListNode(-1);
            // 存放大于等于 x 的链表的虚拟头结点
            ListNode* dummy2 = new ListNode(-1);
            // p1, p2 指针负责生成结果链表
            ListNode* p1 = dummy1, *p2 = dummy2;
            // p 负责遍历原链表，类似合并两个有序链表的逻辑
            // 这里是将一个链表分解成两个链表
            ListNode* p = head;
            while (p != nullptr) {
                if (p->val >= x) {
                    p2->next = p;
                    p2 = p2->next;
                } else {
                    p1->next = p;
                    p1 = p1->next;
                }
                // 不能直接让 p 指针前进，
                // p = p->next
                // 断开原链表中的每个节点的 next 指针
                ListNode* temp = p->next;
                p->next = nullptr;
                p = temp;
            }
            // 连接两个链表
            p1->next = dummy2->next;
    
            return dummy1->next;
        }
    };


我知道有很多读者会对这段代码有疑问：

    // 不能直接让 p 指针前进，
    // p = p.next
    // 断开原链表中的每个节点的 next 指针
    ListNode temp = p.next;
    p.next = null;
    p = temp;

不多废话，直接借助我们的可视化面板看一下就明白了。首先看下正确的写法，你可以多次点击 `while (p !== null)` 这一行代码即可看到链表分解的过程：

[Algorithm visualize](https://labuladong.online/algo-visualize/leetcode/partition-list/)   **算法可视化面板**Link copied!

如果你不断开原链表中的每个节点的 `next` 指针，那么就会出错，因为结果链表中会包含一个环，你可以多次点击 `while (p !== null)` 这一行代码查看：

[Algorithm visualize](https://labuladong.online/algo-visualize/tutorial/mydata-partition-list/)   **算法可视化面板**Link copied!

总的来说，如果我们需要把原链表的节点接到新链表上，而不是 new 新节点来组成新链表的话，那么断开节点和原链表之间的链接可能是必要的。那其实我们可以养成一个好习惯，但凡遇到这种情况，就把原链表的节点断开，这样就不会出错了。

[合并 `k` 个有序链表](#)
-----------------

看下力扣第 23 题「[合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)」：

**23\. 合并 K 个升序链表** | [力扣](https://leetcode.cn/problems/merge-k-sorted-lists/) | [LeetCode](https://leetcode.com/problems/merge-k-sorted-lists/) |  🔴

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。


**题目来源：[力扣 23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)。**


cpp 🤖

    // 函数签名如下
    ListNode* mergeKLists(vector<ListNode*>& lists);


合并 `k` 个有序链表的逻辑类似合并两个有序链表，难点在于，如何快速得到 `k` 个节点中的最小节点，接到结果链表上？

这里我们就要用到优先级队列这种数据结构，把链表节点放入一个最小堆，就可以每次获得 `k` 个节点中的最小节点。关于优先级队列可以参考 [优先级队列（二叉堆）原理及实现](https://labuladong.online/algo/data-structure-basic/binary-heap-implement/)，本文不展开。

cpp 🤖

    class Solution {
    public:
        ListNode* mergeKLists(vector<ListNode*>& lists) {
            if (lists.empty()) return nullptr;
            // 虚拟头结点
            ListNode* dummy = new ListNode(-1);
            ListNode* p = dummy;
            // 优先级队列，最小堆
            auto cmp = [](ListNode* a, ListNode* b) { return a->val > b->val; };
            priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq(cmp);
            // 将 k 个链表的头结点加入最小堆
            for (ListNode* head : lists) {
                if (head != nullptr) {
                    pq.push(head);
                }
            }
    
            while (!pq.empty()) {
                // 获取最小节点，接到结果链表中
                ListNode* node = pq.top();
                pq.pop();
                p->next = node;
                if (node->next != nullptr) {
                    pq.push(node->next);
                }
                // p 指针不断前进
                p = p->next;
            }
            return dummy->next;
        }
    };

这个算法是面试常考题，它的时间复杂度是多少呢？

优先队列 `pq` 中的元素个数最多是 kkk，所以一次 `poll` 或者 `add` 方法的时间复杂度是 O(logk)O(logk)O(logk)；所有的链表节点都会被加入和弹出 `pq`，**所以算法整体的时间复杂度是 O(Nlogk)O(Nlogk)O(Nlogk)，其中 kkk 是链表的条数，NNN 是这些链表的节点总数**。

提示

这道题还有一个经典的解法，在 [分治算法核心框架](https://labuladong.online/algo/essential-technique/divide-and-conquer/) 中详细讲解，这里不展开。

[单链表的倒数第 `k` 个节点](#)
--------------------

从前往后寻找单链表的第 `k` 个节点很简单，一个 for 循环遍历过去就找到了，但是如何寻找从后往前数的第 `k` 个节点呢？

那你可能说，假设链表有 `n` 个节点，倒数第 `k` 个节点就是正数第 `n - k + 1` 个节点，不也是一个 for 循环的事儿吗？

是的，但是算法题一般只给你一个 `ListNode` 头结点代表一条单链表，你不能直接得出这条链表的长度 `n`，而需要先遍历一遍链表算出 `n` 的值，然后再遍历链表计算第 `n - k + 1` 个节点。

也就是说，这个解法需要遍历两次链表才能得到出倒数第 `k` 个节点。

那么，我们能不能**只遍历一次链表**，就算出倒数第 `k` 个节点？可以做到的，如果是面试问到这道题，面试官肯定也是希望你给出只需遍历一次链表的解法。

这个解法就比较巧妙了，假设 `k = 2`，思路如下：

首先，我们先让一个指针 `p1` 指向链表的头节点 `head`，然后走 `k` 步：

![](https://labuladong.online/algo/images/linked-list-two-pointer/1.jpeg)

现在的 `p1`，只要再走 `n - k` 步，就能走到链表末尾的空指针了对吧？

趁这个时候，再用一个指针 `p2` 指向链表头节点 `head`：

![](https://labuladong.online/algo/images/linked-list-two-pointer/2.jpeg)

接下来就很显然了，让 `p1` 和 `p2` 同时向前走，`p1` 走到链表末尾的空指针时前进了 `n - k` 步，`p2` 也从 `head` 开始前进了 `n - k` 步，停留在第 `n - k + 1` 个节点上，即恰好停链表的倒数第 `k` 个节点上：

![](https://labuladong.online/algo/images/linked-list-two-pointer/3.jpeg)

这样，只遍历了一次链表，就获得了倒数第 `k` 个节点 `p2`。

上述逻辑的代码如下：


cpp 🤖

    // 返回链表的倒数第 k 个节点
    ListNode* findFromEnd(ListNode* head, int k) {
        ListNode* p1 = head;
        // p1 先走 k 步
        for (int i = 0; i < k; i++) {
            p1 = p1 -> next;
        }
        ListNode* p2 = head;
        // p1 和 p2 同时走 n - k 步
        while (p1 != nullptr) {
            p2 = p2 -> next;
            p1 = p1 -> next;
        }
        // p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点
        return p2;
    }

当然，如果用 big O 表示法来计算时间复杂度，无论遍历一次链表和遍历两次链表的时间复杂度都是 O(N)O(N)O(N)，但上述这个算法更有技巧性。

很多链表相关的算法题都会用到这个技巧，比如说力扣第 19 题「[删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)」：

**19\. 删除链表的倒数第 N 个结点** | [力扣](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/) | [LeetCode](https://leetcode.com/problems/remove-nth-node-from-end-of-list/) |  🟠

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。


**题目来源：[力扣 19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)。**

我们直接看解法代码：


cpp 🤖

    class Solution {
    public:
        ListNode* removeNthFromEnd(ListNode* head, int n) {
            // 虚拟头结点
            ListNode* dummy = new ListNode(-1);
            dummy->next = head;
            // 删除倒数第 n 个，要先找倒数第 n + 1 个节点
            ListNode* x = findFromEnd(dummy, n + 1);
            // 删掉倒数第 n 个节点
            x->next = x->next->next;
            return dummy->next;
        }
        
    private:
        ListNode* findFromEnd(ListNode* head, int k) {
            // 代码见上文
        }
    };

你可以打开可视化面板，点击 `let p2 = head;` 这一行代码一次，可以看到 `p2` 先前进了 `k` 步，然后多次点击 `while (p1 !== null)` 这一行代码，可以看到 `p1` 和 `p2` 同时前进，最终 `p2` 停在了倒数第 `k` 个节点上：

[Algorithm visualize](https://labuladong.online/algo-visualize/leetcode/remove-nth-node-from-end-of-list/)   **算法可视化面板**Link copied!

这个逻辑就很简单了，要删除倒数第 `n` 个节点，就得获得倒数第 `n + 1` 个节点的引用，可以用我们实现的 `findFromEnd` 来操作。

不过注意我们又使用了虚拟头结点的技巧，也是为了防止出现空指针的情况，比如说链表总共有 5 个节点，题目就让你删除倒数第 5 个节点，也就是第一个节点，那按照算法逻辑，应该首先找到倒数第 6 个节点。但第一个节点前面已经没有节点了，这就会出错。

但有了我们虚拟节点 `dummy` 的存在，就避免了这个问题，能够对这种情况进行正确的删除。

[单链表的中点](#)
-----------

力扣第 876 题「[链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)」就是这个题目，问题的关键也在于我们无法直接得到单链表的长度 `n`，常规方法也是先遍历链表计算 `n`，再遍历一次得到第 `n / 2` 个节点，也就是中间节点。

如果想一次遍历就得到中间节点，也需要耍点小聪明，使用「快慢指针」的技巧：

我们让两个指针 `slow` 和 `fast` 分别指向链表头结点 `head`。

**每当慢指针 `slow` 前进一步，快指针 `fast` 就前进两步，这样，当 `fast` 走到链表末尾时，`slow` 就指向了链表中点**。

上述思路的代码实现如下：


cpp 🤖

    class Solution {
    public:
        ListNode* middleNode(ListNode* head) {
            // 快慢指针初始化指向 head
            ListNode* slow = head;
            ListNode* fast = head;
            // 快指针走到末尾时停止
            while (fast != nullptr && fast->next != nullptr) {
                // 慢指针走一步，快指针走两步
                slow = slow->next;
                fast = fast->next->next;
            }
            // 慢指针指向中点
            return slow;
        }
    };


需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。

另外，这段代码稍加修改就可以直接用到判断链表成环的算法题上。

[判断链表是否包含环](#)
--------------

判断链表是否包含环属于经典问题了，解决方案也是用快慢指针：

每当慢指针 `slow` 前进一步，快指针 `fast` 就前进两步。

如果 `fast` 最终能正常走到链表末尾，说明链表中没有环；如果 `fast` 走着走着竟然和 `slow` 相遇了，那肯定是 `fast` 在链表中转圈了，说明链表中含有环。

只需要把寻找链表中点的代码稍加修改就行了：


cpp 🤖

    class Solution {
    public:
        bool hasCycle(ListNode *head) {
            // 快慢指针初始化指向 head
            ListNode *slow = head, *fast = head;
            // 快指针走到末尾时停止
            while (fast != nullptr && fast->next != nullptr) {
                // 慢指针走一步，快指针走两步
                slow = slow->next;
                fast = fast->next->next;
                // 快慢指针相遇，说明含有环
                if (slow == fast) {
                    return true;
                }
            }
            // 不包含环
            return false;
        }
    };


你可以打开下面的可视化面板，多次点击 `fast = fast.next.next;` 这一行代码，即可看到快慢指针运动的过程，最终相遇：

[Algorithm visualize](https://labuladong.online/algo-visualize/leetcode/linked-list-cycle/)   **算法可视化面板**Link copied!

当然，这个问题还有进阶版，也是力扣第 142 题「[环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)」：如果链表中含有环，如何计算这个环的起点？

举个例子，环的起点是指下面这幅图中的节点 2：

![](https://labuladong.online/algo/images/linked-list-two-pointer/circularlinkedlist.png)

这里先直接看一下寻找环起点的解法代码：

cpp 🤖

    class Solution {
    public:
        ListNode *detectCycle(ListNode *head) {
            ListNode *fast, *slow;
            fast = slow = head;
            while (fast != nullptr && fast->next != nullptr) {
                fast = fast->next->next;
                slow = slow->next;
                if (fast == slow) break;
            }
            // 上面的代码类似 hasCycle 函数
            if (fast == nullptr || fast->next == nullptr) {
                // fast 遇到空指针说明没有环
                return nullptr;
            }
    
            // 重新指向头结点
            slow = head;
            // 快慢指针同步前进，相交点就是环起点
            while (slow != fast) {
                fast = fast->next;
                slow = slow->next;
            }
            return slow;
        }
    };



可以看到，当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。

为什么要这样呢？这里简单说一下其中的原理。

我们假设快慢指针相遇时，慢指针 `slow` 走了 `k` 步，那么快指针 `fast` 一定走了 `2k` 步：

![](https://labuladong.online/algo/images/linked-two-pointer/3.jpeg)

`fast` 一定比 `slow` 多走了 `k` 步，这多走的 `k` 步其实就是 `fast` 指针在环里转圈圈，所以 `k` 的值就是环长度的「整数倍」。

假设相遇点距环的起点的距离为 `m`，那么结合上图的 `slow` 指针，环的起点距头结点 `head` 的距离为 `k - m`，也就是说如果从 `head` 前进 `k - m` 步就能到达环起点。

巧的是，如果从相遇点继续前进 `k - m` 步，也恰好到达环起点。因为结合上图的 `fast` 指针，从相遇点开始走k步可以转回到相遇点，那走 `k - m` 步肯定就走到环起点了：

![](https://labuladong.online/algo/images/linked-two-pointer/2.jpeg)

所以，只要我们把快慢指针中的任一个重新指向 `head`，然后两个指针同速前进，`k - m` 步后一定会相遇，相遇之处就是环的起点了。

[两个链表是否相交](#)
-------------

这个问题有意思，也是力扣第 160 题「[相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)」函数签名如下：


cpp 🤖

    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB);


给你输入两个链表的头结点 `headA` 和 `headB`，这两个链表可能存在相交。

如果相交，你的算法应该返回相交的那个节点；如果没相交，则返回 null。

比如题目给我们举的例子，如果输入的两个链表如下图：

![](https://labuladong.online/algo/images/linked-list-two-pointer/4.png)

那么我们的算法应该返回 `c1` 这个节点。

这个题直接的想法可能是用 `HashSet` 记录一个链表的所有节点，然后和另一条链表对比，但这就需要额外的空间。

如果不用额外的空间，只使用两个指针，你如何做呢？

难点在于，由于两条链表的长度可能不同，两条链表之间的节点无法对应：

![](https://labuladong.online/algo/images/linked-list-two-pointer/5.jpeg)

如果用两个指针 `p1` 和 `p2` 分别在两条链表上前进，并不能**同时**走到公共节点，也就无法得到相交节点 `c1`。

**解决这个问题的关键是，通过某些方式，让 `p1` 和 `p2` 能够同时到达相交节点 `c1`**。

所以，我们可以让 `p1` 遍历完链表 `A` 之后开始遍历链表 `B`，让 `p2` 遍历完链表 `B` 之后开始遍历链表 `A`，这样相当于「逻辑上」两条链表接在了一起。

如果这样进行拼接，就可以让 `p1` 和 `p2` 同时进入公共部分，也就是同时到达相交节点 `c1`：

![](https://labuladong.online/algo/images/linked-list-two-pointer/6.jpeg)

那你可能会问，如果说两个链表没有相交点，是否能够正确的返回 null 呢？

这个逻辑可以覆盖这种情况的，相当于 `c1` 节点是 null 空指针嘛，可以正确返回 null。

按照这个思路，可以写出如下代码：

cpp 🤖

    class Solution {
    public:
        ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
            // p1 指向 A 链表头结点，p2 指向 B 链表头结点
            ListNode *p1 = headA, *p2 = headB;
            while (p1 != p2) {
                // p1 走一步，如果走到 A 链表末尾，转到 B 链表
                if (p1 == nullptr) {
                    p1 = headB;
                } else {
                    p1 = p1->next;
                }
                // p2 走一步，如果走到 B 链表末尾，转到 A 链表
                if (p2 == nullptr) {
                    p2 = headA;
                } else {
                    p2 = p2->next;
                }
            }
            return p1;
        }
    };



这样，这道题就解决了，空间复杂度为 O(1)O(1)O(1)，时间复杂度为 O(N)O(N)O(N)。

以上就是单链表的所有技巧，希望对你有启发。

**2022/1/24 更新**：

评论区有不少优秀读者对最后一题「寻找两条链表的交点」提出了一些其他思路，也补充到这里。

首先有读者提到，如果把两条链表首尾相连，那么「寻找两条链表的交点」的问题转换成了前面讲的「寻找环起点」的问题：

![](https://labuladong.online/algo/images/linked-list-two-pointer/7.png)

说实话我没有想到这种思路，不得不说这是一个很巧妙的转换！不过需要注意的是，这道题说不让你改变原始链表的结构，所以你把题目输入的链表转化成环形链表求解之后记得还要改回来，否则无法通过。

另外，还有读者提到，既然「寻找两条链表的交点」的核心在于让 `p1` 和 `p2` 两个指针能够同时到达相交节点 `c1`，那么可以通过预先计算两条链表的长度来做到这一点，具体代码如下：


cpp 🤖

    class Solution {
    public:
        ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
            int lenA = 0, lenB = 0;
            // 计算两条链表的长度
            for (ListNode* p1 = headA; p1 != nullptr; p1 = p1->next) {
                lenA++;
            }
            for (ListNode* p2 = headB; p2 != nullptr; p2 = p2->next) {
                lenB++;
            }
            // 让 p1 和 p2 到达尾部的距离相同
            ListNode* p1 = headA;
            ListNode* p2 = headB;
            if (lenA > lenB) {
                for (int i = 0; i < lenA - lenB; i++) {
                    p1 = p1->next;
                }
            } else {
                for (int i = 0; i < lenB - lenA; i++) {
                    p2 = p2->next;
                }
            }
            // 看两个指针是否会相同，p1 == p2 时有两种情况：
            // 1、要么是两条链表不相交，他俩同时走到尾部空指针
            // 2、要么是两条链表相交，他俩走到两条链表的相交点
            while (p1 != p2) {
                p1 = p1->next;
                p2 = p2->next;
            }
            return p1;
        }
    };


虽然代码多一些，但是时间复杂度是还是 O(N)O(N)O(N)，而且会更容易理解一些。

总之，我的解法代码并不一定就是最优或者最正确的，鼓励大家在评论区多多提出自己的疑问和思考，我也很高兴和大家探讨更多的解题思路~

到这里，链表相关的双指针技巧就全部讲完了，这些技巧的更多扩展延伸见 [更多链表双指针经典习题](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/)。

* * *

**引用本文的题目**

| 题目名称 | 难度 | 力扣（LeetCode）网址 |
| --- | --- | --- |
| 109. 有序链表转换二叉搜索树 | 🟠 | [109. 有序链表转换二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/?show=1) |
| 1257. 最小公共区域 | 🟠 | [1257. 最小公共区域 - 力扣（LeetCode）](https://leetcode.cn/problems/smallest-common-region/?show=1) |
| 1650. 二叉树的最近公共祖先 III | 🟠 | [1650. 二叉树的最近公共祖先 III - 力扣（LeetCode）](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iii/?show=1) |
| 1836. 从未排序的链表中移除重复元素 | 🟠 | [1836. 从未排序的链表中移除重复元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-an-unsorted-linked-list/?show=1) |
| 2. 两数相加 | 🟠 | [2. 两数相加 - 力扣（LeetCode）](https://leetcode.cn/problems/add-two-numbers/?show=1) |
| 234. 回文链表 | 🟢 | [234. 回文链表 - 力扣（LeetCode）](https://leetcode.cn/problems/palindrome-linked-list/?show=1) |
| 264. 丑数 II | 🟠 | [264. 丑数 II - 力扣（LeetCode）](https://leetcode.cn/problems/ugly-number-ii/?show=1) |
| 313. 超级丑数 | 🟠 | [313. 超级丑数 - 力扣（LeetCode）](https://leetcode.cn/problems/super-ugly-number/?show=1) |
| 355. 设计推特 | 🟠 | [355. 设计推特 - 力扣（LeetCode）](https://leetcode.cn/problems/design-twitter/?show=1) |
| 360. 有序转化数组 | 🟠 | [360. 有序转化数组 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-transformed-array/?show=1) |
| 373. 查找和最小的 K 对数字 | 🟠 | [373. 查找和最小的 K 对数字 - 力扣（LeetCode）](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/?show=1) |
| 378. 有序矩阵中第 K 小的元素 | 🟠 | [378. 有序矩阵中第 K 小的元素 - 力扣（LeetCode）](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/?show=1) |
| 431. 将 N 叉树编码为二叉树 | 🔴 | [431. 将 N 叉树编码为二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/encode-n-ary-tree-to-binary-tree/?show=1) |
| 88. 合并两个有序数组 | 🟢 | [88. 合并两个有序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-sorted-array/?show=1) |
| 97. 交错字符串 | 🟠 | [97. 交错字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/interleaving-string/?show=1) |
| 977. 有序数组的平方 | 🟢 | [977. 有序数组的平方 - 力扣（LeetCode）](https://leetcode.cn/problems/squares-of-a-sorted-array/?show=1) |
| - | - | - |
| 剑指 Offer 18. 删除链表的节点 | 🟢 | [剑指 Offer 18. 删除链表的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/?show=1) |
| 剑指 Offer 25. 合并两个排序的链表 | 🟢 | [剑指 Offer 25. 合并两个排序的链表 - 力扣（LeetCode）](https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/?show=1) |
| 剑指 Offer 49. 丑数 | 🟠 | [剑指 Offer 49. 丑数 - 力扣（LeetCode）](https://leetcode.cn/problems/chou-shu-lcof/?show=1) |
| 剑指 Offer 52. 两个链表的第一个公共节点 | 🟢 | [剑指 Offer 52. 两个链表的第一个公共节点 - 力扣（LeetCode）](https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/?show=1) |
| 剑指 Offer II 021. 删除链表的倒数第 n 个结点 | 🟠 | [剑指 Offer II 021. 删除链表的倒数第 n 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/SLwz0R/?show=1) |
| 剑指 Offer II 022. 链表中环的入口节点 | 🟠 | [剑指 Offer II 022. 链表中环的入口节点 - 力扣（LeetCode）](https://leetcode.cn/problems/c32eOV/?show=1) |
| 剑指 Offer II 023. 两个链表的第一个重合节点 | 🟢 | [剑指 Offer II 023. 两个链表的第一个重合节点 - 力扣（LeetCode）](https://leetcode.cn/problems/3u1WK4/?show=1) |
| 剑指 Offer II 027. 回文链表 | 🟢 | [剑指 Offer II 027. 回文链表 - 力扣（LeetCode）](https://leetcode.cn/problems/aMhZSa/?show=1) |
| 剑指 Offer II 061. 和最小的 k 个数对 | 🟠 | [剑指 Offer II 061. 和最小的 k 个数对 - 力扣（LeetCode）](https://leetcode.cn/problems/qn8gGX/?show=1) |
| 剑指 Offer II 078. 合并排序链表 | 🔴 | [剑指 Offer II 078. 合并排序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/vvXgSW/?show=1) |


* * *



上一页

学习数据结构和算法的框架思维



下一页

双指针技巧秒杀七道数组题目



# 练习题


阅读本文前，你需要先学习：

*   [链表基础](https://labuladong.online/algo/data-structure-basic/linkedlist-basic/)

🌟

* * *

🌟
[链表的分解](#)
----------


链表的分解技巧可以运用到很多单链表题目中，题目并不一定明确地要求你把链表分解成两部分，只要要求你从链表筛选出若干节点，都可以用这个技巧。

[82\. 删除排序链表中的重复元素 II](#)
-------------------------

**82\. 删除排序链表中的重复元素 II** | [力扣](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/) | [LeetCode](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/) |  🟠

给定一个已排序的链表的头 `head` ， _删除原始链表中所有重复数字的节点，只留下不同的数字_ 。返回 _已排序的链表_ 。

**示例 1：**

![](https://labuladong.online/algo/images/lc/uploads/2021/01/04/linkedlist1.jpg)

**输入：**head = \[1,2,3,3,4,4,5\]
**输出：**\[1,2,5\]

**示例 2：**

![](https://labuladong.online/algo/images/lc/uploads/2021/01/04/linkedlist2.jpg)

**输入：**head = \[1,1,1,2,3\]
**输出：**\[2,3\]

**提示：**

*   链表中节点数目在范围 `[0, 300]` 内
*   `-100 <= Node.val <= 100`
*   题目数据保证链表已经按升序 **排列**

**题目来源：[力扣 82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)。**

### [基本思路](#)

这道题可以有多种解法，最简单粗暴的解法是用 [哈希集合](https://labuladong.online/algo/data-structure-basic/hash-set/) 来记录重复节点，需要额外的空间复杂度，我们不讨论。下面探讨如何用双指针技巧，避免使用额外的空间复杂度来求解。

第一种思路，也是我比较推荐的方式，就是把这种题转化成 [链表的双指针技巧汇总](https://labuladong.online/algo/essential-technique/array-two-pointers-summary/) 中讲的链表分解的技巧。题目其实就是让你把链表分解成「重复元素」和「不重复元素」两条链表，然后把不重复元素这条链表返回即可。

第二种思路，可以把这道题理解为 [链表的双指针技巧汇总](https://labuladong.online/algo/essential-technique/array-two-pointers-summary/) 中讲的 [83\. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list) 的变体，只不过 83 题让你把多于的重复元素去掉，这道题要求你把所有重复的元素全都去掉。

第三种思路，可以用递归思维来做，稍微难理解一些，我也写出来供大家参考。

**详细题解**：

*   [【练习】链表双指针经典习题](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/)

### [解法代码](#)

cpp 🤖

    // 推荐的通用解法，运用链表分解的技巧
    class Solution {
    public:
        ListNode* deleteDuplicates(ListNode* head) {
            // 将原链表分解为两条链表
            // 一条链表存放不重复的节点，另一条链表存放重复的节点
            // 运用虚拟头结点技巧，题目说了 node.val <= 100，所以用 101 作为虚拟头结点
            ListNode dummyUniq(101);
            ListNode dummyDup(101);
    
            ListNode* pUniq = &dummyUniq;
            ListNode* pDup = &dummyDup;
            ListNode* p = head;
    
            while (p != nullptr) {
                if ((p->next != nullptr && p->val == p->next->val) || p->val == pDup->val) {
                    // 发现重复节点，接到重复链表后面
                    pDup->next = p;
                    pDup = pDup->next;
                } else {
                    // 不是重复节点，接到不重复链表后面
                    pUniq->next = p;
                    pUniq = pUniq->next;
                }
    
                p = p->next;
                // 将原链表和新链表断开
                pUniq->next = nullptr;
                pDup->next = nullptr;
            }
    
            return dummyUniq.next;
        }
    };
    
    // 快慢双指针解法
    class Solution2 {
    public:
        ListNode* deleteDuplicates(ListNode* head) {
            ListNode dummy(-1);
            ListNode* p = &dummy;
            ListNode* q = head;
            while (q != nullptr) {
                if (q->next != nullptr && q->val == q->next->val) {
                    // 发现重复节点，跳过这些重复节点
                    while (q->next != nullptr && q->val == q->next->val) {
                        q = q->next;
                    }
                    q = q->next;
                    // 此时 q 跳过了这一段重复元素
                    if (q == nullptr) {
                        p->next = nullptr;
                    }
                    // 不过下一段元素也可能重复，等下一轮 while 循环判断
                } else {
                    // 不是重复节点，接到 dummy 后面
                    p->next = q;
                    p = p->next;
                    q = q->next;
                }
            }
            return dummy.next;
        }
    };
    
    // 递归解法
    class Solution3 {
    public:
        // 定义：输入一条单链表头结点，返回去重之后的单链表头结点
        ListNode* deleteDuplicates(ListNode* head) {
            // base case
            if (head == nullptr || head->next == nullptr) {
                return head;
            }
            if (head->val != head->next->val) {
                // 如果头结点和身后节点的值不同，则对之后的链表去重即可
                head->next = deleteDuplicates(head->next);
                return head;
            }
            // 如果如果头结点和身后节点的值相同，则说明从 head 开始存在若干重复节点
            // 越过重复节点，找到 head 之后那个不重复的节点
            while (head->next != nullptr && head->val == head->next->val) {
                head = head->next;
            }
            // 直接返回那个不重复节点开头的链表的去重结果，就把重复节点删掉了
            return deleteDuplicates(head->next);
        }
    };




[链表的合并](#)
----------



有些题目虽然不是链表的题目，但其中蕴含了合并有序链表的思想。

[264\. 丑数 II](#)
----------------

**264\. 丑数 II** | [力扣](https://leetcode.cn/problems/ugly-number-ii/) | [LeetCode](https://leetcode.com/problems/ugly-number-ii/) |  🟠

给你一个整数 `n` ，请你找出并返回第 `n` 个 **丑数** 。

**丑数** 就是质因子只包含 `2`、`3` 和 `5` 的正整数。

**示例 1：**

**输入：**n = 10
**输出：**12
**解释：**\[1, 2, 3, 4, 5, 6, 8, 9, 10, 12\] 是由前 10 个丑数组成的序列。

**示例 2：**

**输入：**n = 1
**输出：**1
**解释：**1 通常被视为丑数。

**提示：**

*   `1 <= n <= 1690`

**题目来源：[力扣 264. 丑数 II](https://leetcode.cn/problems/ugly-number-ii/)。**

### [基本思路](#)

这道题很精妙，你看着它好像是道数学题，实际上它却是一个合并多个有序链表的问题，同时用到了筛选素数的思路。

建议你先做一下 [链表双指针技巧汇总](https://labuladong.online/algo/essential-technique/linked-list-skills-summary/) 中讲到的 [21\. 合并两个有序链表（简单）](https://leetcode.cn/problems/merge-two-sorted-lists)，然后再做一下 [如何高效寻找素数](https://labuladong.online/algo/frequency-interview/print-prime-number/) 中讲的 [204\. 计数质数（简单）](https://leetcode.cn/problems/count-primes)，这样的话就能比较容易理解这道题的思路了。

**类似 [如何高效寻找素数](https://labuladong.online/algo/frequency-interview/print-prime-number/) 的思路：如果一个数 `x` 是丑数，那么 `x * 2, x * 3, x * 5` 都一定是丑数**。

我们把所有丑数想象成一个从小到大排序的链表，就是这个样子：

    1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 8 -> ...

然后，我们可以把丑数分为三类：2 的倍数、3 的倍数、5 的倍数（按照题目的意思，1 算作特殊的丑数，放在开头），这三类丑数就好像三条有序链表，如下：

能被 2 整除的丑数：

    1 -> 1*2 -> 2*2 -> 3*2 -> 4*2 -> 5*2 -> 6*2 -> 8*2 ->...

能被 3 整除的丑数：

    1 -> 1*3 -> 2*3 -> 3*3 -> 4*3 -> 5*3 -> 6*3 -> 8*3 ->...

能被 5 整除的丑数：

    1 -> 1*5 -> 2*5 -> 3*5 -> 4*5 -> 5*5 -> 6*5 -> 8*5 ->...

我们其实就是想把这三条「有序链表」合并在一起并去重，合并的结果就是丑数的序列。然后求合并后的这条有序链表中第 `n` 个元素是什么。所以这里就和 [链表双指针技巧汇总](https://labuladong.online/algo/essential-technique/linked-list-skills-summary/) 中讲到的合并 `k` 条有序链表的思路基本一样了。

具体思路看注释吧，你也可以对照我在 [21\. 合并两个有序链表（简单）](https://leetcode.cn/problems/merge-two-sorted-lists) 中给出的思路代码来看本题的思路代码，就能轻松看懂本题的解法代码了。

**详细题解**：

*   [一文秒杀所有丑数系列问题](https://labuladong.online/algo/frequency-interview/ugly-number-summary/)
*   [【练习】链表双指针经典习题](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/)

### [解法代码](#)


cpp 🤖

    class Solution {
    public:
        int nthUglyNumber(int n) {
            // 可以理解为三个指向有序链表头结点的指针
            int p2 = 1, p3 = 1, p5 = 1;
            // 可以理解为三个有序链表的头节点的值
            int product2 = 1, product3 = 1, product5 = 1;
            // 可以理解为最终合并的有序链表（结果链表）
            vector<int> ugly(n + 1);
            // 可以理解为结果链表上的指针
            int p = 1;
    
            // 开始合并三个有序链表
            while (p <= n) {
                // 取三个链表的最小结点
                int min = std::min({product2, product3, product5});
                // 接到结果链表上
                ugly[p] = min;
                p++;
                // 前进对应有序链表上的指针
                if (min == product2) {
                    product2 = 2 * ugly[p2];
                    p2++;
                }
                if (min == product3) {
                    product3 = 3 * ugly[p3];
                    p3++;
                }
                if (min == product5) {
                    product5 = 5 * ugly[p5];
                    p5++;
                }
            }
            // 返回第 n 个丑数
            return ugly[n];
        }
    };




**类似题目**：

*   [1201\. 丑数 III 🟠](https://leetcode.cn/problems/ugly-number-iii)
*   [263\. 丑数 🟢](https://leetcode.cn/problems/ugly-number)
*   [313\. 超级丑数 🟠](https://leetcode.cn/problems/super-ugly-number)
*   [剑指 Offer 49. 丑数 🟠](https://leetcode.cn/problems/chou-shu-lcof)

[378\. 有序矩阵中第 K 小的元素](#)
------------------------

**378\. 有序矩阵中第 K 小的元素** | [力扣](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/) | [LeetCode](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/) |  🟠

给你一个 `n x n` 矩阵 `matrix` ，其中每行和每列元素均按升序排序，找到矩阵中第 `k` 小的元素。  
请注意，它是 **排序后** 的第 `k` 小元素，而不是第 `k` 个 **不同** 的元素。

你必须找到一个内存复杂度优于 `O(n2)` 的解决方案。

**示例 1：**

**输入：**matrix = \[\[1,5,9\],\[10,11,13\],\[12,13,15\]\], k = 8
**输出：**13
**解释：**矩阵中的元素为 \[1,5,9,10,11,12,13,**13**,15\]，第 8 小元素是 13

**示例 2：**

**输入：**matrix = \[\[-5\]\], k = 1
**输出：**\-5

**提示：**

*   `n == matrix.length`
*   `n == matrix[i].length`
*   `1 <= n <= 300`
*   `-109 <= matrix[i][j] <= 109`
*   题目数据 **保证** `matrix` 中的所有行和列都按 **非递减顺序** 排列
*   `1 <= k <= n2`

**进阶：**

*   你能否用一个恒定的内存(即 `O(1)` 内存复杂度)来解决这个问题?
*   你能在 `O(n)` 的时间复杂度下解决这个问题吗?这个方法对于面试来说可能太超前了，但是你会发现阅读这篇文章（ [this paper](http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf) ）很有趣。

**题目来源：[力扣 378. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/)。**

### [基本思路](#)

这道题其实是前文 [单链表的六大解题套路](https://labuladong.online/algo/essential-technique/linked-list-skills-summary/) 中讲过的 [23\. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists) 的变体。

矩阵中的每一行都是排好序的，就好比多条有序链表，你用优先级队列施展合并多条有序链表的逻辑就能找到第 `k` 小的元素了。

**详细题解**：

*   [【练习】优先级队列经典习题](https://labuladong.online/algo/problem-set/binary-heap/)
*   [【练习】链表双指针经典习题](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/)

### [解法代码](#)


cpp 🤖

    #include <queue>
    #include <vector>
    
    class Solution {
    public:
        int kthSmallest(std::vector<std::vector<int>>& matrix, int k) {
            // 存储二元组 (matrix[i][j], i, j)
            // i, j 记录当前元素的索引位置，用于生成下一个节点
            auto cmp = [](const std::vector<int>& a, const std::vector<int>& b) {
                // 按照元素大小升序排序
                return a[0] > b[0];
            };
            std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, decltype(cmp)> pq(cmp);
    
            // 初始化优先级队列，把每一行的第一个元素装进去
            for (int i = 0; i < matrix.size(); i++) {
                pq.push({matrix[i][0], i, 0});
            }
    
            int res = -1;
            // 执行合并多个有序链表的逻辑，找到第 k 小的元素
            while (!pq.empty() && k > 0) {
                std::vector<int> cur = pq.top();
                pq.pop();
                res = cur[0];
                k--;
                // 链表中的下一个节点加入优先级队列
                int i = cur[1], j = cur[2];
                if (j + 1 < matrix[i].size()) {
                    pq.push({matrix[i][j + 1], i, j + 1});
                }
            }
            return res;
        }
    };


[373\. 查找和最小的 K 对数字](#)
-----------------------

**373\. 查找和最小的 K 对数字** | [力扣](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/) | [LeetCode](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/) |  🟠

给定两个以 **非递减顺序排列** 的整数数组 `nums1` 和 `nums2` , 以及一个整数 `k` 。

定义一对值 `(u,v)`，其中第一个元素来自 `nums1`，第二个元素来自 `nums2` 。

请找到和最小的 `k` 个数对 `(u1,v1)`,  `(u2,v2)`  ...  `(uk,vk)` 。

**示例 1:**

**输入:** nums1 = \[1,7,11\], nums2 = \[2,4,6\], k = 3
**输出:** \[1,2\],\[1,4\],\[1,6\]
**解释:** 返回序列中的前 3 对数：
     \[1,2\],\[1,4\],\[1,6\],\[7,2\],\[7,4\],\[11,2\],\[7,6\],\[11,4\],\[11,6\]

**示例 2:**

**输入:** nums1 = \[1,1,2\], nums2 = \[1,2,3\], k = 2
**输出:** \[1,1\],\[1,1\]
**解释:** 返回序列中的前 2 对数：
     \[1,1\],\[1,1\],\[1,2\],\[2,1\],\[1,2\],\[2,2\],\[1,3\],\[1,3\],\[2,3\]

**提示:**

*   `1 <= nums1.length, nums2.length <= 105`
*   `-109 <= nums1[i], nums2[i] <= 109`
*   `nums1` 和 `nums2` 均为 **升序排列**
*   `1 <= k <= 104`
*   `k <= nums1.length * nums2.length`

**题目来源：[力扣 373. 查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/)。**

### [基本思路](#)

这道题其实是前文 [单链表的六大解题套路](https://labuladong.online/algo/essential-technique/linked-list-skills-summary/) 中讲过的 [23\. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists) 的变体。

怎么把这道题变成合并多个有序链表呢？就比如说题目输入的用例：

    nums1 = [1,7,11], nums2 = [2,4,6]

组合出的所有数对儿这就可以抽象成三个有序链表：

    [1, 2] -> [1, 4] -> [1, 6]
    [7, 2] -> [7, 4] -> [7, 6]
    [11, 2] -> [11, 4] -> [11, 6]

这三个链表中每个元素（数对之和）是递增的，所以就可以按照 [23\. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists) 的思路来合并，取出前 `k` 个作为答案即可。

**详细题解**：

*   [【练习】优先级队列经典习题](https://labuladong.online/algo/problem-set/binary-heap/)
*   [【练习】链表双指针经典习题](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/)

### [解法代码](#)

cpp 🤖

    class Solution {
    public:
        vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {
            // 存储三元组 (num1[i], nums2[i], i)
            // i 记录 nums2 元素的索引位置，用于生成下一个节点
            auto cmp = [](const vector<int>& a, const vector<int>& b) {
                // 按照数对的元素和升序排序
                return (a[0] + a[1]) > (b[0] + b[1]);
            };
            priority_queue<vector<int>, vector<vector<int>>, decltype(cmp)> pq(cmp);
            
            // 按照 23 题的逻辑初始化优先级队列
            for (int i = 0; i < nums1.size(); i++) {
                pq.push({nums1[i], nums2[0], 0});
            }
    
            vector<vector<int>> res;
            // 执行合并多个有序链表的逻辑
            while (!pq.empty() && k > 0) {
                vector<int> cur = pq.top();
                pq.pop();
                k--;
                // 链表中的下一个节点加入优先级队列
                int next_index = cur[2] + 1;
                if (next_index < nums2.size()) {
                    pq.push({cur[0], nums2[next_index], next_index});
                }
    
                res.push_back({cur[0], cur[1]});
            }
            return res;
        }
    };


**类似题目**：

*   [剑指 Offer II 061. 和最小的 k 个数对 🟠](https://leetcode.cn/problems/qn8gGX)

[链表运算题](#)
----------

[2\. 两数相加](#)
-------------

**2\. 两数相加** | [力扣](https://leetcode.cn/problems/add-two-numbers/) | [LeetCode](https://leetcode.com/problems/add-two-numbers/) |  🟠

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例 1：**

![](https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg)

**输入：**l1 = \[2,4,3\], l2 = \[5,6,4\]
**输出：**\[7,0,8\]
**解释：**342 + 465 = 807.

**示例 2：**

**输入：**l1 = \[0\], l2 = \[0\]
**输出：**\[0\]

**示例 3：**

**输入：**l1 = \[9,9,9,9,9,9,9\], l2 = \[9,9,9,9\]
**输出：**\[8,9,9,9,0,0,0,1\]

**提示：**

*   每个链表中的节点数在范围 `[1, 100]` 内
*   `0 <= Node.val <= 9`
*   题目数据保证列表表示的数字不含前导零

**题目来源：[力扣 2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)。**

### [基本思路](#)

逆序存储很友好了，直接遍历链表就是从个位开始的，符合我们计算加法的习惯顺序。如果是正序存储，那倒要费点脑筋了，可能需要 [翻转链表](https://labuladong.online/algo/data-structure/reverse-linked-list-recursion/) 或者使用栈来辅助。

这道题主要考察 [链表双指针技巧](https://labuladong.online/algo/essential-technique/linked-list-skills-summary/) 和加法运算过程中对进位的处理。注意这个 `carry` 变量的处理，在我们手动模拟加法过程的时候会经常用到。

**代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是 `dummy` 节点**。你可以试试，如果不使用 `dummy` 虚拟节点，代码会稍显复杂，而有了 `dummy` 节点这个占位符，可以避免处理初始的空指针情况，降低代码的复杂性。

**详细题解**：

*   [【练习】链表双指针经典习题](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/)


cpp 🤖

    class Solution {
    public:
        ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
            // 在两条链表上的指针
            ListNode *p1 = l1, *p2 = l2;
            // 虚拟头结点（构建新链表时的常用技巧）
            ListNode *dummy = new ListNode(-1);
            // 指针 p 负责构建新链表
            ListNode *p = dummy;
            // 记录进位
            int carry = 0;
            // 开始执行加法，两条链表走完且没有进位时才能结束循环
            while (p1 != nullptr || p2 != nullptr || carry > 0) {
                // 先加上上次的进位
                int val = carry;
                if (p1 != nullptr) {
                    val += p1->val;
                    p1 = p1->next;
                }
                if (p2 != nullptr) {
                    val += p2->val;
                    p2 = p2->next;
                }
                // 处理进位情况
                carry = val / 10;
                val = val % 10;
                // 构建新节点
                p->next = new ListNode(val);
                p = p->next;
            }
            // 返回结果链表的头结点（去除虚拟头结点）
            return dummy->next;
        }
    };

**类似题目**：

*   [445\. 两数相加 II 🟠](https://leetcode.cn/problems/add-two-numbers-ii)
*   [67\. 二进制求和 🟢](https://leetcode.cn/problems/add-binary)
*   [剑指 Offer II 025. 链表中的两数相加 🟠](https://leetcode.cn/problems/lMSNwu)

[445\. 两数相加 II](#)
------------------

**445\. 两数相加 II** | [力扣](https://leetcode.cn/problems/add-two-numbers-ii/) | [LeetCode](https://leetcode.com/problems/add-two-numbers-ii/) |  🟠

给你两个 **非空** 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。

你可以假设除了数字 0 之外，这两个数字都不会以零开头。

**示例1：**

![](https://labuladong.online/algo/images/lc/1626420025-fZfzMX-image.png)

**输入：**l1 = \[7,2,4,3\], l2 = \[5,6,4\]
**输出：**\[7,8,0,7\]

**示例2：**

**输入：**l1 = \[2,4,3\], l2 = \[5,6,4\]
**输出：**\[8,0,7\]

**示例3：**

**输入：**l1 = \[0\], l2 = \[0\]
**输出：**\[0\]

**提示：**

*   链表的长度范围为 `[1, 100]`
*   `0 <= node.val <= 9`
*   输入数据保证链表代表的数字无前导 0

**进阶：**如果输入链表不能翻转该如何解决？

**题目来源：[力扣 445. 两数相加 II](https://leetcode.cn/problems/add-two-numbers-ii/)。**

### [基本思路](#)

这道题是 [2\. 两数相加](https://leetcode.cn/problems/add-two-numbers) 的进阶问题，我们模拟加法运算当然是从最低位开始加，这样才能正确的处理进位。但现在单链表的开头是最高位，那么最直接的想法就是先 [翻转链表](https://labuladong.online/algo/data-structure/reverse-linked-list-recursion/)，这样就可以继续玩第 2 题那一套了，没什么难度。

不过本题也说了，如果不让你反转链表怎么办？其实也好办，我们可以利用栈这种先进后出的数据结构，把链表节点从头到尾放进栈中，再从栈拿出来就是从尾到头的顺序，相当于是反转链表的效果，然后又回到了第 2 题的加法逻辑。

还有一个需要注意的是，计算结果的高位也应该放在结果链表的左侧，也就是插入到 `dummy` 节点的后面。具体看代码吧。

**详细题解**：

*   [【练习】链表双指针经典习题](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/)

### [解法代码](#)


cpp 🤖

    #include <stack>
    
    class Solution {
    public:
        ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
            // 把链表元素转入栈中
            std::stack<int> stk1;
            while (l1 != nullptr) {
                stk1.push(l1->val);
                l1 = l1->next;
            }
            std::stack<int> stk2;
            while (l2 != nullptr) {
                stk2.push(l2->val);
                l2 = l2->next;
            }
            
            // 接下来基本上是复用我在第 2 题的代码逻辑
            // 注意新节点要直接插入到 dummy 后面
    
            // 虚拟头结点（构建新链表时的常用技巧）
            ListNode* dummy = new ListNode(-1);
    
            // 记录进位
            int carry = 0;
            // 开始执行加法，两条链表走完且没有进位时才能结束循环
            while (!stk1.empty() || !stk2.empty() || carry > 0) {
                // 先加上上次的进位
                int val = carry;
                if (!stk1.empty()) {
                    val += stk1.top();
                    stk1.pop();
                }
                if (!stk2.empty()) {
                    val += stk2.top();
                    stk2.pop();
                }
                // 处理进位情况
                carry = val / 10;
                val = val % 10;
                // 构建新节点，直接接在 dummy 后面
                ListNode* newNode = new ListNode(val);
                newNode->next = dummy->next;
                dummy->next = newNode;
            }
            // 返回结果链表的头结点（去除虚拟头结点）
            return dummy->next;
        }
    };



**类似题目**：

*   [剑指 Offer II 025. 链表中的两数相加 🟠](https://leetcode.cn/problems/lMSNwu)