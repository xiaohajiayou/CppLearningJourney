
# 二分查找模板
本文讲解的例题

| 题目编号 | 题目名称 | 中文网站链接 | 题目描述 |
| --- | --- | --- | --- |
| 34 | 在排序数组中查找元素的第一个和最后一个位置 | [力扣（LeetCode）](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/) | 在排序数组中查找元素的第一个和最后一个位置 |
| 704 | 二分查找 | [力扣（LeetCode）](https://leetcode.cn/problems/binary-search/) | 二分查找 |
| 剑指 Offer 53 - I | 在排序数组中查找数字 I | [力扣（LeetCode）](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/) | 在排序数组中查找数字 I |

前置知识

阅读本文前，你需要先学习：

*   [数组基础](https://labuladong.online/algo/data-structure-basic/array-basic/)



先给大家讲个笑话乐呵一下：

有一天阿东到图书馆借了 `N` 本书，出图书馆的时候，警报响了，于是保安把阿东拦下，要检查一下哪本书没有登记出借。阿东正准备把每一本书在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分查找都不会吗？

于是保安把书分成两堆，让第一堆过一下报警器，报警器响，这说明引起报警的书包含在里面；于是再把这堆书分成两堆，把第一堆过一下报警器，报警器又响，继续分成两堆……

最终，检测了 `logN` 次之后，保安成功的找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是阿东背着剩下的书走了。

从此，图书馆丢了 `N - 1` 本书（手动狗头）。

二分查找并不简单，Knuth 大佬（发明 KMP 算法的那位）都说二分查找：**思路很简单，细节是魔鬼**。很多人喜欢拿整型溢出的 bug 说事儿，但是二分查找真正的坑根本就不是那个细节问题，而是在于到底要给 `mid` 加一还是减一，while 里到底用 `<=` 还是 `<`。

你要是没有正确理解这些细节，写二分肯定就是玄学编程，有没有 bug 只能靠菩萨保佑，谁写谁知道。

本文就来探究几个最常用的二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。而且，我们就是要深入细节，比如不等号是否应该带等号，`mid` 是否应该加一等等。分析这些细节的差异以及出现这些差异的原因，保证你能灵活准确地写出正确的二分查找算法。

另外再声明一下，对于二分搜索的每一个场景，本文还会探讨多种代码写法，目的是为了让你理解出现这些细微差异的本质原因，最起码你看到别人的代码时不会懵逼。实际上这些写法没有优劣之分，你喜欢哪种就用哪种好了。

[零、二分查找框架](#)
-------------


cpp 🤖

    int binarySearch(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
    
        while (...) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                ...
            } else if (nums[mid] < target) {
                left = ...
            } else if (nums[mid] > target) {
                right = ...
            }
        }
    }


**分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节**。本文都会使用 else if，旨在讲清楚，读者理解后可自行简化。

其中 `...` 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。

**另外提前说明一下，计算 `mid` 时需要防止溢出**，代码中 `left + (right - left) / 2` 就和 `(left + right) / 2` 的结果相同，但是有效防止了 `left` 和 `right` 太大，直接相加导致溢出的情况。

[一、寻找一个数（基本的二分搜索）](#)
---------------------

这个场景是最简单的，可能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 -1。

cpp 🤖

    class Solution {
    public:
        // 标准的二分搜索框架，搜索目标元素的索引，若不存在则返回 -1
        int search(vector<int>& nums, int target) {
            int left = 0;
            // 注意
            int right = nums.size() - 1;
    
            while(left <= right) {
                int mid = left + (right - left) / 2;
                if(nums[mid] == target) {
                    return mid;   
                } else if (nums[mid] < target) {
                    // 注意
                    left = mid + 1;
                } else if (nums[mid] > target) {
                    // 注意
                    right = mid - 1;
                }
            }
            return -1;
        }
    };


[Algorithm visualize](https://labuladong.online/algo-visualize/leetcode/binary-search/)   **算法可视化面板**Link copied!

这段代码可以解决力扣第 704 题「[二分查找](https://leetcode.cn/problems/binary-search/)」，但我们深入探讨一下其中的细节。

### [为什么 while 循环的条件是 `<=` 而不是 `<`？](#)

答：因为初始化 `right` 的赋值是 `nums.length - 1`，即最后一个元素的索引，而不是 `nums.length`。

这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 `[left, right]`，后者相当于左闭右开区间 `[left, right)`。因为索引大小为 `nums.length` 是越界的，所以我们把 `right` 这一边视为开区间。

我们这个算法中使用的是前者 `[left, right]` 两端都闭的区间。**这个区间其实就是每次进行搜索的区间**。

什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：

        if(nums[mid] == target)
            return mid;

但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？**搜索区间为空的时候应该终止**，意味着你没得找了，就等于没找到嘛。

`while(left <= right)` 的终止条件是 `left == right + 1`，写成区间的形式就是 `[right + 1, right]`，或者带个具体的数字进去 `[3, 2]`，可见**这时候区间为空**，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。

`while(left < right)` 的终止条件是 `left == right`，写成区间的形式就是 `[right, right]`，或者带个具体的数字进去 `[2, 2]`，**这时候区间非空**，还有一个数 2，但此时 while 循环终止了。也就是说区间 `[2, 2]` 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。

当然，如果你非要用 `while(left < right)` 也可以，我们已经知道了出错的原因，就打个补丁好了：

        // ...
        while(left < right) {
            // ...
        }
        return nums[left] == target ? left : -1;

### [为什么是 `left = mid + 1`，`right = mid - 1`？](#)

为什么 `left = mid + 1`，`right = mid - 1`？我看有的代码是 `right = mid` 或者 `left = mid`，没有这些加加减减，到底怎么回事，怎么判断？

答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。

刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 `[left, right]`。那么当我们发现索引 `mid` 不是要找的 `target` 时，下一步应该去搜索哪里呢？

当然是去搜索区间 `[left, mid-1]` 或者区间 `[mid+1, right]` 对不对？**因为 `mid` 已经搜索过，应该从搜索区间中去除**。

### [此算法有什么缺陷？](#)

答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。

比如说给你有序数组 `nums = [1,2,2,2,3]`，`target` 为 2，此算法返回的索引是 2，没错。但是如果我想得到 `target` 的左侧边界，即索引 1，或者我想得到 `target` 的右侧边界，即索引 3，这样的话此算法是无法处理的。

这样的需求很常见，**你也许会说，找到一个 `target`，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了**。

我们后续的算法就来讨论这两种二分查找的算法。

[二、寻找左侧边界的二分搜索](#)
------------------

以下是最常见的代码形式，其中的标记是需要注意的细节：


cpp 🤖

    int left_bound(vector<int>& nums, int target) {
        int left = 0;
        // 注意
        int right = nums.size();
        
        // 注意
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                right = mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                // 注意
                right = mid;
            }
        }
        return left;
    }


### [为什么 while 中是 `<` 而不是 `<=`？](#)

答：用相同的方法分析，因为 `right = nums.length` 而不是 `nums.length - 1`。因此每次循环的「搜索区间」是 `[left, right)` 左闭右开。

`while(left < right)` 终止的条件是 `left == right`，此时搜索区间 `[left, left)` 为空，所以可以正确终止。

Info

这里先要说一个搜索左右边界和上面这个算法的一个区别，也是很多读者问的：**刚才的 `right` 不是 `nums.length - 1` 吗，为啥这里非要写成 `nums.length` 使得「搜索区间」变成左闭右开呢**？

因为对于搜索左右侧边界的二分查找，这种写法比较普遍，我就拿这种写法举例了，保证你以后遇到这类代码可以理解。你非要用两端都闭的写法反而更简单，我会在后面写相关的代码，把三种二分搜索都用一种两端都闭的写法统一起来，你耐心往后看就行了。

### [`target` 不存在时返回什么？](#)

如果 `nums` 中不存在 `target` 这个值，计算出来的这个索引含义是什么？如果我想让它返回 -1，怎么做？

当 `target` 不存在时，`left_bound` 返回值的含义

这是一个很好且很重要的问题，你把这个地方理解了，在二分搜索的实际应用场景中就不会懵逼。

直接说结论：**如果 `target` 不存在，搜索左侧边界的二分搜索返回的索引是大于 `target` 的最小索引**。

举个例子，`nums = [2,3,5,7], target = 4`，`left_bound` 函数返回值是 2，因为元素 5 是大于 4 的最小元素。

有点绕晕了是吧？这个 `left_bound` 函数明明是搜索左边界的，但是当 `target` 不存在的时候，却返回的是大于 `target` 的最小索引。这个结论不用死记，你要是拿不准，简单举个例子就能得到这个结论了。

所以跟你说二分搜索这个东西思路很简单，细节是魔鬼嘛，里面的坑太多了。要是真想考你，总有办法可以把你考到怀疑人生。

不是我故意把代码模板总结的这么复杂，而是二分搜索本身就很复杂，这些细节是不可能绕开的，如果你之前没有了解过这些细节，只能说明你之前学得不扎实。就算不用我总结的模板，你也必须搞清楚当 `target` 不存在时算法的行为，否则出了 bug 你都不知道咋改，真有这么严重。

话说回来，`left_bound` 的这个行为有一个好处。比方说现在让你写一个 `floor` 函数，就可以直接用 `left_bound` 函数来实现：

    // 在一个有序数组中，找到「小于 target 的最大元素的索引」
    // 比如说输入 nums = [1,2,2,2,3]，target = 2，函数返回 0，因为 1 是小于 2 的最大元素。
    // 再比如输入 nums = [1,2,3,5,6]，target = 4，函数返回 2，因为 3 是小于 4 的最大元素。
    int floor(int[] nums, int target) {
        // 当 target 不存在，比如输入 [4,6,8,10], target = 7
        // left_bound 返回 2，减一就是 1，元素 6 就是小于 7 的最大元素
        // 当 target 存在，比如输入 [4,6,8,8,8,10], target = 8
        // left_bound 返回 2，减一就是 1，元素 6 就是小于 8 的最大元素
        return left_bound(nums, target) - 1;
    }

最后，我的建议是，如果你必须手写二分代码，那么你一定要了解清楚代码的种种行为，本文总结的框架就是在帮你理清这里面的细节。如果非必要，不要自己手写，尽可能用编程语言提供的标准库函数，可以节约时间，而且标准库函数的行为在文档里都有明确的说明，不容易出错。

如果想让 `target` 不存在时返回 -1 其实很简单，在返回的时候额外判断一下 `nums[left]` 是否等于 `target` 就行了，如果不等于，就说明 `target` 不存在。需要注意的是，访问数组索引之前要保证索引不越界：

    while (left < right) {
        // ...
    }
    // 如果索引越界，说明数组中无目标元素，返回 -1
    if (left < 0 || left >= nums.length) {
        return -1;
    }
    // 提示：其实上面的 if 中 left < 0 这个判断可以省略，因为对于这个算法，left 不可能小于 0
    // 你看这个算法执行的逻辑，left 初始化就是 0，且只可能一直往右走，那么只可能在右侧越界
    // 不过我这里就同时判断了，因为在访问数组索引之前保证索引在左右两端都不越界是一个好习惯，没有坏处
    // 另一个好处是让二分的模板更统一，降低你的记忆成本，因为等会儿寻找右边界的时候也有类似的出界判断
    
    // 判断一下 nums[left] 是不是 target
    return nums[left] == target ? left : -1;

### [为什么是 `left = mid + 1` 和 `right = mid`？](#)

为什么 `left = mid + 1`，`right = mid` ？和之前的算法不一样？

答：这个很好解释，因为我们的「搜索区间」是 `[left, right)` 左闭右开，所以当 `nums[mid]` 被检测之后，下一步应该去 `mid` 的左侧或者右侧区间搜索，即 `[left, mid)` 或 `[mid + 1, right)`。

### [为什么该算法能够搜索左侧边界？](#)

答：关键在于对于 `nums[mid] == target` 这种情况的处理：

        if (nums[mid] == target)
            right = mid;

可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 `right`，在区间 `[left, mid)` 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。

### [为什么返回 `left` 而不是 `right`？](#)

答：都是一样的，因为 while 终止的条件是 `left == right`。

### [能否统一成两端都闭的搜索区间？](#)

能不能想办法把 `right` 变成 `nums.length - 1`，也就是继续使用两边都闭的「搜索区间」？这样就可以和第一种二分搜索在某种程度上统一起来了。

答：当然可以，只要你明白了「搜索区间」这个概念，就能有效避免漏掉元素，随便你怎么改都行。下面我们严格根据逻辑来修改：

因为你非要让搜索区间两端都闭，所以 `right` 应该初始化为 `nums.length - 1`，while 的终止条件应该是 `left == right + 1`，也就是其中应该用 `<=`：


cpp 🤖

    int left_bound(vector<int>& nums, int target) {
        // 搜索区间为 [left, right]
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            // if else ...
        }
    }


因为搜索区间是两端都闭的，且现在是搜索左侧边界，所以 `left` 和 `right` 的更新逻辑如下：


cpp 🤖

    if (nums[mid] < target) {
        // 搜索区间变为 [mid+1, right]
        left = mid + 1;
    } else if (nums[mid] > target) {
        // 搜索区间变为 [left, mid-1]
        right = mid - 1;
    } else if (nums[mid] == target) {
        // 收缩右侧边界
        right = mid - 1;
    }


和刚才相同，如果想在找不到 `target` 的时候返回 -1，那么检查一下 `nums[left]` 和 `target` 是否相等即可：


cpp 🤖

    // 此时 target 比所有数都大，返回 -1
    if (left == nums.size()) return -1;
    // 判断一下 nums[left] 是不是 target
    return nums[left] == target ? left : -1;


至此，整个算法就写完了，完整代码如下：


cpp 🤖

    int left_bound(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        // 搜索区间为 [left, right]
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                // 搜索区间变为 [mid+1, right]
                left = mid + 1;
            } else if (nums[mid] > target) {
                // 搜索区间变为 [left, mid-1]
                right = mid - 1;
            } else if (nums[mid] == target) {
                // 收缩右侧边界
                right = mid - 1;
            }
        }
        // 判断 target 是否存在于 nums 中
        // 如果越界，target 肯定不存在，返回 -1
        if (left < 0 || left >= nums.size()) {
            return -1;
        }
        // 判断一下 nums[left] 是不是 target
        return nums[left] == target ? left : -1;
    }

这样就和第一种二分搜索算法统一了，都是两端都闭的「搜索区间」，而且最后返回的也是 `left` 变量的值。只要把住二分搜索的逻辑，两种形式大家看自己喜欢哪种记哪种吧。

[三、寻找右侧边界的二分查找](#)
------------------

类似寻找左侧边界的算法，这里也会提供两种写法，还是先写常见的左闭右开的写法，只有两处和搜索左侧边界不同：

cpp 🤖

    int right_bound(vector<int>& nums, int target) {
        int left = 0, right = nums.size();
    
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                // 注意
                left = mid + 1;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid;
            }
        }
        // 注意
        return left - 1;
    }

### [为什么这个算法能够找到右侧边界？](#)

答：类似地，关键点还是这里：

    if (nums[mid] == target) {
        left = mid + 1;
    }

当 `nums[mid] == target` 时，不要立即返回，而是增大「搜索区间」的左边界 `left`，使得区间不断向右靠拢，达到锁定右侧边界的目的。

### [为什么返回 `left - 1`？](#)

为什么最后返回 `left - 1` 而不像左侧边界的函数，返回 `left`？而且我觉得这里既然是搜索右侧边界，应该返回 `right` 才对。

答：首先，while 循环的终止条件是 `left == right`，所以 `left` 和 `right` 是一样的，你非要体现右侧的特点，返回 `right - 1` 好了。

至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在锁定右边界时的这个条件判断：

    // 增大 left，锁定右侧边界
    if (nums[mid] == target) {
        left = mid + 1;
        // 这样想: mid = left - 1
    }

![](https://labuladong.online/algo/images/binary-search/3.jpg)

因为我们对 `left` 的更新必须是 `left = mid + 1`，就是说 while 循环结束时，`nums[left]` 一定不等于 `target` 了，而 `nums[left-1]` 可能是 `target`。

至于为什么 `left` 的更新必须是 `left = mid + 1`，当然是为了把 `nums[mid]` 排除出搜索区间，这里就不再赘述。

### [如果 `target` 不存在时返回什么？](#)

如果 `nums` 中不存在 `target` 这个值，计算出来的这个索引含义是什么？如果我想让它返回 -1，怎么做？

当 `target` 不存在时，`right_bound` 返回值的含义

直接说结论，和前面讲的 `left_bound` 相反：**如果 `target` 不存在，搜索右侧边界的二分搜索返回的索引是小于 `target` 的最大索引**。

这个结论不用死记，你要是拿不准，简单举个例子就能得到这个结论了。比如 `nums = [2,3,5,7], target = 4`，`right_bound` 函数返回值是 1，因为元素 3 是小于 4 的最大元素。

与前面的建议相同，考虑到二分搜索代码细节的复杂性，如果非必要，不要自己手写，尽可能用编程语言提供的标准库函数。

如果你想在 `target` 不存在时返回 -1，很简单，只要在最后判断一下 `nums[left-1]` 是不是 `target` 就行了，类似之前的左侧边界搜索，做一点额外的判断即可：


cpp 🤖

    while (left < right) {
        // ...
    }
    // 判断 target 是否存在于 nums 中
    // left - 1 索引越界的话 target 肯定不存在
    if (left - 1 < 0 || left - 1 >= nums.size()) {
        return -1;
    }
    // 判断一下 nums[left - 1] 是不是 target
    return nums[left - 1] == target ? (left - 1) : -1;


**4、是否也可以把这个算法的「搜索区间」也统一成两端都闭的形式呢？这样这三个写法就完全统一了，以后就可以闭着眼睛写出来了**。

答：当然可以，类似搜索左侧边界的统一写法，其实只要改两个地方就行了：

cpp 🤖

    int right_bound(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] == target) {
                // 这里改成收缩左侧边界即可
                left = mid + 1;
            }
        }
        // 最后改成返回 left - 1
        if (left - 1 < 0 || left - 1 >= nums.size()) {
            return -1;
        }
        return nums[left - 1] == target ? (left - 1) : -1;
    }


[Algorithm visualize](https://labuladong.online/algo-visualize/tutorial/binary-search-right-bound/)   **算法可视化面板**Link copied!

当然，由于 while 的结束条件为 `right == left - 1`，所以你把上述代码中的 `left - 1` 都改成 `right` 也没有问题，这样可能更有利于看出来这是在「搜索右侧边界」：

    int right_bound(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] == target) {
                // 这里改成收缩左侧边界即可
                left = mid + 1;
            }
        }
        // 最后改成返回 right
        if (right < 0 || right >= nums.length) {
            return -1;
        }
        return nums[right] == target ? right : -1;
    }

至此，搜索右侧边界的二分查找的两种写法也完成了，其实将「搜索区间」统一成两端都闭反而更容易记忆，你说是吧？

[四、逻辑统一](#)
-----------

有了搜索左右边界的二分搜索，你可以去解决力扣第 34 题「[在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)」。接下来梳理一下这些细节差异的因果逻辑：

**第一个，最基本的二分查找算法**：

    因为我们初始化 right = nums.length - 1
    所以决定了我们的「搜索区间」是 [left, right]
    所以决定了 while (left <= right)
    同时也决定了 left = mid+1 和 right = mid-1
    
    因为我们只需找到一个 target 的索引即可
    所以当 nums[mid] == target 时可以立即返回

**第二个，寻找左侧边界的二分查找**：

    因为我们初始化 right = nums.length
    所以决定了我们的「搜索区间」是 [left, right)
    所以决定了 while (left < right)
    同时也决定了 left = mid + 1 和 right = mid
    
    因为我们需找到 target 的最左侧索引
    所以当 nums[mid] == target 时不要立即返回
    而要收紧右侧边界以锁定左侧边界

**第三个，寻找右侧边界的二分查找**：

    因为我们初始化 right = nums.length
    所以决定了我们的「搜索区间」是 [left, right)
    所以决定了 while (left < right)
    同时也决定了 left = mid + 1 和 right = mid
    
    因为我们需找到 target 的最右侧索引
    所以当 nums[mid] == target 时不要立即返回
    而要收紧左侧边界以锁定右侧边界
    
    又因为收紧左侧边界时必须 left = mid + 1
    所以最后无论返回 left 还是 right，必须减一

对于寻找左右边界的二分搜索，比较常见的手法是使用左闭右开的「搜索区间」，**我们还根据逻辑将「搜索区间」全都统一成了两端都闭，便于记忆，只要修改两处即可变化出三种写法**：


cpp 🤖

    int binary_search(vector<int>& nums, int target) {
        int left = 0, right = nums.size()-1; 
        while(left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1; 
            } else if(nums[mid] == target) {
                // 直接返回
                return mid;
            }
        }
        // 直接返回
        return -1;
    }
    
    int left_bound(vector<int>& nums, int target) {
        int left = 0, right = nums.size()-1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] == target) {
                // 别返回，锁定左侧边界
                right = mid - 1;
            }
        }
        // 判断 target 是否存在于 nums 中
        if (left < 0 || left >= nums.size()) {
            return -1;
        }
        // 判断一下 nums[left] 是不是 target
        return nums[left] == target ? left : -1;
    }
    
    int right_bound(vector<int>& nums, int target) {
        int left = 0, right = nums.size()-1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] == target) {
                // 别返回，锁定右侧边界
                left = mid + 1;
            }
        }
        // 由于 while 的结束条件是 right == left - 1，且现在在求右边界
        // 所以用 right 替代 left - 1 更好记
        if (right < 0 || right >= nums.size()) {
            return -1;
        }
        return nums[right] == target ? right : -1;
    }


如果以上内容你都能理解，那么恭喜你，二分查找算法的细节不过如此。通过本文，你学会了：

1、分析二分查找代码时，不要出现 else，全部展开成 else if 方便理解。把逻辑写对之后再合并分支，提升运行效率。

2、注意「搜索区间」和 while 的终止条件，如果存在漏掉的元素，记得在最后检查。

3、如需定义左闭右开的「搜索区间」搜索左右边界，只要在 `nums[mid] == target` 时做修改即可，搜索右侧时需要减一。

4、如果将「搜索区间」全都统一成两端都闭，好记，只要稍改 `nums[mid] == target` 条件处的代码和返回的逻辑即可，推荐拿小本本记下，作为二分搜索模板。

最后我想说，以上二分搜索的框架属于「术」的范畴，如果上升到「道」的层面，**二分思维的精髓就是：通过已知信息尽可能多地收缩（折半）搜索空间**，从而增加穷举效率，快速找到目标。

理解本文能保证你写出正确的二分查找的代码，但实际题目中不会直接让你写二分代码，我会在 [二分查找的运用](https://labuladong.online/algo/frequency-interview/binary-search-in-action/) 和 [二分查找的更多习题](https://labuladong.online/algo/problem-set/binary-search/) 中进一步讲解如何把二分思维运用到更多算法题中。





* * *

**引用本文的题目**


| 题目编号 | 题目名称 | 中文网站链接 | 题目描述 |
| --- | --- | --- | --- |
| 1201 | 丑数 III | [力扣（LeetCode）](https://leetcode.cn/problems/ugly-number-iii/?show=1) | 在排序数组中查找元素的第一个和最后一个位置 |
| 1235 | 规划兼职工作 | [力扣（LeetCode）](https://leetcode.cn/problems/maximum-profit-in-job-scheduling/?show=1) | 规划兼职工作 |
| 162 | 寻找峰值 | [力扣（LeetCode）](https://leetcode.cn/problems/find-peak-element/?show=1) | 寻找峰值 |
| 240 | 搜索二维矩阵 II | [力扣（LeetCode）](https://leetcode.cn/problems/search-a-2d-matrix-ii/?show=1) | 搜索二维矩阵 II |
| 33 | 搜索旋转排序数组 | [力扣（LeetCode）](https://leetcode.cn/problems/search-in-rotated-sorted-array/?show=1) | 搜索旋转排序数组 |
| 35 | 搜索插入位置 | [力扣（LeetCode）](https://leetcode.cn/problems/search-insert-position/?show=1) | 搜索插入位置 |
| 658 | 找到 K 个最接近的元素 | [力扣（LeetCode）](https://leetcode.cn/problems/find-k-closest-elements/?show=1) | 找到 K 个最接近的元素 |
| 74 | 搜索二维矩阵 | [力扣（LeetCode）](https://leetcode.cn/problems/search-a-2d-matrix/?show=1) | 搜索二维矩阵 |
| 792 | 匹配子序列的单词数 | [力扣（LeetCode）](https://leetcode.cn/problems/number-of-matching-subsequences/?show=1) | 匹配子序列的单词数 |
| 793 | 阶乘函数后 K 个零 | [力扣（LeetCode）](https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/?show=1) | 阶乘函数后 K 个零 |
| 81 | 搜索旋转排序数组 II | [力扣（LeetCode）](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/?show=1) | 搜索旋转排序数组 II |
| 852 | 山脉数组的峰顶索引 | [力扣（LeetCode）](https://leetcode.cn/problems/peak-index-in-a-mountain-array/?show=1) | 山脉数组的峰顶索引 |
| 剑指 Offer 04 | 二维数组中的查找 | [力扣（LeetCode）](https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/?show=1) | 二维数组中的查找 |
| 剑指 Offer 53 - I | 在排序数组中查找数字 I | [力扣（LeetCode）](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/?show=1) | 在排序数组中查找数字 I |
| 剑指 Offer 53 - II | 0～n-1中缺失的数字 | [力扣（LeetCode）](https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/?show=1) | 0～n-1中缺失的数字 |
| 剑指 Offer II 068 | 查找插入位置 | [力扣（LeetCode）](https://leetcode.cn/problems/N6YdxV/?show=1) | 查找插入位置 |
| 剑指 Offer II 069 | 山峰数组的顶部 | [力扣（LeetCode）](https://leetcode.cn/problems/B1IidL/?show=1) | 山峰数组的顶部 |




# 二分搜索思维框架



| 题目编号 | 题目名称 | 中文网站链接 | 题目描述 |
| --- | --- | --- | --- |
| 1011 | 在 D 天内送达包裹的能力 | [力扣（LeetCode）](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/) | 在 D 天内送达包裹的能力 |
| 410 | 分割数组的最大值 | [力扣（LeetCode）](https://leetcode.cn/problems/split-array-largest-sum/) | 分割数组的最大值 |
| 875 | 爱吃香蕉的珂珂 | [力扣（LeetCode）](https://leetcode.cn/problems/koko-eating-bananas/) | 爱吃香蕉的珂珂 |
前置知识

阅读本文前，你需要先学习：

*   [二分查找框架详解](https://labuladong.online/algo/essential-technique/binary-search-framework/)

在 [二分查找框架详解](https://labuladong.online/algo/essential-technique/binary-search-framework/) 中我们详细研究了二分搜索的细节问题，探讨了「搜索一个元素」，「搜索左侧边界」，「搜索右侧边界」这三个情况，教你如何写出正确无 bug 的二分搜索算法。

**但是前文总结的二分搜索代码框架仅仅局限于「在有序数组中搜索指定元素」这个基本场景，具体的算法问题没有这么直接，可能你都很难看出这个问题能够用到二分搜索**。

所以本文就来总结一套二分搜索算法运用的框架套路，帮你在遇到二分搜索算法相关的实际问题时，能够有条理地思考分析，步步为营，写出答案。

[原始的二分搜索代码](#)
--------------

二分搜索的原型就是在「**有序数组**」中搜索一个元素 `target`，返回该元素对应的索引。

如果该元素不存在，那可以返回一个什么特殊值，这种细节问题只要微调算法实现就可实现。

还有一个重要的问题，如果「**有序数组**」中存在多个 `target` 元素，那么这些元素肯定挨在一起，这里就涉及到算法应该返回最左侧的那个 `target` 元素的索引还是最右侧的那个 `target` 元素的索引，也就是所谓的「搜索左侧边界」和「搜索右侧边界」，这个也可以通过微调算法的代码来实现。

**我们前文 [二分搜索核心框架](https://labuladong.online/algo/essential-technique/binary-search-framework/) 详细探讨了上述问题，对这块还不清楚的读者建议复习前文**，已经搞清楚基本二分搜索算法的读者可以继续看下去。

**在具体的算法问题中，常用到的是「搜索左侧边界」和「搜索右侧边界」这两种场景**，很少有让你单独「搜索一个元素」。

因为算法题一般都让你求最值，比如让你求吃香蕉的「最小速度」，让你求轮船的「最低运载能力」，求最值的过程，必然是搜索一个边界的过程，所以后面我们就详细分析一下这两种搜索边界的二分算法代码。

Note

注意，本文我写的都是左闭右开的二分搜索写法，如果你习惯两端都闭的写法，可以自行改写代码。

「搜索左侧边界」的二分搜索算法的具体代码实现如下：


cpp 🤖

    // 搜索左侧边界
    int left_bound(vector<int>& nums, int target) {
        if (nums.size() == 0) return -1;
        int left = 0, right = nums.size();
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                // 当找到 target 时，收缩右侧边界
                right = mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid;
            }
        }
        return left;
    }


假设输入的数组 `nums = [1,2,3,3,3,5,7]`，想搜索的元素 `target = 3`，那么算法就会返回索引 2。

如果画一个图，就是这样：

![](https://labuladong.online/algo/images/binary-search-in-action/1.jpeg)

「搜索右侧边界」的二分搜索算法的具体代码实现如下：


cpp 🤖

    // 搜索右侧边界
    int right_bound(vector<int>& nums, int target) {
        if (nums.size() == 0) return -1;
        int left = 0, right = nums.size();
    
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                // 当找到 target 时，收缩左侧边界
                left = mid + 1;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid;
            }
        }
        return left - 1;
    }


输入同上，那么算法就会返回索引 4，如果画一个图，就是这样：

![](https://labuladong.online/algo/images/binary-search-in-action/2.jpeg)

好，上述内容都属于复习，我想读到这里的读者应该都能理解。记住上述的图像，所有能够抽象出上述图像的问题，都可以使用二分搜索解决。

二分搜索问题的泛化
---------

运用二分搜索的套路框架
-----------

例题一、珂珂吃香蕉
---------

例题二、运送货物
--------

例题三、分割数组
--------

🌟

* * *



[二分搜索问题的泛化](#)
--------------

什么问题可以运用二分搜索算法技巧？

**首先，你要从题目中抽象出一个自变量 `x`，一个关于 `x` 的函数 `f(x)`，以及一个目标值 `target`**。

同时，`x, f(x), target` 还要满足以下条件：

**1、`f(x)` 必须是在 `x` 上的单调函数（单调增单调减都可以）**。

**2、题目是让你计算满足约束条件 `f(x) == target` 时的 `x` 的值**。

上述规则听起来有点抽象，来举个具体的例子：

给你一个升序排列的有序数组 `nums` 以及一个目标元素 `target`，请你计算 `target` 在数组中的索引位置，如果有多个目标元素，返回最小的索引。

这就是「搜索左侧边界」这个基本题型，解法代码之前都写了，但这里面 `x, f(x), target` 分别是什么呢？

我们可以把数组中元素的索引认为是自变量 `x`，函数关系 `f(x)` 就可以这样设定：


cpp 🤖

    // 函数 f(x) 是关于自变量 x 的单调递增函数
    // 入参 nums 是不会改变的，所以可以忽略，不算自变量
    int f(int x, vector<int>& nums) {
        return nums[x];
    }


其实这个函数 `f` 就是在访问数组 `nums`，因为题目给我们的数组 `nums` 是升序排列的，所以函数 `f(x)` 就是在 `x` 上单调递增的函数。

最后，题目让我们求什么来着？是不是让我们计算元素 `target` 的最左侧索引？

是不是就相当于在问我们「满足 `f(x) == target` 的 `x` 的最小值是多少」？

画个图，如下：

![](https://labuladong.online/algo/images/binary-search-in-action/3.jpeg)

**如果遇到一个算法问题，能够把它抽象成这幅图，就可以对它运用二分搜索算法**。

算法代码如下：


cpp 🤖

    // 函数 f 是关于自变量 x 的单调递增函数
    int f(int x, int nums[]) {
        return nums[x];
    }
    
    int left_bound(int nums[], int length, int target) {
        if (length == 0) return -1;
        int left = 0, right = length;
    
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (f(mid, nums) == target) {
                // 当找到 target 时，收缩右侧边界
                right = mid;
            } else if (f(mid, nums) < target) {
                left = mid + 1;
            } else if (f(mid, nums) > target) {
                right = mid;
            }
        }
        return left;
    }


这段代码其实是多此一举，把之常规的二分搜索代码微调了一下，把直接访问 `nums[mid]` 套了一层函数 `f`。但是，这样能抽象出二分搜索思想在具体算法问题中的框架。

[运用二分搜索的套路框架](#)
----------------

想要运用二分搜索解决具体的算法问题，可以从以下代码框架着手思考：


cpp 🤖

    // 函数 f 是关于自变量 x 的单调函数
    int f(int x) {
        // ...
    }
    
    // 主函数，在 f(x) == target 的约束下求 x 的最值
    int solution(vector<int>& nums, int target) {
        if (nums.size() == 0) return -1;
        // 问自己：自变量 x 的最小值是多少？
        int left = ...;
        // 问自己：自变量 x 的最大值是多少？
        int right = ... + 1;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (f(mid) == target) {
                // 问自己：题目是求左边界还是右边界？
                // ...
            } else if (f(mid) < target) {
                // 问自己：怎么让 f(x) 大一点？
                // ...
            } else if (f(mid) > target) {
                // 问自己：怎么让 f(x) 小一点？
                // ...
            }
        }
        return left;
    }


具体来说，想要用二分搜索算法解决问题，分为以下几步：

**1、确定 `x, f(x), target` 分别是什么，并写出函数 `f` 的代码**。

**2、找到 `x` 的取值范围作为二分搜索的搜索区间，初始化 `left` 和 `right` 变量**。

**3、根据题目的要求，确定应该使用搜索左侧还是搜索右侧的二分搜索算法，写出解法代码**。

下面用几道例题来讲解这个流程。

[例题一、珂珂吃香蕉](#)
--------------

这是力扣第 875 题「[爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/)」：

**875\. 爱吃香蕉的珂珂** | [力扣](https://leetcode.cn/problems/koko-eating-bananas/) | [LeetCode](https://leetcode.com/problems/koko-eating-bananas/) |  🟠

珂珂喜欢吃香蕉。这里有 `n` 堆香蕉，第 `i` 堆中有 `piles[i]` 根香蕉。警卫已经离开了，将在 `h` 小时后回来。

珂珂可以决定她吃香蕉的速度 `k` （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 `k` 根。如果这堆香蕉少于 `k` 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  

珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。

返回她可以在 `h` 小时内吃掉所有香蕉的最小速度 `k`（`k` 为整数）。

**示例 1：**

**输入：**piles = \[3,6,7,11\], h = 8
**输出：**4

**示例 2：**

**输入：**piles = \[30,11,23,4,20\], h = 5
**输出：**30

**示例 3：**

**输入：**piles = \[30,11,23,4,20\], h = 6
**输出：**23

**提示：**

*   `1 <= piles.length <= 104`
*   `piles.length <= h <= 109`
*   `1 <= piles[i] <= 109`

**题目来源：[力扣 875. 爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/)。**

珂珂每小时最多只能吃一堆香蕉，如果吃不完的话留到下一小时再吃；如果吃完了这一堆还有胃口，也只会等到下一小时才会吃下一堆。

他想在警卫回来之前吃完所有香蕉，让我们确定吃香蕉的**最小速度 `K`**。函数签名如下：

cpp 🤖

    int minEatingSpeed(vector<int>& piles, int H);


那么，对于这道题，如何运用刚才总结的套路，写出二分搜索解法代码？

按步骤思考即可：

**1、确定 `x, f(x), target` 分别是什么，并写出函数 `f` 的代码**。

自变量 `x` 是什么呢？回忆之前的函数图像，二分搜索的本质就是在搜索自变量。

所以，题目让求什么，就把什么设为自变量，珂珂吃香蕉的速度就是自变量 `x`。

那么，在 `x` 上单调的函数关系 `f(x)` 是什么？

显然，吃香蕉的速度越快，吃完所有香蕉堆所需的时间就越少，速度和时间就是一个单调函数关系。

所以，`f(x)` 函数就可以这样定义：

若吃香蕉的速度为 `x` 根/小时，则需要 `f(x)` 小时吃完所有香蕉。

代码实现如下：


cpp 🤖

    // 定义：速度为 x 时，需要 f(x) 小时吃完所有香蕉
    // f(x) 随着 x 的增加单调递减
    int f(vector<int>& piles, int x) {
        int hours = 0;
        for (int i = 0; i < piles.size(); i++) {
            hours += piles[i] / x;
            if (piles[i] % x > 0) {
                hours++;
            }
        }
        return hours;
    }


为什么 `f(x)` 的返回值是 `long` 类型？因为你注意题目给的数据范围和 `f` 函数的逻辑。`piles` 数组中元素的最大值是 10^9，最多有 10^4 个元素；那么当 `x` 取值为 1 时，`hours` 变量就会被加到 10^13 这个数量级，超过了 `int` 类型的最大值（大概 2x10^9 这个量级），所以这里用 `long` 类型避免可能出现的整型溢出。

`target` 就很明显了，吃香蕉的时间限制 `H` 自然就是 `target`，是对 `f(x)` 返回值的最大约束。

**2、找到 `x` 的取值范围作为二分搜索的搜索区间，初始化 `left` 和 `right` 变量**。

珂珂吃香蕉的速度最小是多少？多大是多少？

显然，最小速度应该是 1，最大速度是 `piles` 数组中元素的最大值，因为每小时最多吃一堆香蕉，胃口再大也白搭嘛。

这里可以有两种选择，要么你用一个 for 循环去遍历 `piles` 数组，计算最大值，要么你看题目给的约束，`piles` 中的元素取值范围是多少，然后给 `right` 初始化一个取值范围之外的值。

我选择第二种，题目说了 `1 <= piles[i] <= 10^9`，那么我就可以确定二分搜索的区间边界：


cpp 🤖

    int minEatingSpeed(vector<int>& piles, int H) {
        int left = 1;
        // 注意，right 是开区间，所以再加一
        int right = 1000000000 + 1;
    
        // ...
    }


因为我们二分搜索是对数级别的复杂度，所以 `right` 就算是个很大的值，算法的效率依然很高。

**3、根据题目的要求，确定应该使用搜索左侧还是搜索右侧的二分搜索算法，写出解法代码**。

现在我们确定了自变量 `x` 是吃香蕉的速度，`f(x)` 是单调递减的函数，`target` 就是吃香蕉的时间限制 `H`，题目要我们计算最小速度，也就是 `x` 要尽可能小：

![](https://labuladong.online/algo/images/binary-search-in-action/4.jpeg)

这就是搜索左侧边界的二分搜索嘛，不过注意 `f(x)` 是单调递减的，不要闭眼睛套框架，需要结合上图进行思考，写出代码：


cpp 🤖

    class Solution {
    public:
        int minEatingSpeed(vector<int>& piles, int H) {
            int left = 1;
            int right = 1000000000 + 1;
            
            while (left < right) {
                int mid = left + (right - left) / 2;
                if (f(piles, mid) == H) {
                    // 搜索左侧边界，则需要收缩右侧边界
                    right = mid;
                } else if (f(piles, mid) < H) {
                    // 需要让 f(x) 的返回值大一些
                    right = mid;
                } else if (f(piles, mid) > H) {
                    // 需要让 f(x) 的返回值小一些
                    left = mid + 1;
                }
            }
            return left;
        }
    };


我这里采用的是左闭右开的二分搜索写法，如果想用两端都闭的写法，只要修改 `right` 的初始值和 `right` 更新的逻辑即可：

    // 两端都闭的二分搜索写法
    int minEatingSpeed(int[] piles, int H) {
        int left = 1;
        // right 是闭区间，所以这里改成最大取值
        int right = 1000000000;
    
        // right 是闭区间，所以这里改成 <=
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (f(piles, mid) <= H) {
                // right 是闭区间，所以这里用 mid - 1
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }

关于这个算法中的细节问题，前文 [二分搜索算法详解](https://labuladong.online/algo/essential-technique/binary-search-framework/) 进行了详细分析，这里不展开了。

至此，这道题就解决了。我们代码框架中多余的 if 分支主要是帮助理解的，写出正确解法后建议合并多余的分支，可以提高算法运行的效率：


cpp 🤖

    class Solution {
    public:
        int minEatingSpeed(vector<int>& piles, int H) {
            int left = 1;
            int right = 1000000000 + 1;
    
            while (left < right) {
                int mid = left + (right - left) / 2;
                if (f(piles, mid) <= H) {
                    right = mid;
                } else {
                    left = mid + 1;
                }
            }
            return left;
        }
    
        // f(x) 随着 x 的增加单调递减
        long f(vector<int>& piles, int x) {
            long hours = 0;
            for (int i = 0; i < piles.size(); i++) {
                hours += piles[i] / x;
                if (piles[i] % x > 0) {
                    hours++;
                }
            }
            return hours;
        }
    };


[例题二、运送货物](#)
-------------

再看看力扣第 1011 题「[在 D 天内送达包裹的能力](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/)」：

**1011\. 在 D 天内送达包裹的能力** | [力扣](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/) | [LeetCode](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/) |  🟠

传送带上的包裹必须在 `days` 天内从一个港口运送到另一个港口。

传送带上的第 `i` 个包裹的重量为 `weights[i]`。每一天，我们都会按给出重量（`weights`）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。

返回能在 `days` 天内将传送带上的所有包裹送达的船的最低运载能力。

**示例 1：**

**输入：**weights = \[1,2,3,4,5,6,7,8,9,10\], days = 5
**输出：**15
**解释：**
船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：
第 1 天：1, 2, 3, 4, 5
第 2 天：6, 7
第 3 天：8
第 4 天：9
第 5 天：10

请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 

**示例 2：**

**输入：**weights = \[3,2,2,4,1,4\], days = 3
**输出：**6
**解释：**
船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：
第 1 天：3, 2
第 2 天：2, 4
第 3 天：1, 4

**示例 3：**

**输入：**weights = \[1,2,3,1,1\], days = 4
**输出：**3
**解释：**
第 1 天：1
第 2 天：2
第 3 天：3
第 4 天：1, 1

**提示：**

*   `1 <= days <= weights.length <= 5 * 104`
*   `1 <= weights[i] <= 500`

**题目来源：[力扣 1011. 在 D 天内送达包裹的能力](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/)。**

要在 `D` 天内按顺序运输完所有货物，货物不可分割，如何确定运输的最小载重呢？

函数签名如下：


cpp 🤖

    int shipWithinDays(vector<int>& weights, int days);


和上一道题一样的，我们按照流程来就行：

**1、确定 `x, f(x), target` 分别是什么，并写出函数 `f` 的代码**。

题目问什么，什么就是自变量，也就是说船的运载能力就是自变量 `x`。

运输天数和运载能力成反比，所以可以让 `f(x)` 计算 `x` 的运载能力下需要的运输天数，那么 `f(x)` 是单调递减的。

函数 `f(x)` 的实现如下：


cpp 🤖

    // 定义：当运载能力为 x 时，需要 f(x) 天运完所有货物
    // f(x) 随着 x 的增加单调递减
    int f(vector<int> &weights, int x) {
        int days = 0;
        for (int i = 0; i < weights.size(); ) {
            // 尽可能多装货物
            int cap = x;
            while (i < weights.size()) {
                if (cap < weights[i]) break;
                else cap -= weights[i];
                i++;
            }
            days++;
        }
        return days;
    }


对于这道题，`target` 显然就是运输天数 `D`，我们要在 `f(x) == D` 的约束下，算出船的最小载重。

**2、找到 `x` 的取值范围作为二分搜索的搜索区间，初始化 `left` 和 `right` 变量**。

船的最小载重是多少？最大载重是多少？

显然，船的最小载重应该是 `weights` 数组中元素的最大值，因为每次至少得装一件货物走，不能说装不下嘛。

最大载重显然就是`weights` 数组所有元素之和，也就是一次把所有货物都装走。

这样就确定了搜索区间 `[left, right)`：


cpp 🤖

    int shipWithinDays(vector<int>& weights, int days) {
        int left = 0;
        // 注意，right 是开区间，所以额外加一
        int right = 1;
        for (int w : weights) {
            left = max(left, w);
            right += w;
        }
        
        // ...
    }


**3、需要根据题目的要求，确定应该使用搜索左侧还是搜索右侧的二分搜索算法，写出解法代码**。

现在我们确定了自变量 `x` 是船的载重能力，`f(x)` 是单调递减的函数，`target` 就是运输总天数限制 `D`，题目要我们计算船的最小载重，也就是 `x` 要尽可能小：

![](https://labuladong.online/algo/images/binary-search-in-action/5.jpeg)

这就是搜索左侧边界的二分搜索嘛，结合上图就可写出二分搜索代码：


cpp 🤖

    int shipWithinDays(vector<int>& weights, int days) {
        int left = 0;
        // 注意，right 是开区间，所以额外加一
        int right = 1;
        for (int w : weights) {
            left = max(left, w);
            right += w;
        }
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (f(weights, mid) == days) {
                // 搜索左侧边界，则需要收缩右侧边界
                right = mid;
            } else if (f(weights, mid) < days) {
                // 需要让 f(x) 的返回值大一些
                right = mid;
            } else if (f(weights, mid) > days) {
                // 需要让 f(x) 的返回值小一些
                left = mid + 1;
            }
        }
        
        return left;
    }


到这里，这道题的解法也写出来了，我们合并一下多余的 if 分支，提高代码运行速度，最终代码如下：


cpp 🤖

    class Solution {
    public:
        int shipWithinDays(vector<int>& weights, int days) {
            int left = 0, right = 1;
            for (int weight : weights) {
                left = max(left, weight);
                right += weight;
            }
            while (left < right) {
                int mid = left + (right - left) / 2;
                if (f(weights, mid) <= days) {
                    right = mid;
                } else {
                    left = mid + 1;
                }
            }
            return left;
        }
    
    private:
        int f(vector<int>& weights, int x) {
            int days = 0;
            for (int i = 0; i < weights.size(); ) {
                int cap = x;
                while (i < weights.size()) {
                    if (cap < weights[i]) break;
                    else cap -= weights[i];
                    i++;
                }
                days++;
            }
            return days;
        }
    };


[Algorithm visualize](https://labuladong.online/algo-visualize/leetcode/capacity-to-ship-packages-within-d-days/)   **算法可视化面板**Link copied!

[例题三、分割数组](#)
-------------

我们实操一下力扣第 410 题「[分割数组的最大值](https://leetcode.cn/problems/split-array-largest-sum/)」，难度为困难：

**410\. 分割数组的最大值** | [力扣](https://leetcode.cn/problems/split-array-largest-sum/) | [LeetCode](https://leetcode.com/problems/split-array-largest-sum/) |  🔴

给定一个非负整数数组 `nums` 和一个整数 `k` ，你需要将这个数组分成 `k` 个非空的连续子数组。

设计一个算法使得这 `k` 个子数组各自和的最大值最小。

**示例 1：**

**输入：**nums = \[7,2,5,10,8\], k = 2
**输出：**18
**解释：**
一共有四种方法将 nums 分割为 2 个子数组。 
其中最好的方式是将其分为 \[7,2,5\] 和 \[10,8\] 。
因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。

**示例 2：**

**输入：**nums = \[1,2,3,4,5\], k = 2
**输出：**9

**示例 3：**

**输入：**nums = \[1,4,4\], k = 3
**输出：**4

**提示：**

*   `1 <= nums.length <= 1000`
*   `0 <= nums[i] <= 106`
*   `1 <= k <= min(50, nums.length)`

**题目来源：[力扣 410. 分割数组的最大值](https://leetcode.cn/problems/split-array-largest-sum/)。**

函数签名如下：


cpp 🤖

    int splitArray(vector<int>& nums, int m);


这个题目有点类似前文一道经典动态规划题目 [高楼扔鸡蛋](https://labuladong.online/algo/dynamic-programming/egg-drop/)，题目比较绕，又是最大值又是最小值的。

简单说，给你输入一个数组 `nums` 和数字 `m`，你要把 `nums` 分割成 `m` 个子数组。

肯定有不止一种分割方法，每种分割方法都会把 `nums` 分成 `m` 个子数组，这 `m` 个子数组中肯定有一个和最大的子数组对吧。

我们想要找一个分割方法，该方法分割出的最大子数组和是所有方法中最大子数组和最小的。

请你的算法返回这个分割方法对应的最大子数组和。

我滴妈呀，这个题目看了就觉得难的不行，完全没思路，这题怎么运用我们之前说套路，转化成二分搜索呢？

**其实，这道题和上面讲的运输问题是一模一样的，不相信的话我给你改写一下题目**：

你只有一艘货船，现在有若干货物，每个货物的重量是 `nums[i]`，现在你需要在 `m` 天内将这些货物运走，请问你的货船的最小载重是多少？

这不就是刚才我们解决的力扣第 1011 题「[在 D 天内送达包裹的能力](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/)」吗？

货船每天运走的货物就是 `nums` 的一个子数组；在 `m` 天内运完就是将 `nums` 划分成 `m` 个子数组；让货船的载重尽可能小，就是让所有子数组中最大的那个子数组元素之和尽可能小。

所以这道题的解法直接复制粘贴运输问题的解法代码即可：

cpp 🤖

    class Solution {
    public:
        int splitArray(vector<int>& nums, int m) {
            return shipWithinDays(nums, m);
        }
    
    private:
        int shipWithinDays(vector<int>& weights, int days) {
            // 见上文
        }
    
        int f(vector<int>& weights, int x) {
            // 见上文
        }
    };


本文就到这里，总结来说，如果发现题目中存在单调关系，就可以尝试使用二分搜索的思路来解决。搞清楚单调性和二分搜索的种类，通过分析和画图，就能够写出最终的代码。

* * *

## 引用本文的题目
| 题目编号 | 题目名称 | 中文网站链接 | 题目描述 |
| --- | --- | --- | --- |
| 1201 | 丑数 III | [力扣（LeetCode）](https://leetcode.cn/problems/ugly-number-iii/?show=1) | 丑数 III |
| 1723 | 完成所有工作的最短时间 | [力扣（LeetCode）](https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs/?show=1) | 完成所有工作的最短时间 |
| 剑指 Offer II 073 | 狒狒吃香蕉 | [力扣（LeetCode）](https://leetcode.cn/problems/nZZqjQ/?show=1) | 狒狒吃香蕉 |



# 灵府山二分题单
![](https://pic.leetcode.cn/1711713491-SoiQWc-t2.png)

> 图：闭区间二分循环结束时的左右指针位置（查找第一个 8）

题目已按照难度分排序，右侧数字为难度分。

如果遇到难度很大，题解都看不懂的题目，建议直接收藏，过段时间再来做。

一、二分查找
------

### §1.1 基础

请先学习：[二分查找 红蓝染色法【基础算法精讲 04】](https://leetcode.cn/link/?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1AP41137w7%2F)

*   [34\. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)
*   [35\. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)
*   [704\. 二分查找](https://leetcode.cn/problems/binary-search/)
*   [744\. 寻找比目标字母大的最小字母](https://leetcode.cn/problems/find-smallest-letter-greater-than-target/)
*   [2529\. 正整数和负整数的最大计数](https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/)

### §1.2 进阶

部分题目需要先排序，然后在有序数组上二分查找。

*   [2300\. 咒语和药水的成功对数](https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/) 1477
*   [1385\. 两个数组间的距离值](https://leetcode.cn/problems/find-the-distance-value-between-two-arrays/)
*   [2389\. 和有限的最长子序列](https://leetcode.cn/problems/longest-subsequence-with-limited-sum/)
*   [1170\. 比较字符串最小字母出现频次](https://leetcode.cn/problems/compare-strings-by-frequency-of-the-smallest-character/)
*   [2080\. 区间内查询数字的频率](https://leetcode.cn/problems/range-frequency-queries/) 1702
*   [3488\. 距离最小相等元素查询](https://leetcode.cn/problems/closest-equal-element-queries/) 做法不止一种
*   [2563\. 统计公平数对的数目](https://leetcode.cn/problems/count-the-number-of-fair-pairs/) 1721
*   [2070\. 每一个查询的最大美丽值](https://leetcode.cn/problems/most-beautiful-item-for-each-query/) 1724
*   [1146\. 快照数组](https://leetcode.cn/problems/snapshot-array/) 1771
*   [981\. 基于时间的键值存储](https://leetcode.cn/problems/time-based-key-value-store/) 同 1146 题
*   [3508\. 设计路由器](https://leetcode.cn/problems/implement-router/) ~1800
*   [658\. 找到 K 个最接近的元素](https://leetcode.cn/problems/find-k-closest-elements/)
*   [1818\. 绝对差值和](https://leetcode.cn/problems/minimum-absolute-sum-difference/) 1934
*   [911\. 在线选举](https://leetcode.cn/problems/online-election/) 2001
*   [LCP 08. 剧情触发时间](https://leetcode.cn/problems/ju-qing-hong-fa-shi-jian/)
*   [1182\. 与目标颜色间的最短距离](https://leetcode.cn/problems/shortest-distance-to-target-color/)（会员题）
*   [2819\. 购买巧克力后的最小相对损失](https://leetcode.cn/problems/minimum-relative-loss-after-buying-chocolates/)（会员题）

**思维扩展**：

*   [1287\. 有序数组中出现次数超过 25% 的元素](https://leetcode.cn/problems/element-appearing-more-than-25-in-sorted-array/) 做到 O(logn)
*   [1150\. 检查一个数是否在数组中占绝大多数](https://leetcode.cn/problems/check-if-a-number-is-majority-element-in-a-sorted-array/)（会员题）

二、二分答案
------

> “花费一个 log 的时间，增加了一个条件。” —— 二分答案

### §2.1 求最小

题目求什么，就二分什么。

#### 答疑

**问**：如何把二分答案与数组上的二分查找联系起来？

**答**：假设范围是 \[2,3,4,5\]，我们相当于在一个**虚拟数组** \[check(2),check(3),check(4),check(5)\] 中二分找第一个（或者最后一个）值为 true 的 check(i)。这同样可以用红蓝染色法思考。

**问**：有些题目，明明 m 可以是答案，但却不在初始二分区间中。比如闭区间二分初始化 right\=m−1（或者开区间 right\=m），这不会算错吗？

**答**：不会算错。想一想，如果二分的 while 循环每次更新的都是 left，那么最终答案是什么？正好就是 m。一般地，如果一开始就能确定 m 一定可以满足题目要求，那么 m 是不需要在二分区间中的。换句话说，二分区间是「尚未确定是否满足题目要求」的数的范围。那些在区间外面的数，都是已确定的满足（不满足）题目要求的数。

**问**：什么是循环不变量？

**答**：想一想，对于求最小的题目，**开区间二分**的写法，为什么最终返回的是 right，而不是别的数？在初始化（循环之前）、循环中、循环结束后，都时时刻刻保证 `check(right) == true` 和 `check(left) == false`，这就叫**循环不变量**。根据循环不变量，循环结束时 `left + 1 == right`，那么 right 就是最小的满足要求的数（因为再 −1 就不满足要求了），所以答案是 right。

**注**：部分题目可以优化二分边界，减少二分次数，从而减少代码运行时间。对于初次接触二分答案的同学，无需强求自己写出最优的代码，设定一个比较大的二分上界也是可以的。

*   [1283\. 使结果不超过阈值的最小除数](https://leetcode.cn/problems/find-the-smallest-divisor-given-a-threshold/) 1542
*   [2187\. 完成旅途的最少时间](https://leetcode.cn/problems/minimum-time-to-complete-trips/) 1641
*   [1011\. 在 D 天内送达包裹的能力](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/) 1725
*   [875\. 爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/) 1766
*   [3296\. 移山所需的最少秒数](https://leetcode.cn/problems/minimum-number-of-seconds-to-make-mountain-height-zero/) 注：由于有其他做法，难度分会低一些，二分做法估计 1850
*   [475\. 供暖器](https://leetcode.cn/problems/heaters/)
*   [2594\. 修车的最少时间](https://leetcode.cn/problems/minimum-time-to-repair-cars/) 1915
*   [1482\. 制作 m 束花所需的最少天数](https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets/) 1946
*   [3048\. 标记所有下标的最早秒数 I](https://leetcode.cn/problems/earliest-second-to-mark-indices-i/) 2263
*   [2604\. 吃掉所有谷子的最短时间](https://leetcode.cn/problems/minimum-time-to-eat-all-grains/)（会员题）
*   [2702\. 使数字变为非正数的最小操作次数](https://leetcode.cn/problems/minimum-operations-to-make-numbers-non-positive/)（会员题）

**思维扩展**：

*   [1870\. 准时到达的列车最小时速](https://leetcode.cn/problems/minimum-speed-to-arrive-on-time/) 1676 避免浮点数
*   [3453\. 分割正方形 I](https://leetcode.cn/problems/separate-squares-i/) 1735 浮点二分（也可以避免浮点数）

### §2.2 求最大

[一图掌握二分答案！四种写法！](https://leetcode.cn/problems/h-index-ii/solution/tu-jie-yi-tu-zhang-wo-er-fen-da-an-si-ch-d15k/)

在练习时，请注意「求最小」和「求最大」的二分写法上的区别。

前面的「求最小」和二分查找求「排序数组中某元素的第一个位置」是类似的，按照红蓝染色法，左边是不满足要求的（红色），右边则是满足要求的（蓝色）。

「求最大」的题目则相反，左边是满足要求的（蓝色），右边是不满足要求的（红色）。这会导致二分写法和上面的「求最小」有一些区别。

以开区间二分为例：

*   求最小：`check(mid) == true` 时更新 `right = mid`，反之更新 `left = mid`，最后返回 `right`。
*   求最大：`check(mid) == true` 时更新 `left = mid`，反之更新 `right = mid`，最后返回 `left`。

对于开区间写法，简单来说 `check(mid) == true` 时更新的是谁，最后就返回谁。相比其他二分写法，开区间写法不需要思考加一减一等细节，**推荐使用开区间写二分**。

*   [275\. H 指数 II](https://leetcode.cn/problems/h-index-ii/)
*   [2226\. 每个小孩最多能分到多少糖果](https://leetcode.cn/problems/maximum-candies-allocated-to-k-children/) 1646
*   [2982\. 找出出现至少三次的最长特殊子字符串 II](https://leetcode.cn/problems/find-longest-special-substring-that-occurs-thrice-ii/) 1773
*   [2576\. 求出最多标记下标](https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/) 1843
*   [1898\. 可移除字符的最大数目](https://leetcode.cn/problems/maximum-number-of-removable-characters/) 1913
*   [1802\. 有界数组中指定下标处的最大值](https://leetcode.cn/problems/maximum-value-at-a-given-index-in-a-bounded-array/) 1929
*   [1642\. 可以到达的最远建筑](https://leetcode.cn/problems/furthest-building-you-can-reach/) 1962
*   [2861\. 最大合金数](https://leetcode.cn/problems/maximum-number-of-alloys/) 1981
*   [3007\. 价值和小于等于 K 的最大数字](https://leetcode.cn/problems/maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k/) 2258
*   [2141\. 同时运行 N 台电脑的最长时间](https://leetcode.cn/problems/maximum-running-time-of-n-computers/) 2265
*   [2258\. 逃离火灾](https://leetcode.cn/problems/escape-the-spreading-fire/) 2347
*   [2071\. 你可以安排的最多任务数目](https://leetcode.cn/problems/maximum-number-of-tasks-you-can-assign/) 2648
*   [LCP 78. 城墙防线](https://leetcode.cn/problems/Nsibyl/)
*   [1618\. 找出适应屏幕的最大字号](https://leetcode.cn/problems/maximum-font-to-fit-a-sentence-in-a-screen/)（会员题）
*   [1891\. 割绳子](https://leetcode.cn/problems/cutting-ribbons/)（会员题）
*   [2137\. 通过倒水操作让所有的水桶所含水量相等](https://leetcode.cn/problems/pour-water-between-buckets-to-make-water-levels-equal/)（会员题）
*   [644\. 子数组最大平均数 II](https://leetcode.cn/problems/maximum-average-subarray-ii/)（会员题）

### §2.3 二分间接值

二分的不是答案，而是一个和答案有关的值（间接值）。

*   [3143\. 正方形中的最多点数](https://leetcode.cn/problems/maximum-points-inside-the-square/) 1697
*   [1648\. 销售价值减少的颜色球](https://leetcode.cn/problems/sell-diminishing-valued-colored-balls/) 2050

### §2.4 最小化最大值

本质是二分答案求最小。二分的 mid 表示上界。

*   [410\. 分割数组的最大值](https://leetcode.cn/problems/split-array-largest-sum/)
*   [2064\. 分配给商店的最多商品的最小值](https://leetcode.cn/problems/minimized-maximum-of-products-distributed-to-any-store/) 1886
*   [1760\. 袋子里最少数目的球](https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag/) 1940
*   [1631\. 最小体力消耗路径](https://leetcode.cn/problems/path-with-minimum-effort/) 1948
*   [2439\. 最小化数组中的最大值](https://leetcode.cn/problems/minimize-maximum-of-array/) 1965
*   [2560\. 打家劫舍 IV](https://leetcode.cn/problems/house-robber-iv/) 2081
*   [778\. 水位上升的泳池中游泳](https://leetcode.cn/problems/swim-in-rising-water/) 2097 相当于最小化路径最大值
*   [2616\. 最小化数对的最大差值](https://leetcode.cn/problems/minimize-the-maximum-difference-of-pairs/) 2155
*   [3419\. 图的最大边权的最小值](https://leetcode.cn/problems/minimize-the-maximum-edge-weight-of-graph/) 2243
*   [2513\. 最小化两个数组中的最大值](https://leetcode.cn/problems/minimize-the-maximum-of-two-arrays/) 2302
*   [3399\. 字符相同的最短子字符串 II](https://leetcode.cn/problems/smallest-substring-with-identical-characters-ii/) 2376
*   [LCP 12. 小张刷题计划](https://leetcode.cn/problems/xiao-zhang-shua-ti-ji-hua/)
*   [774\. 最小化去加油站的最大距离](https://leetcode.cn/problems/minimize-max-distance-to-gas-station/)（会员题）

### §2.5 最大化最小值

本质是二分答案求最大。二分的 mid 表示下界。

*   [3281\. 范围内整数的最大得分](https://leetcode.cn/problems/maximize-score-of-numbers-in-ranges/) 1768
*   [2517\. 礼盒的最大甜蜜度](https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/) 2021
*   [1552\. 两球之间的磁力](https://leetcode.cn/problems/magnetic-force-between-two-balls/) 同 2517 题
*   [2812\. 找出最安全路径](https://leetcode.cn/problems/find-the-safest-path-in-a-grid/) 2154
*   [2528\. 最大化城市的最小电量](https://leetcode.cn/problems/maximize-the-minimum-powered-city/) 2236
*   [3449\. 最大化游戏分数的最小值](https://leetcode.cn/problems/maximize-the-minimum-game-score/) 2748
*   [3464\. 正方形上的点之间的最大距离](https://leetcode.cn/problems/maximize-the-distance-between-points-on-a-square/) 2806
*   [1102\. 得分最高的路径](https://leetcode.cn/problems/path-with-maximum-minimum-value/)（会员题）
*   [1231\. 分享巧克力](https://leetcode.cn/problems/divide-chocolate/)（会员题）

### §2.6 第 K 小/大

例如数组 \[1,1,1,2,2\]，其中第 1 小、第 2 小和第 3 小的数都是 1，第 4 小和第 5 小的数都是 2。

*   第 k 小等价于：求**最小**的 x，满足 ≤x 的数**至少**有 k 个。
*   第 k 大等价于：求**最大**的 x，满足 ≥x 的数**至少**有 k 个。

> 注 1：一般规定 k 从 1 开始，而不是像数组下标那样从 0 开始。
> 
> 注 2：部分题目也可以用堆解决。

*   [668\. 乘法表中第 K 小的数](https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/)
*   [378\. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/)
*   [719\. 找出第 K 小的数对距离](https://leetcode.cn/problems/find-k-th-smallest-pair-distance/)
*   [878\. 第 N 个神奇数字](https://leetcode.cn/problems/nth-magical-number/) 1897
*   [1201\. 丑数 III](https://leetcode.cn/problems/ugly-number-iii/) 2039
*   [793\. 阶乘函数后 K 个零](https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/) 2100
*   [373\. 查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/)
*   [1439\. 有序矩阵中的第 k 个最小数组和](https://leetcode.cn/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/) 2134
*   [786\. 第 K 个最小的质数分数](https://leetcode.cn/problems/k-th-smallest-prime-fraction/) 2169
*   [3116\. 单面值组合的第 K 小金额](https://leetcode.cn/problems/kth-smallest-amount-with-single-denomination-combination/) 2387
*   [3134\. 找出唯一性数组的中位数](https://leetcode.cn/problems/find-the-median-of-the-uniqueness-array/) 2451
*   [2040\. 两个有序数组的第 K 小乘积](https://leetcode.cn/problems/kth-smallest-product-of-two-sorted-arrays/) 2518
*   [2386\. 找出数组的第 K 大和](https://leetcode.cn/problems/find-the-k-sum-of-an-array/) 2648 转化
*   [1508\. 子数组和排序后的区间和](https://leetcode.cn/problems/range-sum-of-sorted-subarray-sums/) 思考：二分做法
*   [1918\. 第 K 小的子数组和](https://leetcode.cn/problems/kth-smallest-subarray-sum/)（会员题）

三、其他
----

*   [69\. x 的平方根](https://leetcode.cn/problems/sqrtx/) 二分求最大的 m，满足 m2≤x（也可以二分求最小的满足 m2\>x 的 m，减一得到答案）
*   [74\. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)
*   [240\. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)
*   [2476\. 二叉搜索树最近节点查询](https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/)
*   [278\. 第一个错误的版本](https://leetcode.cn/problems/first-bad-version/)
*   [374\. 猜数字大小](https://leetcode.cn/problems/guess-number-higher-or-lower/)
*   [162\. 寻找峰值](https://leetcode.cn/problems/find-peak-element/)
*   [1901\. 寻找峰值 II](https://leetcode.cn/problems/find-a-peak-element-ii/)
*   [852\. 山脉数组的峰顶索引](https://leetcode.cn/problems/peak-index-in-a-mountain-array/)
*   [1095\. 山脉数组中查找目标值](https://leetcode.cn/problems/find-in-mountain-array/) 1827
*   [153\. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)
*   [154\. 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)
*   [33\. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)
*   [81\. 搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/)
*   [222\. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)
*   [1539\. 第 k 个缺失的正整数](https://leetcode.cn/problems/kth-missing-positive-number/)
*   [540\. 有序数组中的单一元素](https://leetcode.cn/problems/single-element-in-a-sorted-array/)
*   [4\. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)
*   [1064\. 不动点](https://leetcode.cn/problems/fixed-point/)（会员题）
*   [702\. 搜索长度未知的有序数组](https://leetcode.cn/problems/search-in-a-sorted-array-of-unknown-size/)（会员题）
*   [2936\. 包含相等值数字块的数量](https://leetcode.cn/problems/number-of-equal-numbers-blocks/)（会员题）
*   [1060\. 有序数组中的缺失元素](https://leetcode.cn/problems/missing-element-in-sorted-array/)（会员题）
*   [1198\. 找出所有行中最小公共元素](https://leetcode.cn/problems/find-smallest-common-element-in-all-rows/)（会员题）
*   [1428\. 至少有一个 1 的最左端列](https://leetcode.cn/problems/leftmost-column-with-at-least-a-one/)（会员题）
*   [1533\. 找到最大整数的索引](https://leetcode.cn/problems/find-the-index-of-the-large-integer/)（会员题）
*   [2387\. 行排序矩阵的中位数](https://leetcode.cn/problems/median-of-a-row-wise-sorted-matrix/)（会员题）
*   [302\. 包含全部黑色像素的最小矩形](https://leetcode.cn/problems/smallest-rectangle-enclosing-black-pixels/)（会员题）

关联题单
----

二分答案的一个难点是 `check` 函数怎么写，这会涉及到**贪心**等技巧，可以练练下面的贪心题单（主要是第一章节）。

分类题单
----

[如何科学刷题？](https://leetcode.cn/circle/discuss/RvFUtj/)

1.  [滑动窗口与双指针（定长/不定长/单序列/双序列/三指针/分组循环）](https://leetcode.cn/circle/discuss/0viNMK/)
2.  [二分算法（二分答案/最小化最大值/最大化最小值/第K小）](https://leetcode.cn/circle/discuss/SqopEo/)
3.  [单调栈（基础/矩形面积/贡献法/最小字典序）](https://leetcode.cn/circle/discuss/9oZFK9/)
4.  [网格图（DFS/BFS/综合应用）](https://leetcode.cn/circle/discuss/YiXPXW/)
5.  [位运算（基础/性质/拆位/试填/恒等式/思维）](https://leetcode.cn/circle/discuss/dHn9Vk/)
6.  [图论算法（DFS/BFS/拓扑排序/最短路/最小生成树/二分图/基环树/欧拉路径）](https://leetcode.cn/circle/discuss/01LUak/)
7.  [动态规划（入门/背包/状态机/划分/区间/状压/数位/数据结构优化/树形/博弈/概率期望）](https://leetcode.cn/circle/discuss/tXLS3i/)
8.  [常用数据结构（前缀和/差分/栈/队列/堆/字典树/并查集/树状数组/线段树）](https://leetcode.cn/circle/discuss/mOr1u6/)
9.  [数学算法（数论/组合/概率期望/博弈/计算几何/随机算法）](https://leetcode.cn/circle/discuss/IYT3ss/)
10.  [贪心与思维（基本贪心策略/反悔/区间/字典序/数学/思维/脑筋急转弯/构造）](https://leetcode.cn/circle/discuss/g6KTKL/)
11.  [链表、二叉树与回溯（前后指针/快慢指针/DFS/BFS/直径/LCA/一般树）](https://leetcode.cn/circle/discuss/K0n2gO/)
12.  [字符串（KMP/Z函数/Manacher/字符串哈希/AC自动机/后缀数组/子序列自动机）](https://leetcode.cn/circle/discuss/SJFwQI/)

[我的题解精选（已分类）](https://leetcode.cn/link/?target=https%3A%2F%2Fgithub.com%2FEndlessCheng%2Fcodeforces-go%2Fblob%2Fmaster%2Fleetcode%2FSOLUTIONS.md)

欢迎关注 [B站@灵茶山艾府](https://leetcode.cn/link/?target=https%3A%2F%2Fspace.bilibili.com%2F206214)

如果你发现有题目可以补充进来，欢迎评论反馈。