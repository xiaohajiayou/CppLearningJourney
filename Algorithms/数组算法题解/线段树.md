
# 基本数据结构
前置知识

阅读本文前，你需要先学习：

*   [线段树核心原理及可视化](https://labuladong.online/algo/data-structure-basic/segment-tree-basic/)
*   [小而美的算法技巧：前缀和数组](https://labuladong.online/algo/data-structure/prefix-sum/)

线段树结构也是解决区间求值的问题，同时支持元素动态更新，解决了前缀和技巧的痛点。当然，代价就是时间复杂度稍微高一些，区间查询操作和单点动态更新操作的时间复杂度都是 O(log⁡n)O(\\log n)O(logn)。

线段树的原理在前面的数据结构基础章节 [线段树核心原理及可视化](https://labuladong.online/algo/data-structure-basic/segment-tree-basic/) 已经讲解过了，本文将不再重复，直接给出线段树的代码实现。

[链式实现 vs 数组实现](#)
-----------------

最直接的想法，就是使用类似二叉树节点的 `SegmentNode` 类来实现线段树，我们不妨称之为线段树的链式实现：

    // 线段树节点
    class SegmentNode {
        // 当前节点对应的索引区间
        int l, r;
    
        // 当前区间内元素的聚合值
        int mergeValue;
    
        // 左右子节点
        SegmentNode left = null, right = null;
    }
    
    // 线段树
    class SegmentTree {
        SegmentNode root;
    
        // ...
    }

因为线段树是一种近似于完全二叉树的结构，所以也可以用数组来存储线段树，不需要真的使用 `SegmentNode` 构建树结构，我们不妨称这种实现方式为线段树的数组实现：

    // 线段树
    class SegmentTree {
        // 用数组存储完全二叉树结构
        int[] tree;
    
        // ...
    }

从算法分析的角度，两种实现的理论复杂度都一样，但是链式结构需要额外维护指针信息，所以在实际的运行中肯定会比数组实现的效率差一点。不过在数组上实现树结构更抽象，理解难度更大。

本站会给出两种实现的代码，先讲解链式的实现方式，你理解之后，再看数组实现的代码会很容易。

在实际笔试中，如果需要使用线段树，可以直接复制数组实现的代码去使用。



[链式结构实现线段树](#)
--------------

线段树节点 `SegmentNode` 除了记录左右节点的指针 `left, right` 之外，还要记录当前节点对应的索引区间 `[l, r]` 和区间内元素的聚合值（比如元素和、最大值等等）`mergeValue`。

记录索引区间 `[l, r]`，是为了判断待查找区间是否和当前节点的区间有交集，若无交集可以避免遍历子树，从而提高查询效率；同时，如果索引区间 `[l, r]` 完全包含在待查找区间内，可以直接返回当前节点的聚合值，不需要再遍历子树，从而提高查询效率。

更新操作需要注意，后序位置需要根据左右子节点的聚合值来更新当前节点的聚合值，这样才能保证被更新叶子节点的整条路径上的聚合值都被正确更新。

下面直接看代码吧，注释写得很详细了：


cpp 🤖

    #include <functional>
    #include <iostream>
    #include <stdexcept>
    #include <vector>
    
    // 线段树节点
    class SegmentNode {
    public:
        // 该节点表示的区间范围 [l, r]
        int l, r;
        // [l, r] 区间元素的聚合值（如区间和、区间最大值等）
        int mergeVal;
        SegmentNode* left;
        SegmentNode* right;
    
        SegmentNode(int mergeVal, int l, int r) 
            : mergeVal(mergeVal), l(l), r(r), left(nullptr), right(nullptr) {}
    };
    
    class SegmentTree {
    private:
        SegmentNode* root;
        std::function<int(int, int)> merger;
    
        // 定义：将 nums[l..r] 中的元素构建成线段树，返回根节点
        SegmentNode* build(const std::vector<int>& nums, int l, int r) {
            // 区间内只有一个元素，直接返回
            if (l == r) {
                return new SegmentNode(nums[l], l, r);
            }
            // 从中间切分，递归构建左右子树
            int mid = l + (r - l) / 2;
            SegmentNode* left = build(nums, l, mid);
            SegmentNode* right = build(nums, mid + 1, r);
            // 根据左右子树的聚合值，计算当前根节点的聚合值
            SegmentNode* node = new SegmentNode(merger(left->mergeVal, right->mergeVal), l, r);
            // 组装左右子树
            node->left = left;
            node->right = right;
            return node;
        }
    
        void update(SegmentNode* node, int index, int value) {
            if (node->l == node->r) {
                // 找到了目标叶子节点，更新值
                node->mergeVal = value;
                return;
            }
    
            int mid = node->l + (node->r - node->l) / 2;
            if (index <= mid) {
                // 若 index 较小，则去左子树更新
                update(node->left, index, value);
            } else {
                // 若 index 较大，则去右子树更新
                update(node->right, index, value);
            }
            // 后序位置，左右子树已经更新完毕，更新当前节点的聚合值
            node->mergeVal = merger(node->left->mergeVal, node->right->mergeVal);
        }
    
        int query(SegmentNode* node, int qL, int qR) {
            if (qL > qR) {
                throw std::invalid_argument("Invalid query range");
            }
    
            if (node->l == qL && node->r == qR) {
                // 命中了目标区间，直接返回
                return node->mergeVal;
            }
    
            // 未直接命中区间，需要继续向下查找
            int mid = node->l + (node->r - node->l) / 2;
            if (qR <= mid) {
                // node.l <= qL <= qR <= mid
                // 目标区间完全在左子树中
                return query(node->left, qL, qR);
            } else if (qL > mid) {
                // mid < qL <= qR <= node.r
                // 目标区间完全在右子树中
                return query(node->right, qL, qR);
            } else {
                // node.l <= qL <= mid < qR <= node.r
                // 目标区间横跨左右子树
                // 将查询区间拆分成 [qL, mid] 和 [mid + 1, qR] 两部分，分别向左右子树查询
                // 最后将左右子树的查询结果合并
                return merger(
                    query(node->left, qL, mid),
                    query(node->right, mid + 1, qR)
                );
            }
        }
    
    public:
        // 创建线段树
        // 输入数组 nums 和一个聚合函数 merger，merger 用于计算区间的聚合值
        SegmentTree(const std::vector<int>& nums, std::function<int(int, int)> merger)
            : merger(merger) {
            root = build(nums, 0, nums.size() - 1);
        }
    
        void update(int index, int value) {
            update(root, index, value);
        }
    
        int query(int qL, int qR) {
            return query(root, qL, qR);
        }
    };
    
    int main() {
        std::vector<int> arr = {1, 3, 5, 7, 9};
        // 示例，创建一棵求和线段树
        SegmentTree st(arr, [](int a, int b) { return a + b; });
    
        std::cout << st.query(1, 3) << std::endl; // 3 + 5 + 7 = 15
        st.update(2, 10);
        std::cout << st.query(1, 3) << std::endl; // 3 + 10 + 7 = 20
    
        return 0;
    }


有了这个线段树实现，只需要稍加修改，即可解决力扣第 307 题「[区域和检索 - 数组可修改](https://leetcode.cn/problems/range-sum-query-mutable/)」。

[数组实现线段树](#)
------------

要想理解数组实现线段树的代码，需要你学过 [二叉堆实代码实现](https://labuladong.online/algo/data-structure-basic/binary-heap-implement/)，因为二叉堆也是用数组存储二叉树结构，和这里的场景有一些相似之处。

这里我们也把数组的索引 0 作为根节点，那么对于索引为 `i` 的节点，它的左子节点索引为 `2 * i + 1`，右子节点索引为 `2 * i + 2`。

数组实现线段树和数组实现二叉堆有一个重要不同：假设数组元素个数为 nnn，那么存储线段树的数组容量应该初始化为 4×n4 \\times n4×n，而二叉堆数组只需要 nnn 的容量。

**为什么是 4×n4 \\times n4×n 呢？主要是为了确保数组能够存储线段树的所有节点**。我来简单讲讲这里面的原因。

首先来看满二叉树，它的最底层叶子节点是填满的对吧：

![](https://labuladong.online/algo/images/complete_tree/perfect.png)

这种情况下，假设最底层叶子节点有 nnn 个，那么整个满二叉树的节点总数是 2n−12n - 12n−1 个。

接着来看线段树，线段树的叶子节点就是数组中的元素，假设数组中有 nnn 个元素，那么线段树的叶子节点总数必然是 nnn 个。

但是线段树不一定是满二叉树，比方这个可视化面板展示的线段树结构：

[Algorithm visualize](https://labuladong.online/algo-visualize/tutorial/segment-tree-height/?stepId=-1)   **算法可视化面板**Link copied!

把根节点作为第一层，面板中的线段树共有 5 层，叶子节点分布在第 5 和第 4 层，这种情况下，请你估算一下整棵树上的节点总数是多少？

我们要根据节点总数，来确定存储线段树的数组容量。估算不准的话，给一个上界也行，多一些没关系，但绝对不能少。

比方说现在我就估算第 5 层共有 2×n2 \\times n2×n 个节点，这个肯定是上界。

因为第 5 层有 2×n2 \\times n2×n 个节点的话，第 4 层就应该有 nnn 个节点。但这个 nnn 是同时分布在第 4、5 层的叶子节点总数，所以第 4 层的实际节点数量肯定小于 nnn，进而第 5 层的节点数量也是小于 2×n2 \\times n2×n。

现在估算第 5 层（最底层）有 2×n2 \\times n2×n 个节点，那么就可以估算整棵二叉树的节点总数为 4×n4 \\times n4×n 个。

如果满二叉树的最底层叶子节点数量是 xxx，那么满二叉树的节点总数是 2x−12x - 12x−1。线段树不是满二叉树，所以这里的 4×n4 \\times n4×n 肯定大于线段树实际的总结点数，是一个偏大的上界。

综上，我们初始化一个容量为 4×n4 \\times n4×n 的数组，肯定可以存储 nnn 个叶子节点的线段树。

好了，接下来可以看数组实现线段树的代码了，注释写得很详细：


cpp 🤖

    #include <iostream>
    #include <vector>
    #include <functional>
    #include <stdexcept>
    
    class ArraySegmentTree {
        // 用数组存储线段树结构
        std::vector<int> tree;
        // 元素个数
        int n;
        std::function<int(int, int)> merger;
    
        // 定义：对 nums[l..r] 区间的元素构建线段树，rootIndex 是根节点
        void build(const std::vector<int>& nums, int l, int r, int rootIndex) {
            if (l == r) {
                // 区间内只有一个元素，设置为叶子节点
                tree[rootIndex] = nums[l];
                return;
            }
    
            // 从中间切分，递归构建左右子树
            int mid = l + (r - l) / 2;
            int leftRootIndex = leftChild(rootIndex);
            int rightRootIndex = rightChild(rootIndex);
            // 递归构建 nums[l..mid]，根节点为 leftRootIndex
            build(nums, l, mid, leftRootIndex);
            // 递归构建 nums[mid+1..r]，根节点为 rightRootIndex
            build(nums, mid + 1, r, rightRootIndex);
    
            // 后序位置，左右子树已经构建完毕，更新当前节点的聚合值
            tree[rootIndex] = merger(tree[leftRootIndex], tree[rightRootIndex]);
        }
    
        void update(int l, int r, int rootIndex, int index, int value) {
            // 当前节点为 rootIndex，对应的区间为 [l, r]
            // 去子树更新 nums[index] 为 value
            if (l == r) {
                // 找到了目标叶子节点，更新值
                tree[rootIndex] = value;
                return;
            }
    
            int mid = l + (r - l) / 2;
            if (index <= mid) {
                // 若 index 较小，则去左子树更新
                update(l, mid, leftChild(rootIndex), index, value);
            } else {
                // 若 index 较大，则去右子树更新
                update(mid + 1, r, rightChild(rootIndex), index, value);
            }
    
            // 后序位置，左右子树已经更新完毕，更新当前节点的聚合值
            tree[rootIndex] = merger(tree[leftChild(rootIndex)], tree[rightChild(rootIndex)]);
        }
    
        int query(int l, int r, int rootIndex, int qL, int qR) {
            if (qL == l && r == qR) {
                // 命中了目标区间，直接返回
                return tree[rootIndex];
            }
    
            int mid = l + (r - l) / 2;
            int leftRootIndex = leftChild(rootIndex);
            int rightRootIndex = rightChild(rootIndex);
            if (qR <= mid) {
                // node.l <= qL <= qR <= mid
                // 目标区间完全在左子树中
                return query(l, mid, leftRootIndex, qL, qR);
            } else if (qL > mid) {
                // mid < qL <= qR <= node.r
                // 目标区间完全在右子树中
                return query(mid + 1, r, rightRootIndex, qL, qR);
            } else {
                // node.l <= qL <= mid < qR <= node.r
                // 目标区间横跨左右子树
                // 将查询区间拆分成 [qL, mid] 和 [mid + 1, qR] 两部分，分别向左右子树查询
                return merger(query(l, mid, leftRootIndex, qL, mid),
                              query(mid + 1, r, rightRootIndex, mid + 1, qR));
            }
        }
    
        int leftChild(int pos) {
            return 2 * pos + 1;
        }
    
        int rightChild(int pos) {
            return 2 * pos + 2;
        }
    
    public:
        ArraySegmentTree(const std::vector<int>& nums, std::function<int(int, int)> mergeFunc)
            : n(nums.size()), merger(mergeFunc) {
            // 分配 4 倍数组长度的空间，存储线段树
            tree.resize(4 * n);
            build(nums, 0, n - 1, 0);
        }
    
        void update(int index, int value) {
            update(0, n - 1, 0, index, value);
        }
    
        int query(int qL, int qR) {
            if (qL < 0 || qR >= n || qL > qR) {
                throw std::invalid_argument("Invalid range: [" + std::to_string(qL) + ", " + std::to_string(qR) + "]");
            }
            return query(0, n - 1, 0, qL, qR);
        }
    };
    
    int main() {
        std::vector<int> arr = {1, 3, 5, 7, 9};
        // 示例，创建一棵求和线段树
        ArraySegmentTree st(arr, [](int a, int b) { return a + b; });
    
        std::cout << st.query(1, 3) << std::endl; // 3 + 5 + 7 = 15
        st.update(2, 10);
        std::cout << st.query(1, 3) << std::endl; // 3 + 10 + 7 = 20
        return 0;
    }


[进阶优化](#)
---------

上面实现的线段树还有两个局限性：

1、`update` 方法只支持单点更新，不支持区间更新。当然理论上你可以基于这个单点更新实现区间更新：

    // 单点更新 nums[index] = val，时间复杂度 O(logn)
    void update(int index, int val) {
        // ...
    }
    
    // 区间更新 nums[l..r] = val
    void updateRange(int l, int r, int val) {
        for (int i = l; i <= r; i++) {
            update(i, val);
        }
    }

但是这样的时间复杂度为 O(mlog⁡n)O(m \\log n)O(mlogn)，mmm 是更新区间的长度，效率比较差。所以有没有办法能让任意区间更新的时间复杂度也保持在 O(log⁡n)O(\\log n)O(logn) 呢？

2、构造线段树时需要构造出所有节点，也就是说，你构造线段树的时候就需要传入一个包含所有元素的数组，这在某些场景下是不现实的。

比方说我要在一个规模为 10910^9109 的区间上进行区间查询和更新，难道我需要先构造一个包含 10910^9109 个元素的数组吗？这显然是非常消耗内存的。

有没有办法让线段树动态构建，优化稀疏数据上的内存开销呢？

对于这两个问题的优化，我们会在后面的文章中给出。
# 优化-动态线段树


前置知识

阅读本文前，你需要先学习：

*   [线段树基本实现](https://labuladong.online/algo/data-structure/segment-tree-implement/)

[线段树基本实现](https://labuladong.online/algo/data-structure/segment-tree-implement/) 中用数组和链表分别实现了线段树，文末留了两个优化点，分别是区间更新问题和稀疏数据的内存优化问题。

本文将实现一个动态线段树 `DynamicSegmentTree`，利用「动态开点技术」，优化稀疏数据的内存占用问题。


这个实现的区别是，不需要你在一开始就输入一个数组，只需要输入线段树的区间范围，并给定一个默认值。

比方说你输入区间范围为 `[0, 1000000]`，默认值为 `0`，就相当于输入了一个大小为 `1000001` 的数组，其中每个元素的值都是 `0`。

`DynamicSegmentTree` 并不会在初始化的时候真的开辟这么大的内存空间来存储 `1000001` 个节点，而是在更新元素的时候，根据需要动态地创建节点，这就是所谓的「动态开点」。

这种动态线段树用链式结构比较容易实现，所以我们可以基于 [线段树基本实现](https://labuladong.online/algo/data-structure/segment-tree-implement/) 中的 `LinkedSegmentTree` 来实现动态线段树。

下面高亮显示了需要修改的代码部分，主要就是在 `update` 逻辑中额外调用一次 `initChildrenIfNeeded` 方法，用于在需要的时候动态地创建子节点，其他的代码都可以保持不变：


cpp 🤖

    #include <functional>
    #include <stdexcept>
    
    // 线段树节点
    class SegmentNode {
    public:
        int l, r;
        int mergeVal;
        SegmentNode* left;
        SegmentNode* right;
    
        // 构造函数
        SegmentNode(int l, int r, int mergeVal)
            : l(l), r(r), mergeVal(mergeVal), left(nullptr), right(nullptr) {}
    };
    
    class DynamicSegmentTree {
    private:
        SegmentNode* root;
        std::function<int(int, int)> merger;
        int defaultValue;
    
        // 检查当前节点是否需要创建子节点
        void initChildrenIfNeeded(SegmentNode* node) {
            if (node->l == node->r) {
                // 叶子节点，无需创建子节点
                return;
            }
            int mid = node->l + (node->r - node->l) / 2;
            if (node->left == nullptr) {
                // 左子节点为空，创建左子节点
                node->left = new SegmentNode(node->l, mid, defaultValue);
            }
            if (node->right == nullptr) {
                // 右子节点为空，创建右子节点
                node->right = new SegmentNode(mid + 1, node->r, defaultValue);
            }
        }
    
        // 单点更新：将下标 index 的值更新为 value
        void update(SegmentNode* node, int index, int value) {
            if (node->l == node->r) {
                node->mergeVal = value;
                return;
            }
            // 动态创建子节点
            initChildrenIfNeeded(node);
            int mid = node->l + (node->r - node->l) / 2;
            if (index <= mid) {
                update(node->left, index, value);
            } else {
                update(node->right, index, value);
            }
            node->mergeVal = merger(node->left->mergeVal, node->right->mergeVal);
        }
    
        // 区间查询：返回区间 [qL, qR] 的聚合值
        int query(SegmentNode* node, int qL, int qR) {
            if (node->r < qL || node->l > qR) {
                throw std::invalid_argument("Invalid query range");
            }
            if (qL <= node->l && node->r <= qR) {
                return node->mergeVal;
            }
            int mid = node->l + (node->r - node->l) / 2;
            if (qR <= mid) {
                return query(node->left, qL, qR);
            } else if (qL > mid) {
                return query(node->right, qL, qR);
            } else {
                return merger(query(node->left, qL, mid), query(node->right, mid + 1, qR));
            }
        }
    
        // 辅助函数，递归释放节点内存
        void deleteTree(SegmentNode* node) {
            if (!node) return;
            deleteTree(node->left);
            deleteTree(node->right);
            delete node;
        }
    
    public:
        // 构造函数
        DynamicSegmentTree(int start, int end, std::function<int(int, int)> merger, int defaultValue)
            : merger(merger), defaultValue(defaultValue) {
            // 只创建根节点，初始值均为 defaultValue
            root = new SegmentNode(start, end, defaultValue);
        }
    
        // 析构函数，释放内存
        ~DynamicSegmentTree() {
            deleteTree(root);
        }
    
        // 单点更新接口
        void update(int index, int value) {
            update(root, index, value);
        }
    
        // 区间查询接口：返回区间 [qL, qR] 的聚合值
        int query(int qL, int qR) {
            if(qL > qR) {
                throw std::invalid_argument("Invalid query range");
            }
            return query(root, qL, qR);
        }
    };


你可以利用力扣第 307 题「[区域和检索 - 数组可修改](https://leetcode.cn/problems/range-sum-query-mutable/)」来验证这个实现的正确性。需要注意的是，动态线段树初始化时只有一个根节点，我们需要在代码中手动调用 `update` 方法把 `nums` 数组中的每个元素更新到线段树中：


cpp 🤖

    class NumArray {
    private:
        DynamicSegmentTree* segmentTree;
    
    public:
        NumArray(vector<int>& nums) {
            // 初始化线段树，区间范围为 [0, nums.length - 1]
            segmentTree = new DynamicSegmentTree(0, nums.size() - 1, 
                                               [](int a, int b) { return a + b; }, 0);
            // 将 nums 数组中的每个元素更新到线段树中
            for (int i = 0; i < nums.size(); i++) {
                segmentTree->update(i, nums[i]);
            }
        }
        
        ~NumArray() {
            delete segmentTree;
        }
        
        void update(int index, int val) {
            segmentTree->update(index, val);
        }
        
        int sumRange(int left, int right) {
            return segmentTree->query(left, right);
        }
    };


# 优化-懒更新线段树

前置知识

阅读本文前，你需要先学习：

*   [线段树基本实现](https://labuladong.online/algo/data-structure/segment-tree-implement/)
*   [优化：动态线段树](https://labuladong.online/algo/data-structure/segment-tree-dynamic/)

[线段树基本实现](https://labuladong.online/algo/data-structure/segment-tree-implement/) 中用数组和链表分别实现了线段树，文末留了两个优化点，分别是区间更新问题和稀疏数据的内存优化问题。

[优化：动态线段树](https://labuladong.online/algo/data-structure/segment-tree-dynamic/) 解决了稀疏数据的内存优化问题，**本文将基于 `DynamicSegmentTree` 的链式实现，使用「懒更新」技术，为线段树新增 `rangeAdd/rangeUpdate` 方法，在 O(log⁡N)O(\\log N)O(logN) 时间复杂度内完成任意长度的区间更新**。

本文实现的区间更新线段树和之前的单点更新线段树有几点区别：

1、因为单点更新可以看作是长度为 1 的区间更新，复杂度还是 O(log⁡N)O(\\log N)O(logN)，所以我们不需要单独实现单点更新了。

2、我们不接受 `merge` 聚合函数了，因为涉及区间懒更新，如果同时考虑不同的聚合函数，会引入一些编程语言层面的细节问题，对于算法的学习没有什么意义，所以本文仅给出**求和线段树**的实现。如果你需要求最值等其他场景，可以自行修改代码中的聚合计算逻辑，或者使用文末提供的 `AllInOneSegmentTree` 万能模板。

3、线段树的区间更新可以是区间赋值（Assign），也可以区间累加（Increment）。

比方 `[1, 2, 3, 4, 5]` 这个数组，将索引区间 `[1, 3]` 内的元素都赋值为 10 叫做区间赋值，结果是 `[1, 10, 10, 10, 5]`；将索引区间 `[1, 3]` 内的元素都增加 1 叫做区间累加，结果是 `[1, 3, 4, 5, 5]`。

这两种场景都是算法题中常见的，本文会同时给出这两种实现。

我们之前实现的线段树主要 API 如下：

    class SegmentTree {
    
        // 初始化线段树
        public SegmentTree(int[] nums, Function<Integer, Integer> merge) {}
    
        // 查询闭区间 [qL, qR] 的聚合值，时间复杂度 O(logN)
        public int query(int qL, int qR) {}
        
        // 单点更新，设置 nums[i] = val，时间复杂度 O(logN)
        public void update(int i, int val) {}
    }

本文将实现以下两种线段树：

    // 区间累加线段树
    class IncrSegmentTree {
    
        // 初始化动态线段树
        public IncrSegmentTree(int start, int end, int defaultValue) {}
    
        // 将闭区间 [qL, qR] 增加 delta（可以是负数），时间复杂度 O(logN)
        public void rangeAdd(int qL, int qR, int delta) {}
    
        // 查询闭区间 [qL, qR] 的元素和，时间复杂度 O(logN)
        public int query(int qL, int qR) {}
    }
    
    // 区间赋值线段树
    class AssignSegmentTree {
    
        // 初始化动态线段树
        public AssignSegmentTree(int start, int end, int defaultValue) {}
    
        // 将闭区间 [qL, qR] 赋值为 val，时间复杂度 O(logN)
        public void rangeUpdate(int qL, int qR, int val) {}
    
        // 查询闭区间 [qL, qR] 的元素和，时间复杂度 O(logN)
        public int query(int qL, int qR) {}
    }

`rangeAdd` 和 `rangeUpdate` 的实现逻辑非常类似，理论上可以同时实现到一个类上，但是两个逻辑混在一起代码会更复杂，徒增理解成本，而且实际的算法题中，一般只会用到区间累加或区间赋值中的一种，不会同时用到，所以本文还是把它们拆到两个类分别实现，方便大家理解其原理。

本文的最后会给出一个万能线段树模板 `AllInOneSegmentTree`，同时包含上述所有 API 和线段树的所有优化，笔试时可以直接拿来使用。


[懒更新的核心原理](#)
-------------

我们对比一下单点更新的 `update` 方法和区间更新的 `rangeUpdate` 方法，就能直观地感受到懒更新的原理，以及为什么懒更新可以让区间更新的时间复杂度依然保持在 O(log⁡N)O(\\log N)O(logN)。

对于区间更新的场景，如果使用 `update` 方法单点更新，我们只能用一个 for 循环去更新区间内的每个元素。

请你点开下面的可视化面板，多次点击 `sumTree.update` 这一行代码，可以看到每次 `update` 都要从根节点遍历到叶子节点：

所以区间更新的时间复杂度是 O(Mlog⁡N)O(M \\log N)O(MlogN)，MMM 是区间中的元素个数，log⁡N\\log NlogN 是线段树的高度，NNN 是数组中的元素个数。

优化思路及难点

**懒更新的思路是，没必要上来就去更新区间的所有叶子节点，而是先把更新记录到非叶子节点（懒标记）。等到之后的操作经过懒标记节点时，再顺手把懒标记逐渐更新到叶子节点（懒标记下推）**。

它的难点在于，你要正确处理懒标记，保证在懒标记存在时，线段树的查询、更新操作依然能返回正确的结果。

可视化面板对懒更新线段树有特殊的支持，带有「懒标记」的线段树节点会显示为半透明，而且节点上的显示值会有一个 `*` 前缀，你把鼠标移动到对应的节点上，会显示懒标记的值。下面来结合可视化面板看看 `rangeUpdate` 方法是如何工作的。

请你点开下面的可视化面板，点击 `sumTree.rangeUpdate` 这一行代码，可以看到代码并没有真的更新了叶子节点，而是只更新了 `[0, 4]` 节点的元素和，并且打了一个 `lazyAssign = 2` 的标记。

点击 `console.log(sumTree.query(0, 4))` 这一行代码，可以看到直接命中了 `[0, 4]` 节点，返回元素和 `10`。

当查询 `[0, 4]` 节点的子节点时，会将这个懒标记向下传递。请你点击 `console.log(sumTree.query(0, 1))` 这一行代码，可以看到查询到了正确的元素和，并将懒标记下推到了 `[0, 1]` 节点和 `[3, 4]` 节点。


尝试修改 `rangeUpdate` 和 `query` 方法的参数，看看懒标记的下推过程。

根据上面的可视化展示可以直观地看出来：

1、`rangeUpdate` 方法不需要遍历更新区间的所有叶子节点，遍历的节点总数是树高 O(log⁡N)O(\\log N)O(logN) 的常数倍，与区间的长度无关，所以时间复杂度是 O(log⁡N)O(\\log N)O(logN)。

2、`query` 方法在查询时，虽然会额外做一些懒标记下推的工作，但遍历的节点总数依然是树高 O(log⁡N)O(\\log N)O(logN) 的常数倍，与区间的长度无关，所以时间复杂度是 O(log⁡N)O(\\log N)O(logN)。

有了这些直观的认识，我们就可以开始实现懒更新线段树了。

[实现区间赋值线段树](#)
--------------

基于 [动态线段树](https://labuladong.online/algo/data-structure/segment-tree-dynamic/) 实现的动态线段树，只需改动少量代码即可实现懒更新线段树。

首先是给 `SegmentNode` 添加 `hasLazyAssign` 和 `lazyAssign` 字段，记录当前节点是否存在懒标记，以及懒标记的值。

然后是多了一个 `pushDown` 方法用来下推懒标记，在调用 `query` 和 `updateRange` 方法时调用一次就行了。

具体看代码吧，注释非常详细了。

cpp 🤖

    #include <iostream>
    #include <stdexcept>
    
    using namespace std;
    
    // 线段树节点，维护区间 [l, r] 的元素和以及懒标记信息
    class SegmentNode {
    public:
        int l, r;
        int sum;
        SegmentNode* left;
        SegmentNode* right;
        
        // 表示当前节点是否存在赋值懒标记
        bool hasLazyAssign;
        // 懒更新中赋值的值
        int lazyAssign;
    
        SegmentNode(int l, int r, int value)
            : l(l), r(r), sum(value), left(nullptr), right(nullptr), hasLazyAssign(false) {
        }
        
        ~SegmentNode() {
            delete left;
            delete right;
        }
    };
    
    class AssignSegmentTree {
    private:
        SegmentNode* root;
        int defaultValue;
    
        // 当需要访问子节点时，如果子节点不存在，则动态创建
        void initChildrenIfNeeded(SegmentNode* node) {
            if (node->l == node->r) {
                // 叶子节点，无需划分
                return;
            }
            if (node->left == nullptr || node->right == nullptr) {
                int mid = node->l + (node->r - node->l) / 2;
                if (node->left == nullptr) {
                    node->left = new SegmentNode(node->l, mid, defaultValue);
                }
                if (node->right == nullptr) {
                    node->right = new SegmentNode(mid + 1, node->r, defaultValue);
                }
            }
        }
    
        // 下传懒标记，将当前节点的赋值懒标记传递给左右子节点
        void pushDown(SegmentNode* node) {
            if (!node->hasLazyAssign) {
                return;
            }
            
            // 把懒标记下推到左子节点
            if (node->left) {
                node->left->lazyAssign = node->lazyAssign;
                node->left->hasLazyAssign = true;
                node->left->sum = (node->left->r - node->left->l + 1) * node->lazyAssign;
            }
            
            // 把懒标记下推到右子节点
            if (node->right) {
                node->right->lazyAssign = node->lazyAssign;
                node->right->hasLazyAssign = true;
                node->right->sum = (node->right->r - node->right->l + 1) * node->lazyAssign;
            }
            
            // 清除当前节点的懒标记
            node->hasLazyAssign = false;
        }
    
        // 将闭区间 [qL, qR] 赋值为 val，时间复杂度 O(logN)
        void _rangeUpdate(SegmentNode* node, int qL, int qR, int val) {
            if (node->r < qL || node->l > qR) {
                throw invalid_argument("Invalid update range");
            }
            // 当前节点区间完全被更新区间覆盖，则更新该节点并打上懒标记
            if (qL <= node->l && node->r <= qR) {
                node->sum = (node->r - node->l + 1) * val;
                node->lazyAssign = val;
                node->hasLazyAssign = true;
                return;
            }
            
            initChildrenIfNeeded(node);
            
            // 部分覆盖，需要先下传懒标记，再递归更新左右子节点
            pushDown(node);
            
            int mid = node->l + (node->r - node->l) / 2;
            if (qR <= mid) {
                // 目标区间完全在左子树中
                _rangeUpdate(node->left, qL, qR, val);
            } else if (qL > mid) {
                // 目标区间完全在右子树中
                _rangeUpdate(node->right, qL, qR, val);
            } else {
                // 目标区间跨越左右子树
                _rangeUpdate(node->left, qL, mid, val);
                _rangeUpdate(node->right, mid + 1, qR, val);
            }
            // 更新当前节点的区间和
            node->sum = node->left->sum + node->right->sum;
        }
    
        int _query(SegmentNode* node, int qL, int qR) {
            if (node->r < qL || node->l > qR) {
                throw invalid_argument("Invalid query range");
            }
            // 当前节点区间完全包含于查询区间，直接返回区间和
            if (qL <= node->l && node->r <= qR) {
                return node->sum;
            }
            
            initChildrenIfNeeded(node);
            // 下传懒标记以确保左右子节点的数据正确
            pushDown(node);
            
            int mid = node->l + (node->r - node->l) / 2;
            if (qR <= mid) {
                // 目标区间完全在左子树中
                return _query(node->left, qL, qR);
            } else if (qL > mid) {
                // 目标区间完全在右子树中
                return _query(node->right, qL, qR);
            } else {
                // 目标区间跨越左右子树
                // 将查询区间拆分成 [qL, mid] 和 [mid + 1, qR] 两部分，分别向左右子树查询
                // 最后将左右子树的查询结果合并
                return _query(node->left, qL, mid) + _query(node->right, mid + 1, qR);
            }
        }
    
    public:
        // 构造方法
        // start, end 表示线段树的区间范围，defaultValue 表示每个区间初始的默认值
        AssignSegmentTree(int start, int end, int defaultValue)
            : defaultValue(defaultValue) {
            int initSum = (end - start + 1) * defaultValue;
            root = new SegmentNode(start, end, initSum);
        }
        
        ~AssignSegmentTree() {
            delete root;
        }
        
        // 单点赋值 val，时间复杂度 O(logN)
        void assign(int index, int val) {
            // 直接复用区间赋值方法
            rangeUpdate(index, index, val);
        }
        
        // 将闭区间 [qL, qR] 赋值为 val，时间复杂度 O(logN)
        void rangeUpdate(int qL, int qR, int val) {
            _rangeUpdate(root, qL, qR, val);
        }
        
        // 查询闭区间 [qL, qR] 的元素和，时间复杂度 O(logN)
        int query(int qL, int qR) {
            return _query(root, qL, qR);
        }
    };
    
    int main() {
        // 构建区间 [0, 9] 的赋值线段树，初始值均为 0
        AssignSegmentTree tree(0, 9, 0);
        // [0,0,0,0,0,0,0,0,0,0]
        
        tree.rangeUpdate(2, 5, 7);
        // [0,0,7,7,7,7,7,0,0,0]
        
        // 7 * 4 = 28
        cout << "sum of [0,9]: " << tree.query(0, 9) << " expected: 28" << endl;
        
        tree.rangeUpdate(0, 3, 5);
        // [5,5,5,5,7,7,0,0,0,0]
        
        // 5 * 4 + 7 * 2 = 34
        cout << "sum of [0,5]: " << tree.query(0, 5) << " expected: 34" << endl;
        
        tree.rangeUpdate(5, 9, 2);
        // [5,5,5,5,7,2,2,2,2,2]
        
        // 5 * 4 + 7 * 2 + 2 * 5 = 37
        cout << "sum of [0,9]: " << tree.query(0, 9) << " expected: 37" << endl;
        
        // 单点查询索引 5 的值
        cout << "value of index 5: " << tree.query(5, 5) << " expected: 2" << endl;
        
        // 5 + 5 = 10
        cout << "sum of [1,2]: " << tree.query(1, 2) << " expected: 10" << endl;
        
        return 0;
    }


[实现区间累加线段树](#)
--------------

区间累加线段树和上面实现的区间赋值线段树是类似的，只不过懒标记的值变成了 `lazyAdd` 表示累加的值，然后稍微修改 `pushDown` 方法的逻辑即可。

具体看代码吧，注释非常详细了：

cpp 🤖

    #include <iostream>
    #include <stdexcept>
    
    
    // 线段树节点，维护区间 [l, r] 的元素和以及懒标记信息（区间累加线段树）
    class SegmentNode {
    public:
        int l, r;
        int sum;
        SegmentNode* left;
        SegmentNode* right;
    
        // 懒更新中累加的值，初始为 0 表示无懒更新
        int lazyAdd;
    
        SegmentNode(int l, int r, int value)
            : l(l), r(r), sum(value), left(nullptr), right(nullptr), lazyAdd(0) {}
    };
    
    class IncrSegmentTree {
    private:
        SegmentNode* root;
        int defaultValue;
    
        // 当需要访问子节点时，如果子节点不存在，则动态创建
        void initChildrenIfNeeded(SegmentNode* node) {
            if (node->l == node->r) {
                // 叶子节点，无需划分
                return;
            }
            if (node->left == nullptr || node->right == nullptr) {
                int mid = node->l + (node->r - node->l) / 2;
                if (node->left == nullptr) {
                    node->left = new SegmentNode(node->l, mid, defaultValue);
                }
                if (node->right == nullptr) {
                    node->right = new SegmentNode(mid + 1, node->r, defaultValue);
                }
            }
        }
    
        // 下传懒标记，将当前节点的累加懒标记传递给左右子节点
        void pushDown(SegmentNode* node) {
            if (node->lazyAdd != 0) {
                initChildrenIfNeeded(node);
                // 将懒标记下传给左子节点
                node->left->lazyAdd += node->lazyAdd;
                node->left->sum += (node->left->r - node->left->l + 1) * node->lazyAdd;
                // 将懒标记下传给右子节点
                node->right->lazyAdd += node->lazyAdd;
                node->right->sum += (node->right->r - node->right->l + 1) * node->lazyAdd;
                // 清除当前节点的懒标记
                node->lazyAdd = 0;
            }
        }
    
        // 区间累加辅助方法
        void _rangeAdd(SegmentNode* node, int qL, int qR, int delta) {
            if (node->r < qL || node->l > qR) {
                throw std::invalid_argument("Invalid update range");
            }
            // 当前节点区间完全被更新区间覆盖，则更新该节点并打上懒标记
            if (qL <= node->l && node->r <= qR) {
                node->sum += (node->r - node->l + 1) * delta;
                node->lazyAdd += delta;
                return;
            }
    
            initChildrenIfNeeded(node);
            // 部分覆盖，需要先下传懒标记，再递归更新左右子节点
            pushDown(node);
    
            int mid = node->l + (node->r - node->l) / 2;
            if (qR <= mid) {
                // node->l <= qL <= qR <= mid
                // 目标区间完全在左子树中
                _rangeAdd(node->left, qL, qR, delta);
            } else if (qL > mid) {
                // node->l <= mid < qL <= qR <= node->r
                // 目标区间完全在右子树中
                _rangeAdd(node->right, qL, qR, delta);
            } else {
                // node->l <= qL <= mid < qR <= node->r
                // 目标区间跨越左右子树，分别更新
                _rangeAdd(node->left, qL, mid, delta);
                _rangeAdd(node->right, mid + 1, qR, delta);
            }
            // 更新当前节点的区间和
            node->sum = node->left->sum + node->right->sum;
        }
    
        // 查询区间辅助方法
        int _query(SegmentNode* node, int qL, int qR) {
            if (node->r < qL || node->l > qR) {
                throw std::invalid_argument("Invalid query range");
            }
            // 当前节点区间完全包含于查询区间，直接返回区间和
            if (qL <= node->l && node->r <= qR) {
                return node->sum;
            }
    
            initChildrenIfNeeded(node);
            // 下传懒标记以确保左右子节点的数据正确
            pushDown(node);
    
            int mid = node->l + (node->r - node->l) / 2;
            if (qR <= mid) {
                // node->l <= qL <= qR <= mid
                // 目标区间完全在左子树中
                return _query(node->left, qL, qR);
            } else if (qL > mid) {
                // node->l <= mid < qL <= qR <= node->r
                // 目标区间完全在右子树中
                return _query(node->right, qL, qR);
            } else {
                // node->l <= qL <= mid < qR <= node->r
                // 目标区间跨越左右子树
                return _query(node->left, qL, mid) + _query(node->right, mid + 1, qR);
            }
        }
    
        // 释放节点内存的递归函数
        void freeNode(SegmentNode* node) {
            if (node == nullptr) return;
            freeNode(node->left);
            freeNode(node->right);
            delete node;
        }
    
    public:
        // 构造方法
        // start, end 表示线段树的区间范围，defaultValue 表示每个区间初始的默认值
        IncrSegmentTree(int start, int end, int defaultValue)
            : defaultValue(defaultValue) {
            int initSum = (end - start + 1) * defaultValue;
            root = new SegmentNode(start, end, initSum);
        }
    
        ~IncrSegmentTree() {
            freeNode(root);
        }
    
        // 单点累加 delta（可以为负数），时间复杂度 O(logN)
        void add(int index, int delta) {
            // 直接复用区间累加方法
            rangeAdd(index, index, delta);
        }
    
        // 将闭区间 [qL, qR] 增加 delta（可以为负数），时间复杂度 O(logN)
        void rangeAdd(int qL, int qR, int delta) {
            _rangeAdd(root, qL, qR, delta);
        }
    
        // 查询闭区间 [qL, qR] 的元素和，时间复杂度 O(logN)
        int query(int qL, int qR) {
            return _query(root, qL, qR);
        }
    };
    
    int main() {
        // 构建区间 [0, 9] 的累加线段树，初始值均为 0
        IncrSegmentTree tree(0, 9, 0);
        // [0,0,0,0,0,0,0,0,0,0]
    
        tree.rangeAdd(2, 5, 7);
        // [0,0,7,7,7,7,0,0,0,0]
        // 7 * 4 = 28
        std::cout << "sum of [0,9]: " << tree.query(0, 9) << " expected: 28" << std::endl;
    
        tree.rangeAdd(0, 3, 5);
        // [5,5,12,12,7,7,0,0,0,0]
        // 5 + 5 + 12 + 12 + 7 + 7 = 48
        std::cout << "sum of [0,5]: " << tree.query(0, 5) << " expected: 48" << std::endl;
    
        tree.rangeAdd(5, 9, 2);
        // [5,5,12,12,7,9,2,2,2,2]
        // 5 + 5 + 12 + 12 + 7 + 9 + 2 + 2 + 2 + 2 = 58
        std::cout << "sum of [0,9]: " << tree.query(0, 9) << " expected: 58" << std::endl;
    
        // 单点查询索引 5 的值
        std::cout << "value of index 5: " << tree.query(5, 5) << " expected: 9" << std::endl;
    
        // [5,5,12,12,7,9,2,2,2,2]
        // 5 + 12 = 17
        std::cout << "sum of [1,2]: " << tree.query(1, 2) << " expected: 17" << std::endl;
    
        return 0;
    }

    // 示例用法
    // 构建区间 [0, 9] 的累加线段树，初始值均为 0
    const tree = new IncrSegmentTree(0, 9, 0);
    // [0,0,0,0,0,0,0,0,0,0]
    
    tree.rangeAdd(2, 5, 7);
    // [0,0,7,7,7,7,0,0,0,0]
    // 7 * 4 = 28
    console.log("sum of [0,9]: " + tree.query(0, 9) + " expected: 28");
    
    tree.rangeAdd(0, 3, 5);
    // [5,5,12,12,7,7,0,0,0,0]
    // 5 + 5 + 12 + 12 + 7 + 7 = 48
    console.log("sum of [0,5]: " + tree.query(0, 5) + " expected: 48");
    
    tree.rangeAdd(5, 9, 2);
    // [5,5,12,12,7,9,2,2,2,2]
    // 5 + 5 + 12 + 12 + 7 + 9 + 2 + 2 + 2 + 2 = 58
    console.log("sum of [0,9]: " + tree.query(0, 9) + " expected: 58");
    
    // 单点查询索引 5 的值
    console.log("value of index 5: " + tree.query(5, 5) + " expected: 9");
    
    // [5,5,12,12,7,9,2,2,2,2]
    // 5 + 12 = 17
    console.log("sum of [1,2]: " + tree.query(1, 2) + " expected: 17");

[万能线段树模板](#)
------------

上面的代码为了方便大家理解，把 `updateRange` 和 `addRange` 分别放到了 `AssignSegmentTree` 和 `IncrSegmentTree` 两个类中实现。

而且上面实现的 `AssignSegmentTree` 和 `IncrSegmentTree` 都是用于区间求和场景的，算法题中一般会出现求和、求最大值、求最小值这三种场景。

下面实现一个万能的线段树类 `AllInOneSegmentTree`，具有以下特点：

1、同时实现 `updateRange` 和 `addRange` 方法，支持区间赋值和区间累加的混合调用。

2、在创建线段树时，可以指定线段树来计算区间和、区间最大值或区间最小值。

把这些功能都混合在一起，代码会显得复杂臃肿，但好处是开箱即用。**所以这个万能实现不太适合用来学习理解，仅适合存为模板，在实战中直接使用**。


cpp 🤖

    class AllInOneSegmentTree {
        struct SegmentNode {
            int l, r;
            int mergeValue;
            SegmentNode* left;
            SegmentNode* right;
    
            // 累加懒标记, 为 0 表示无懒更新
            int lazyAdd;
    
            // 赋值懒标记
            int lazyAssign;
            bool hasLazyAssign;
    
            SegmentNode(int l, int r, int mergeValue) : l(l), r(r), mergeValue(mergeValue), left(nullptr), right(nullptr), lazyAdd(0), lazyAssign(0), hasLazyAssign(false) {}
        };
    
    private:
        SegmentNode* root;
        int defaultValue;
        string type;
    
    public:
        AllInOneSegmentTree(int start, int end, int defaultValue, string type) {
            if (type == "sum" || type == "max" || type == "min") {
                this->type = type;
            } else {
                throw invalid_argument("Invalid type, must be sum, max, or min");
            }
            this->defaultValue = defaultValue;
            int rootMergeValue = computeRangeValue(start, end, defaultValue);
            this->root = new SegmentNode(start, end, rootMergeValue);
        }
    
        // 计算区间 [l, r] 赋值为 val 后的 mergeValue
        int computeRangeValue(int l, int r, int val) {
            if (type == "sum") {
                return (r - l + 1) * val;
            } else {
                return val;
            }
        }
    
        // 根据区间长度更新 mergeValue，加上 delta
        int applyAddToValue(SegmentNode* node, int delta) {
            if (type == "sum") {
                return node->mergeValue + (node->r - node->l + 1) * delta;
            } else {
                return node->mergeValue + delta;
            }
        }
    
        // 根据类型合并左右子节点的值
        int merge(int leftVal, int rightVal) {
            if (type == "sum") {
                return leftVal + rightVal;
            } else if (type == "max") {
                return max(leftVal, rightVal);
            } else if (type == "min") {
                return min(leftVal, rightVal);
            }
            throw invalid_argument("Invalid type");
        }
    
        // 动态创建线段树节点
        void initChildrenIfNeeded(SegmentNode* node) {
            if (node->l == node->r) {
                return;
            }
            int mid = node->l + (node->r - node->l) / 2;
            if (node->left == nullptr) {
                int leftMergeValue = computeRangeValue(node->l, mid, defaultValue);
                node->left = new SegmentNode(node->l, mid, leftMergeValue);
            }
            if (node->right == nullptr) {
                int rightMergeValue = computeRangeValue(mid + 1, node->r, defaultValue);
                node->right = new SegmentNode(mid + 1, node->r, rightMergeValue);
            }
        }
    
        // 下传懒标记，保证子节点的数据正确
        void pushDown(SegmentNode* node) {
            if (node->hasLazyAssign) {
                applyAssign(node->left, node->lazyAssign);
                applyAssign(node->right, node->lazyAssign);
                node->hasLazyAssign = false;
                node->lazyAssign = 0;
            }
            if (node->lazyAdd != 0) {
                applyAdd(node->left, node->lazyAdd);
                applyAdd(node->right, node->lazyAdd);
                node->lazyAdd = 0;
            }
        }
    
        // 将赋值懒标记下传到子节点
        void applyAssign(SegmentNode* child, int val) {
            child->hasLazyAssign = true;
            child->lazyAssign = val;
            child->lazyAdd = 0;
            child->mergeValue = computeRangeValue(child->l, child->r, val);
        }
    
        // 将累加懒标记下传到子节点
        void applyAdd(SegmentNode* child, int delta) {
            if (child->hasLazyAssign) {
                child->lazyAssign += delta;
                child->mergeValue = computeRangeValue(child->l, child->r, child->lazyAssign);
            } else {
                child->lazyAdd += delta;
                child->mergeValue = applyAddToValue(child, delta);
            }
        }
    
        // 单点赋值：将索引 index 赋值为 val
        void update(int index, int val) {
            rangeUpdate(index, index, val);
        }
    
        // 区间赋值：将闭区间 [qL, qR] 赋值为 val
        void rangeUpdate(int qL, int qR, int val) {
            _rangeUpdate(root, qL, qR, val);
        }
    
        void _rangeUpdate(SegmentNode* node, int qL, int qR, int val) {
            if (node->r < qL || node->l > qR) {
                throw invalid_argument("Invalid update range");
            }
            if (qL <= node->l && node->r <= qR) {
                node->hasLazyAssign = true;
                node->lazyAssign = val;
                node->lazyAdd = 0;
                node->mergeValue = computeRangeValue(node->l, node->r, val);
                return;
            }
    
            initChildrenIfNeeded(node);
            pushDown(node);
    
            int mid = node->l + (node->r - node->l) / 2;
            if (qR <= mid) {
                _rangeUpdate(node->left, qL, qR, val);
            } else if (qL > mid) {
                _rangeUpdate(node->right, qL, qR, val);
            } else {
                _rangeUpdate(node->left, qL, mid, val);
                _rangeUpdate(node->right, mid + 1, qR, val);
            }
            node->mergeValue = merge(node->left->mergeValue, node->right->mergeValue);
        }
    
        // 单点累加：将索引 index 增加 delta（可为负数）
        void add(int index, int delta) {
            rangeAdd(index, index, delta);
        }
    
        // 区间累加：将闭区间 [qL, qR] 增加 delta（可为负数）
        void rangeAdd(int qL, int qR, int delta) {
            _rangeAdd(root, qL, qR, delta);
        }
    
        void _rangeAdd(SegmentNode* node, int qL, int qR, int delta) {
            if (node->r < qL || node->l > qR) {
                throw invalid_argument("Invalid update range");
            }
            if (qL <= node->l && node->r <= qR) {
                if (node->hasLazyAssign) {
                    node->lazyAssign += delta;
                    node->mergeValue = computeRangeValue(node->l, node->r, node->lazyAssign);
                } else {
                    node->lazyAdd += delta;
                    node->mergeValue = applyAddToValue(node, delta);
                }
                return;
            }
            initChildrenIfNeeded(node);
            pushDown(node);
    
            int mid = node->l + (node->r - node->l) / 2;
            if (qL <= mid) {
                _rangeAdd(node->left, qL, qR, delta);
            }
            if (qR > mid) {
                _rangeAdd(node->right, qL, qR, delta);
            }
            node->mergeValue = merge(node->left->mergeValue, node->right->mergeValue);
        }
    
        // 查询闭区间 [qL, qR] 的聚合值
        int query(int qL, int qR) {
            return _query(root, qL, qR);
        }
    
        int _query(SegmentNode* node, int qL, int qR) {
            if (node->r < qL || node->l > qR) {
                throw invalid_argument("Invalid query range");
            }
            if (qL <= node->l && node->r <= qR) {
                return node->mergeValue;
            }
    
            initChildrenIfNeeded(node);
            pushDown(node);
    
            int mid = node->l + (node->r - node->l) / 2;
            if (qR <= mid) {
                return _query(node->left, qL, qR);
            } else if (qL > mid) {
                return _query(node->right, qL, qR);
            } else {
                int leftResult = _query(node->left, qL, mid);
                int rightResult = _query(node->right, mid + 1, qR);
                return merge(leftResult, rightResult);
            }
        }
    };
