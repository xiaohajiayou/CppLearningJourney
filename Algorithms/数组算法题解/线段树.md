
# åŸºæœ¬æ•°æ®ç»“æ„
å‰ç½®çŸ¥è¯†

é˜…è¯»æœ¬æ–‡å‰ï¼Œä½ éœ€è¦å…ˆå­¦ä¹ ï¼š

*   [çº¿æ®µæ ‘æ ¸å¿ƒåŸç†åŠå¯è§†åŒ–](https://labuladong.online/algo/data-structure-basic/segment-tree-basic/)
*   [å°è€Œç¾çš„ç®—æ³•æŠ€å·§ï¼šå‰ç¼€å’Œæ•°ç»„](https://labuladong.online/algo/data-structure/prefix-sum/)

çº¿æ®µæ ‘ç»“æ„ä¹Ÿæ˜¯è§£å†³åŒºé—´æ±‚å€¼çš„é—®é¢˜ï¼ŒåŒæ—¶æ”¯æŒå…ƒç´ åŠ¨æ€æ›´æ–°ï¼Œè§£å†³äº†å‰ç¼€å’ŒæŠ€å·§çš„ç—›ç‚¹ã€‚å½“ç„¶ï¼Œä»£ä»·å°±æ˜¯æ—¶é—´å¤æ‚åº¦ç¨å¾®é«˜ä¸€äº›ï¼ŒåŒºé—´æŸ¥è¯¢æ“ä½œå’Œå•ç‚¹åŠ¨æ€æ›´æ–°æ“ä½œçš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ O(logâ¡n)O(\\log n)O(logn)ã€‚

çº¿æ®µæ ‘çš„åŸç†åœ¨å‰é¢çš„æ•°æ®ç»“æ„åŸºç¡€ç« èŠ‚ [çº¿æ®µæ ‘æ ¸å¿ƒåŸç†åŠå¯è§†åŒ–](https://labuladong.online/algo/data-structure-basic/segment-tree-basic/) å·²ç»è®²è§£è¿‡äº†ï¼Œæœ¬æ–‡å°†ä¸å†é‡å¤ï¼Œç›´æ¥ç»™å‡ºçº¿æ®µæ ‘çš„ä»£ç å®ç°ã€‚

[é“¾å¼å®ç° vs æ•°ç»„å®ç°](#)
-----------------

æœ€ç›´æ¥çš„æƒ³æ³•ï¼Œå°±æ˜¯ä½¿ç”¨ç±»ä¼¼äºŒå‰æ ‘èŠ‚ç‚¹çš„ `SegmentNode` ç±»æ¥å®ç°çº¿æ®µæ ‘ï¼Œæˆ‘ä»¬ä¸å¦¨ç§°ä¹‹ä¸ºçº¿æ®µæ ‘çš„é“¾å¼å®ç°ï¼š

    // çº¿æ®µæ ‘èŠ‚ç‚¹
    class SegmentNode {
        // å½“å‰èŠ‚ç‚¹å¯¹åº”çš„ç´¢å¼•åŒºé—´
        int l, r;
    
        // å½“å‰åŒºé—´å†…å…ƒç´ çš„èšåˆå€¼
        int mergeValue;
    
        // å·¦å³å­èŠ‚ç‚¹
        SegmentNode left = null, right = null;
    }
    
    // çº¿æ®µæ ‘
    class SegmentTree {
        SegmentNode root;
    
        // ...
    }

å› ä¸ºçº¿æ®µæ ‘æ˜¯ä¸€ç§è¿‘ä¼¼äºå®Œå…¨äºŒå‰æ ‘çš„ç»“æ„ï¼Œæ‰€ä»¥ä¹Ÿå¯ä»¥ç”¨æ•°ç»„æ¥å­˜å‚¨çº¿æ®µæ ‘ï¼Œä¸éœ€è¦çœŸçš„ä½¿ç”¨ `SegmentNode` æ„å»ºæ ‘ç»“æ„ï¼Œæˆ‘ä»¬ä¸å¦¨ç§°è¿™ç§å®ç°æ–¹å¼ä¸ºçº¿æ®µæ ‘çš„æ•°ç»„å®ç°ï¼š

    // çº¿æ®µæ ‘
    class SegmentTree {
        // ç”¨æ•°ç»„å­˜å‚¨å®Œå…¨äºŒå‰æ ‘ç»“æ„
        int[] tree;
    
        // ...
    }

ä»ç®—æ³•åˆ†æçš„è§’åº¦ï¼Œä¸¤ç§å®ç°çš„ç†è®ºå¤æ‚åº¦éƒ½ä¸€æ ·ï¼Œä½†æ˜¯é“¾å¼ç»“æ„éœ€è¦é¢å¤–ç»´æŠ¤æŒ‡é’ˆä¿¡æ¯ï¼Œæ‰€ä»¥åœ¨å®é™…çš„è¿è¡Œä¸­è‚¯å®šä¼šæ¯”æ•°ç»„å®ç°çš„æ•ˆç‡å·®ä¸€ç‚¹ã€‚ä¸è¿‡åœ¨æ•°ç»„ä¸Šå®ç°æ ‘ç»“æ„æ›´æŠ½è±¡ï¼Œç†è§£éš¾åº¦æ›´å¤§ã€‚

æœ¬ç«™ä¼šç»™å‡ºä¸¤ç§å®ç°çš„ä»£ç ï¼Œå…ˆè®²è§£é“¾å¼çš„å®ç°æ–¹å¼ï¼Œä½ ç†è§£ä¹‹åï¼Œå†çœ‹æ•°ç»„å®ç°çš„ä»£ç ä¼šå¾ˆå®¹æ˜“ã€‚

åœ¨å®é™…ç¬”è¯•ä¸­ï¼Œå¦‚æœéœ€è¦ä½¿ç”¨çº¿æ®µæ ‘ï¼Œå¯ä»¥ç›´æ¥å¤åˆ¶æ•°ç»„å®ç°çš„ä»£ç å»ä½¿ç”¨ã€‚



[é“¾å¼ç»“æ„å®ç°çº¿æ®µæ ‘](#)
--------------

çº¿æ®µæ ‘èŠ‚ç‚¹ `SegmentNode` é™¤äº†è®°å½•å·¦å³èŠ‚ç‚¹çš„æŒ‡é’ˆ `left, right` ä¹‹å¤–ï¼Œè¿˜è¦è®°å½•å½“å‰èŠ‚ç‚¹å¯¹åº”çš„ç´¢å¼•åŒºé—´ `[l, r]` å’ŒåŒºé—´å†…å…ƒç´ çš„èšåˆå€¼ï¼ˆæ¯”å¦‚å…ƒç´ å’Œã€æœ€å¤§å€¼ç­‰ç­‰ï¼‰`mergeValue`ã€‚

è®°å½•ç´¢å¼•åŒºé—´ `[l, r]`ï¼Œæ˜¯ä¸ºäº†åˆ¤æ–­å¾…æŸ¥æ‰¾åŒºé—´æ˜¯å¦å’Œå½“å‰èŠ‚ç‚¹çš„åŒºé—´æœ‰äº¤é›†ï¼Œè‹¥æ— äº¤é›†å¯ä»¥é¿å…éå†å­æ ‘ï¼Œä»è€Œæé«˜æŸ¥è¯¢æ•ˆç‡ï¼›åŒæ—¶ï¼Œå¦‚æœç´¢å¼•åŒºé—´ `[l, r]` å®Œå…¨åŒ…å«åœ¨å¾…æŸ¥æ‰¾åŒºé—´å†…ï¼Œå¯ä»¥ç›´æ¥è¿”å›å½“å‰èŠ‚ç‚¹çš„èšåˆå€¼ï¼Œä¸éœ€è¦å†éå†å­æ ‘ï¼Œä»è€Œæé«˜æŸ¥è¯¢æ•ˆç‡ã€‚

æ›´æ–°æ“ä½œéœ€è¦æ³¨æ„ï¼Œååºä½ç½®éœ€è¦æ ¹æ®å·¦å³å­èŠ‚ç‚¹çš„èšåˆå€¼æ¥æ›´æ–°å½“å‰èŠ‚ç‚¹çš„èšåˆå€¼ï¼Œè¿™æ ·æ‰èƒ½ä¿è¯è¢«æ›´æ–°å¶å­èŠ‚ç‚¹çš„æ•´æ¡è·¯å¾„ä¸Šçš„èšåˆå€¼éƒ½è¢«æ­£ç¡®æ›´æ–°ã€‚

ä¸‹é¢ç›´æ¥çœ‹ä»£ç å§ï¼Œæ³¨é‡Šå†™å¾—å¾ˆè¯¦ç»†äº†ï¼š


cpp ğŸ¤–

    #include <functional>
    #include <iostream>
    #include <stdexcept>
    #include <vector>
    
    // çº¿æ®µæ ‘èŠ‚ç‚¹
    class SegmentNode {
    public:
        // è¯¥èŠ‚ç‚¹è¡¨ç¤ºçš„åŒºé—´èŒƒå›´ [l, r]
        int l, r;
        // [l, r] åŒºé—´å…ƒç´ çš„èšåˆå€¼ï¼ˆå¦‚åŒºé—´å’Œã€åŒºé—´æœ€å¤§å€¼ç­‰ï¼‰
        int mergeVal;
        SegmentNode* left;
        SegmentNode* right;
    
        SegmentNode(int mergeVal, int l, int r) 
            : mergeVal(mergeVal), l(l), r(r), left(nullptr), right(nullptr) {}
    };
    
    class SegmentTree {
    private:
        SegmentNode* root;
        std::function<int(int, int)> merger;
    
        // å®šä¹‰ï¼šå°† nums[l..r] ä¸­çš„å…ƒç´ æ„å»ºæˆçº¿æ®µæ ‘ï¼Œè¿”å›æ ¹èŠ‚ç‚¹
        SegmentNode* build(const std::vector<int>& nums, int l, int r) {
            // åŒºé—´å†…åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œç›´æ¥è¿”å›
            if (l == r) {
                return new SegmentNode(nums[l], l, r);
            }
            // ä»ä¸­é—´åˆ‡åˆ†ï¼Œé€’å½’æ„å»ºå·¦å³å­æ ‘
            int mid = l + (r - l) / 2;
            SegmentNode* left = build(nums, l, mid);
            SegmentNode* right = build(nums, mid + 1, r);
            // æ ¹æ®å·¦å³å­æ ‘çš„èšåˆå€¼ï¼Œè®¡ç®—å½“å‰æ ¹èŠ‚ç‚¹çš„èšåˆå€¼
            SegmentNode* node = new SegmentNode(merger(left->mergeVal, right->mergeVal), l, r);
            // ç»„è£…å·¦å³å­æ ‘
            node->left = left;
            node->right = right;
            return node;
        }
    
        void update(SegmentNode* node, int index, int value) {
            if (node->l == node->r) {
                // æ‰¾åˆ°äº†ç›®æ ‡å¶å­èŠ‚ç‚¹ï¼Œæ›´æ–°å€¼
                node->mergeVal = value;
                return;
            }
    
            int mid = node->l + (node->r - node->l) / 2;
            if (index <= mid) {
                // è‹¥ index è¾ƒå°ï¼Œåˆ™å»å·¦å­æ ‘æ›´æ–°
                update(node->left, index, value);
            } else {
                // è‹¥ index è¾ƒå¤§ï¼Œåˆ™å»å³å­æ ‘æ›´æ–°
                update(node->right, index, value);
            }
            // ååºä½ç½®ï¼Œå·¦å³å­æ ‘å·²ç»æ›´æ–°å®Œæ¯•ï¼Œæ›´æ–°å½“å‰èŠ‚ç‚¹çš„èšåˆå€¼
            node->mergeVal = merger(node->left->mergeVal, node->right->mergeVal);
        }
    
        int query(SegmentNode* node, int qL, int qR) {
            if (qL > qR) {
                throw std::invalid_argument("Invalid query range");
            }
    
            if (node->l == qL && node->r == qR) {
                // å‘½ä¸­äº†ç›®æ ‡åŒºé—´ï¼Œç›´æ¥è¿”å›
                return node->mergeVal;
            }
    
            // æœªç›´æ¥å‘½ä¸­åŒºé—´ï¼Œéœ€è¦ç»§ç»­å‘ä¸‹æŸ¥æ‰¾
            int mid = node->l + (node->r - node->l) / 2;
            if (qR <= mid) {
                // node.l <= qL <= qR <= mid
                // ç›®æ ‡åŒºé—´å®Œå…¨åœ¨å·¦å­æ ‘ä¸­
                return query(node->left, qL, qR);
            } else if (qL > mid) {
                // mid < qL <= qR <= node.r
                // ç›®æ ‡åŒºé—´å®Œå…¨åœ¨å³å­æ ‘ä¸­
                return query(node->right, qL, qR);
            } else {
                // node.l <= qL <= mid < qR <= node.r
                // ç›®æ ‡åŒºé—´æ¨ªè·¨å·¦å³å­æ ‘
                // å°†æŸ¥è¯¢åŒºé—´æ‹†åˆ†æˆ [qL, mid] å’Œ [mid + 1, qR] ä¸¤éƒ¨åˆ†ï¼Œåˆ†åˆ«å‘å·¦å³å­æ ‘æŸ¥è¯¢
                // æœ€åå°†å·¦å³å­æ ‘çš„æŸ¥è¯¢ç»“æœåˆå¹¶
                return merger(
                    query(node->left, qL, mid),
                    query(node->right, mid + 1, qR)
                );
            }
        }
    
    public:
        // åˆ›å»ºçº¿æ®µæ ‘
        // è¾“å…¥æ•°ç»„ nums å’Œä¸€ä¸ªèšåˆå‡½æ•° mergerï¼Œmerger ç”¨äºè®¡ç®—åŒºé—´çš„èšåˆå€¼
        SegmentTree(const std::vector<int>& nums, std::function<int(int, int)> merger)
            : merger(merger) {
            root = build(nums, 0, nums.size() - 1);
        }
    
        void update(int index, int value) {
            update(root, index, value);
        }
    
        int query(int qL, int qR) {
            return query(root, qL, qR);
        }
    };
    
    int main() {
        std::vector<int> arr = {1, 3, 5, 7, 9};
        // ç¤ºä¾‹ï¼Œåˆ›å»ºä¸€æ£µæ±‚å’Œçº¿æ®µæ ‘
        SegmentTree st(arr, [](int a, int b) { return a + b; });
    
        std::cout << st.query(1, 3) << std::endl; // 3 + 5 + 7 = 15
        st.update(2, 10);
        std::cout << st.query(1, 3) << std::endl; // 3 + 10 + 7 = 20
    
        return 0;
    }


æœ‰äº†è¿™ä¸ªçº¿æ®µæ ‘å®ç°ï¼Œåªéœ€è¦ç¨åŠ ä¿®æ”¹ï¼Œå³å¯è§£å†³åŠ›æ‰£ç¬¬ 307 é¢˜ã€Œ[åŒºåŸŸå’Œæ£€ç´¢ - æ•°ç»„å¯ä¿®æ”¹](https://leetcode.cn/problems/range-sum-query-mutable/)ã€ã€‚

[æ•°ç»„å®ç°çº¿æ®µæ ‘](#)
------------

è¦æƒ³ç†è§£æ•°ç»„å®ç°çº¿æ®µæ ‘çš„ä»£ç ï¼Œéœ€è¦ä½ å­¦è¿‡ [äºŒå‰å †å®ä»£ç å®ç°](https://labuladong.online/algo/data-structure-basic/binary-heap-implement/)ï¼Œå› ä¸ºäºŒå‰å †ä¹Ÿæ˜¯ç”¨æ•°ç»„å­˜å‚¨äºŒå‰æ ‘ç»“æ„ï¼Œå’Œè¿™é‡Œçš„åœºæ™¯æœ‰ä¸€äº›ç›¸ä¼¼ä¹‹å¤„ã€‚

è¿™é‡Œæˆ‘ä»¬ä¹ŸæŠŠæ•°ç»„çš„ç´¢å¼• 0 ä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œé‚£ä¹ˆå¯¹äºç´¢å¼•ä¸º `i` çš„èŠ‚ç‚¹ï¼Œå®ƒçš„å·¦å­èŠ‚ç‚¹ç´¢å¼•ä¸º `2 * i + 1`ï¼Œå³å­èŠ‚ç‚¹ç´¢å¼•ä¸º `2 * i + 2`ã€‚

æ•°ç»„å®ç°çº¿æ®µæ ‘å’Œæ•°ç»„å®ç°äºŒå‰å †æœ‰ä¸€ä¸ªé‡è¦ä¸åŒï¼šå‡è®¾æ•°ç»„å…ƒç´ ä¸ªæ•°ä¸º nnnï¼Œé‚£ä¹ˆå­˜å‚¨çº¿æ®µæ ‘çš„æ•°ç»„å®¹é‡åº”è¯¥åˆå§‹åŒ–ä¸º 4Ã—n4 \\times n4Ã—nï¼Œè€ŒäºŒå‰å †æ•°ç»„åªéœ€è¦ nnn çš„å®¹é‡ã€‚

**ä¸ºä»€ä¹ˆæ˜¯ 4Ã—n4 \\times n4Ã—n å‘¢ï¼Ÿä¸»è¦æ˜¯ä¸ºäº†ç¡®ä¿æ•°ç»„èƒ½å¤Ÿå­˜å‚¨çº¿æ®µæ ‘çš„æ‰€æœ‰èŠ‚ç‚¹**ã€‚æˆ‘æ¥ç®€å•è®²è®²è¿™é‡Œé¢çš„åŸå› ã€‚

é¦–å…ˆæ¥çœ‹æ»¡äºŒå‰æ ‘ï¼Œå®ƒçš„æœ€åº•å±‚å¶å­èŠ‚ç‚¹æ˜¯å¡«æ»¡çš„å¯¹å§ï¼š

![](https://labuladong.online/algo/images/complete_tree/perfect.png)

è¿™ç§æƒ…å†µä¸‹ï¼Œå‡è®¾æœ€åº•å±‚å¶å­èŠ‚ç‚¹æœ‰ nnn ä¸ªï¼Œé‚£ä¹ˆæ•´ä¸ªæ»¡äºŒå‰æ ‘çš„èŠ‚ç‚¹æ€»æ•°æ˜¯ 2nâˆ’12n - 12nâˆ’1 ä¸ªã€‚

æ¥ç€æ¥çœ‹çº¿æ®µæ ‘ï¼Œçº¿æ®µæ ‘çš„å¶å­èŠ‚ç‚¹å°±æ˜¯æ•°ç»„ä¸­çš„å…ƒç´ ï¼Œå‡è®¾æ•°ç»„ä¸­æœ‰ nnn ä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆçº¿æ®µæ ‘çš„å¶å­èŠ‚ç‚¹æ€»æ•°å¿…ç„¶æ˜¯ nnn ä¸ªã€‚

ä½†æ˜¯çº¿æ®µæ ‘ä¸ä¸€å®šæ˜¯æ»¡äºŒå‰æ ‘ï¼Œæ¯”æ–¹è¿™ä¸ªå¯è§†åŒ–é¢æ¿å±•ç¤ºçš„çº¿æ®µæ ‘ç»“æ„ï¼š

[Algorithm visualize](https://labuladong.online/algo-visualize/tutorial/segment-tree-height/?stepId=-1) Â  **ç®—æ³•å¯è§†åŒ–é¢æ¿**Link copied!

æŠŠæ ¹èŠ‚ç‚¹ä½œä¸ºç¬¬ä¸€å±‚ï¼Œé¢æ¿ä¸­çš„çº¿æ®µæ ‘å…±æœ‰ 5 å±‚ï¼Œå¶å­èŠ‚ç‚¹åˆ†å¸ƒåœ¨ç¬¬ 5 å’Œç¬¬ 4 å±‚ï¼Œè¿™ç§æƒ…å†µä¸‹ï¼Œè¯·ä½ ä¼°ç®—ä¸€ä¸‹æ•´æ£µæ ‘ä¸Šçš„èŠ‚ç‚¹æ€»æ•°æ˜¯å¤šå°‘ï¼Ÿ

æˆ‘ä»¬è¦æ ¹æ®èŠ‚ç‚¹æ€»æ•°ï¼Œæ¥ç¡®å®šå­˜å‚¨çº¿æ®µæ ‘çš„æ•°ç»„å®¹é‡ã€‚ä¼°ç®—ä¸å‡†çš„è¯ï¼Œç»™ä¸€ä¸ªä¸Šç•Œä¹Ÿè¡Œï¼Œå¤šä¸€äº›æ²¡å…³ç³»ï¼Œä½†ç»å¯¹ä¸èƒ½å°‘ã€‚

æ¯”æ–¹è¯´ç°åœ¨æˆ‘å°±ä¼°ç®—ç¬¬ 5 å±‚å…±æœ‰ 2Ã—n2 \\times n2Ã—n ä¸ªèŠ‚ç‚¹ï¼Œè¿™ä¸ªè‚¯å®šæ˜¯ä¸Šç•Œã€‚

å› ä¸ºç¬¬ 5 å±‚æœ‰ 2Ã—n2 \\times n2Ã—n ä¸ªèŠ‚ç‚¹çš„è¯ï¼Œç¬¬ 4 å±‚å°±åº”è¯¥æœ‰ nnn ä¸ªèŠ‚ç‚¹ã€‚ä½†è¿™ä¸ª nnn æ˜¯åŒæ—¶åˆ†å¸ƒåœ¨ç¬¬ 4ã€5 å±‚çš„å¶å­èŠ‚ç‚¹æ€»æ•°ï¼Œæ‰€ä»¥ç¬¬ 4 å±‚çš„å®é™…èŠ‚ç‚¹æ•°é‡è‚¯å®šå°äº nnnï¼Œè¿›è€Œç¬¬ 5 å±‚çš„èŠ‚ç‚¹æ•°é‡ä¹Ÿæ˜¯å°äº 2Ã—n2 \\times n2Ã—nã€‚

ç°åœ¨ä¼°ç®—ç¬¬ 5 å±‚ï¼ˆæœ€åº•å±‚ï¼‰æœ‰ 2Ã—n2 \\times n2Ã—n ä¸ªèŠ‚ç‚¹ï¼Œé‚£ä¹ˆå°±å¯ä»¥ä¼°ç®—æ•´æ£µäºŒå‰æ ‘çš„èŠ‚ç‚¹æ€»æ•°ä¸º 4Ã—n4 \\times n4Ã—n ä¸ªã€‚

å¦‚æœæ»¡äºŒå‰æ ‘çš„æœ€åº•å±‚å¶å­èŠ‚ç‚¹æ•°é‡æ˜¯ xxxï¼Œé‚£ä¹ˆæ»¡äºŒå‰æ ‘çš„èŠ‚ç‚¹æ€»æ•°æ˜¯ 2xâˆ’12x - 12xâˆ’1ã€‚çº¿æ®µæ ‘ä¸æ˜¯æ»¡äºŒå‰æ ‘ï¼Œæ‰€ä»¥è¿™é‡Œçš„ 4Ã—n4 \\times n4Ã—n è‚¯å®šå¤§äºçº¿æ®µæ ‘å®é™…çš„æ€»ç»“ç‚¹æ•°ï¼Œæ˜¯ä¸€ä¸ªåå¤§çš„ä¸Šç•Œã€‚

ç»¼ä¸Šï¼Œæˆ‘ä»¬åˆå§‹åŒ–ä¸€ä¸ªå®¹é‡ä¸º 4Ã—n4 \\times n4Ã—n çš„æ•°ç»„ï¼Œè‚¯å®šå¯ä»¥å­˜å‚¨ nnn ä¸ªå¶å­èŠ‚ç‚¹çš„çº¿æ®µæ ‘ã€‚

å¥½äº†ï¼Œæ¥ä¸‹æ¥å¯ä»¥çœ‹æ•°ç»„å®ç°çº¿æ®µæ ‘çš„ä»£ç äº†ï¼Œæ³¨é‡Šå†™å¾—å¾ˆè¯¦ç»†ï¼š


cpp ğŸ¤–

    #include <iostream>
    #include <vector>
    #include <functional>
    #include <stdexcept>
    
    class ArraySegmentTree {
        // ç”¨æ•°ç»„å­˜å‚¨çº¿æ®µæ ‘ç»“æ„
        std::vector<int> tree;
        // å…ƒç´ ä¸ªæ•°
        int n;
        std::function<int(int, int)> merger;
    
        // å®šä¹‰ï¼šå¯¹ nums[l..r] åŒºé—´çš„å…ƒç´ æ„å»ºçº¿æ®µæ ‘ï¼ŒrootIndex æ˜¯æ ¹èŠ‚ç‚¹
        void build(const std::vector<int>& nums, int l, int r, int rootIndex) {
            if (l == r) {
                // åŒºé—´å†…åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œè®¾ç½®ä¸ºå¶å­èŠ‚ç‚¹
                tree[rootIndex] = nums[l];
                return;
            }
    
            // ä»ä¸­é—´åˆ‡åˆ†ï¼Œé€’å½’æ„å»ºå·¦å³å­æ ‘
            int mid = l + (r - l) / 2;
            int leftRootIndex = leftChild(rootIndex);
            int rightRootIndex = rightChild(rootIndex);
            // é€’å½’æ„å»º nums[l..mid]ï¼Œæ ¹èŠ‚ç‚¹ä¸º leftRootIndex
            build(nums, l, mid, leftRootIndex);
            // é€’å½’æ„å»º nums[mid+1..r]ï¼Œæ ¹èŠ‚ç‚¹ä¸º rightRootIndex
            build(nums, mid + 1, r, rightRootIndex);
    
            // ååºä½ç½®ï¼Œå·¦å³å­æ ‘å·²ç»æ„å»ºå®Œæ¯•ï¼Œæ›´æ–°å½“å‰èŠ‚ç‚¹çš„èšåˆå€¼
            tree[rootIndex] = merger(tree[leftRootIndex], tree[rightRootIndex]);
        }
    
        void update(int l, int r, int rootIndex, int index, int value) {
            // å½“å‰èŠ‚ç‚¹ä¸º rootIndexï¼Œå¯¹åº”çš„åŒºé—´ä¸º [l, r]
            // å»å­æ ‘æ›´æ–° nums[index] ä¸º value
            if (l == r) {
                // æ‰¾åˆ°äº†ç›®æ ‡å¶å­èŠ‚ç‚¹ï¼Œæ›´æ–°å€¼
                tree[rootIndex] = value;
                return;
            }
    
            int mid = l + (r - l) / 2;
            if (index <= mid) {
                // è‹¥ index è¾ƒå°ï¼Œåˆ™å»å·¦å­æ ‘æ›´æ–°
                update(l, mid, leftChild(rootIndex), index, value);
            } else {
                // è‹¥ index è¾ƒå¤§ï¼Œåˆ™å»å³å­æ ‘æ›´æ–°
                update(mid + 1, r, rightChild(rootIndex), index, value);
            }
    
            // ååºä½ç½®ï¼Œå·¦å³å­æ ‘å·²ç»æ›´æ–°å®Œæ¯•ï¼Œæ›´æ–°å½“å‰èŠ‚ç‚¹çš„èšåˆå€¼
            tree[rootIndex] = merger(tree[leftChild(rootIndex)], tree[rightChild(rootIndex)]);
        }
    
        int query(int l, int r, int rootIndex, int qL, int qR) {
            if (qL == l && r == qR) {
                // å‘½ä¸­äº†ç›®æ ‡åŒºé—´ï¼Œç›´æ¥è¿”å›
                return tree[rootIndex];
            }
    
            int mid = l + (r - l) / 2;
            int leftRootIndex = leftChild(rootIndex);
            int rightRootIndex = rightChild(rootIndex);
            if (qR <= mid) {
                // node.l <= qL <= qR <= mid
                // ç›®æ ‡åŒºé—´å®Œå…¨åœ¨å·¦å­æ ‘ä¸­
                return query(l, mid, leftRootIndex, qL, qR);
            } else if (qL > mid) {
                // mid < qL <= qR <= node.r
                // ç›®æ ‡åŒºé—´å®Œå…¨åœ¨å³å­æ ‘ä¸­
                return query(mid + 1, r, rightRootIndex, qL, qR);
            } else {
                // node.l <= qL <= mid < qR <= node.r
                // ç›®æ ‡åŒºé—´æ¨ªè·¨å·¦å³å­æ ‘
                // å°†æŸ¥è¯¢åŒºé—´æ‹†åˆ†æˆ [qL, mid] å’Œ [mid + 1, qR] ä¸¤éƒ¨åˆ†ï¼Œåˆ†åˆ«å‘å·¦å³å­æ ‘æŸ¥è¯¢
                return merger(query(l, mid, leftRootIndex, qL, mid),
                              query(mid + 1, r, rightRootIndex, mid + 1, qR));
            }
        }
    
        int leftChild(int pos) {
            return 2 * pos + 1;
        }
    
        int rightChild(int pos) {
            return 2 * pos + 2;
        }
    
    public:
        ArraySegmentTree(const std::vector<int>& nums, std::function<int(int, int)> mergeFunc)
            : n(nums.size()), merger(mergeFunc) {
            // åˆ†é… 4 å€æ•°ç»„é•¿åº¦çš„ç©ºé—´ï¼Œå­˜å‚¨çº¿æ®µæ ‘
            tree.resize(4 * n);
            build(nums, 0, n - 1, 0);
        }
    
        void update(int index, int value) {
            update(0, n - 1, 0, index, value);
        }
    
        int query(int qL, int qR) {
            if (qL < 0 || qR >= n || qL > qR) {
                throw std::invalid_argument("Invalid range: [" + std::to_string(qL) + ", " + std::to_string(qR) + "]");
            }
            return query(0, n - 1, 0, qL, qR);
        }
    };
    
    int main() {
        std::vector<int> arr = {1, 3, 5, 7, 9};
        // ç¤ºä¾‹ï¼Œåˆ›å»ºä¸€æ£µæ±‚å’Œçº¿æ®µæ ‘
        ArraySegmentTree st(arr, [](int a, int b) { return a + b; });
    
        std::cout << st.query(1, 3) << std::endl; // 3 + 5 + 7 = 15
        st.update(2, 10);
        std::cout << st.query(1, 3) << std::endl; // 3 + 10 + 7 = 20
        return 0;
    }


[è¿›é˜¶ä¼˜åŒ–](#)
---------

ä¸Šé¢å®ç°çš„çº¿æ®µæ ‘è¿˜æœ‰ä¸¤ä¸ªå±€é™æ€§ï¼š

1ã€`update` æ–¹æ³•åªæ”¯æŒå•ç‚¹æ›´æ–°ï¼Œä¸æ”¯æŒåŒºé—´æ›´æ–°ã€‚å½“ç„¶ç†è®ºä¸Šä½ å¯ä»¥åŸºäºè¿™ä¸ªå•ç‚¹æ›´æ–°å®ç°åŒºé—´æ›´æ–°ï¼š

    // å•ç‚¹æ›´æ–° nums[index] = valï¼Œæ—¶é—´å¤æ‚åº¦ O(logn)
    void update(int index, int val) {
        // ...
    }
    
    // åŒºé—´æ›´æ–° nums[l..r] = val
    void updateRange(int l, int r, int val) {
        for (int i = l; i <= r; i++) {
            update(i, val);
        }
    }

ä½†æ˜¯è¿™æ ·çš„æ—¶é—´å¤æ‚åº¦ä¸º O(mlogâ¡n)O(m \\log n)O(mlogn)ï¼Œmmm æ˜¯æ›´æ–°åŒºé—´çš„é•¿åº¦ï¼Œæ•ˆç‡æ¯”è¾ƒå·®ã€‚æ‰€ä»¥æœ‰æ²¡æœ‰åŠæ³•èƒ½è®©ä»»æ„åŒºé—´æ›´æ–°çš„æ—¶é—´å¤æ‚åº¦ä¹Ÿä¿æŒåœ¨ O(logâ¡n)O(\\log n)O(logn) å‘¢ï¼Ÿ

2ã€æ„é€ çº¿æ®µæ ‘æ—¶éœ€è¦æ„é€ å‡ºæ‰€æœ‰èŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œä½ æ„é€ çº¿æ®µæ ‘çš„æ—¶å€™å°±éœ€è¦ä¼ å…¥ä¸€ä¸ªåŒ…å«æ‰€æœ‰å…ƒç´ çš„æ•°ç»„ï¼Œè¿™åœ¨æŸäº›åœºæ™¯ä¸‹æ˜¯ä¸ç°å®çš„ã€‚

æ¯”æ–¹è¯´æˆ‘è¦åœ¨ä¸€ä¸ªè§„æ¨¡ä¸º 10910^9109 çš„åŒºé—´ä¸Šè¿›è¡ŒåŒºé—´æŸ¥è¯¢å’Œæ›´æ–°ï¼Œéš¾é“æˆ‘éœ€è¦å…ˆæ„é€ ä¸€ä¸ªåŒ…å« 10910^9109 ä¸ªå…ƒç´ çš„æ•°ç»„å—ï¼Ÿè¿™æ˜¾ç„¶æ˜¯éå¸¸æ¶ˆè€—å†…å­˜çš„ã€‚

æœ‰æ²¡æœ‰åŠæ³•è®©çº¿æ®µæ ‘åŠ¨æ€æ„å»ºï¼Œä¼˜åŒ–ç¨€ç–æ•°æ®ä¸Šçš„å†…å­˜å¼€é”€å‘¢ï¼Ÿ

å¯¹äºè¿™ä¸¤ä¸ªé—®é¢˜çš„ä¼˜åŒ–ï¼Œæˆ‘ä»¬ä¼šåœ¨åé¢çš„æ–‡ç« ä¸­ç»™å‡ºã€‚
# ä¼˜åŒ–-åŠ¨æ€çº¿æ®µæ ‘


å‰ç½®çŸ¥è¯†

é˜…è¯»æœ¬æ–‡å‰ï¼Œä½ éœ€è¦å…ˆå­¦ä¹ ï¼š

*   [çº¿æ®µæ ‘åŸºæœ¬å®ç°](https://labuladong.online/algo/data-structure/segment-tree-implement/)

[çº¿æ®µæ ‘åŸºæœ¬å®ç°](https://labuladong.online/algo/data-structure/segment-tree-implement/) ä¸­ç”¨æ•°ç»„å’Œé“¾è¡¨åˆ†åˆ«å®ç°äº†çº¿æ®µæ ‘ï¼Œæ–‡æœ«ç•™äº†ä¸¤ä¸ªä¼˜åŒ–ç‚¹ï¼Œåˆ†åˆ«æ˜¯åŒºé—´æ›´æ–°é—®é¢˜å’Œç¨€ç–æ•°æ®çš„å†…å­˜ä¼˜åŒ–é—®é¢˜ã€‚

æœ¬æ–‡å°†å®ç°ä¸€ä¸ªåŠ¨æ€çº¿æ®µæ ‘ `DynamicSegmentTree`ï¼Œåˆ©ç”¨ã€ŒåŠ¨æ€å¼€ç‚¹æŠ€æœ¯ã€ï¼Œä¼˜åŒ–ç¨€ç–æ•°æ®çš„å†…å­˜å ç”¨é—®é¢˜ã€‚


è¿™ä¸ªå®ç°çš„åŒºåˆ«æ˜¯ï¼Œä¸éœ€è¦ä½ åœ¨ä¸€å¼€å§‹å°±è¾“å…¥ä¸€ä¸ªæ•°ç»„ï¼Œåªéœ€è¦è¾“å…¥çº¿æ®µæ ‘çš„åŒºé—´èŒƒå›´ï¼Œå¹¶ç»™å®šä¸€ä¸ªé»˜è®¤å€¼ã€‚

æ¯”æ–¹è¯´ä½ è¾“å…¥åŒºé—´èŒƒå›´ä¸º `[0, 1000000]`ï¼Œé»˜è®¤å€¼ä¸º `0`ï¼Œå°±ç›¸å½“äºè¾“å…¥äº†ä¸€ä¸ªå¤§å°ä¸º `1000001` çš„æ•°ç»„ï¼Œå…¶ä¸­æ¯ä¸ªå…ƒç´ çš„å€¼éƒ½æ˜¯ `0`ã€‚

`DynamicSegmentTree` å¹¶ä¸ä¼šåœ¨åˆå§‹åŒ–çš„æ—¶å€™çœŸçš„å¼€è¾Ÿè¿™ä¹ˆå¤§çš„å†…å­˜ç©ºé—´æ¥å­˜å‚¨ `1000001` ä¸ªèŠ‚ç‚¹ï¼Œè€Œæ˜¯åœ¨æ›´æ–°å…ƒç´ çš„æ—¶å€™ï¼Œæ ¹æ®éœ€è¦åŠ¨æ€åœ°åˆ›å»ºèŠ‚ç‚¹ï¼Œè¿™å°±æ˜¯æ‰€è°“çš„ã€ŒåŠ¨æ€å¼€ç‚¹ã€ã€‚

è¿™ç§åŠ¨æ€çº¿æ®µæ ‘ç”¨é“¾å¼ç»“æ„æ¯”è¾ƒå®¹æ˜“å®ç°ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åŸºäº [çº¿æ®µæ ‘åŸºæœ¬å®ç°](https://labuladong.online/algo/data-structure/segment-tree-implement/) ä¸­çš„ `LinkedSegmentTree` æ¥å®ç°åŠ¨æ€çº¿æ®µæ ‘ã€‚

ä¸‹é¢é«˜äº®æ˜¾ç¤ºäº†éœ€è¦ä¿®æ”¹çš„ä»£ç éƒ¨åˆ†ï¼Œä¸»è¦å°±æ˜¯åœ¨ `update` é€»è¾‘ä¸­é¢å¤–è°ƒç”¨ä¸€æ¬¡ `initChildrenIfNeeded` æ–¹æ³•ï¼Œç”¨äºåœ¨éœ€è¦çš„æ—¶å€™åŠ¨æ€åœ°åˆ›å»ºå­èŠ‚ç‚¹ï¼Œå…¶ä»–çš„ä»£ç éƒ½å¯ä»¥ä¿æŒä¸å˜ï¼š


cpp ğŸ¤–

    #include <functional>
    #include <stdexcept>
    
    // çº¿æ®µæ ‘èŠ‚ç‚¹
    class SegmentNode {
    public:
        int l, r;
        int mergeVal;
        SegmentNode* left;
        SegmentNode* right;
    
        // æ„é€ å‡½æ•°
        SegmentNode(int l, int r, int mergeVal)
            : l(l), r(r), mergeVal(mergeVal), left(nullptr), right(nullptr) {}
    };
    
    class DynamicSegmentTree {
    private:
        SegmentNode* root;
        std::function<int(int, int)> merger;
        int defaultValue;
    
        // æ£€æŸ¥å½“å‰èŠ‚ç‚¹æ˜¯å¦éœ€è¦åˆ›å»ºå­èŠ‚ç‚¹
        void initChildrenIfNeeded(SegmentNode* node) {
            if (node->l == node->r) {
                // å¶å­èŠ‚ç‚¹ï¼Œæ— éœ€åˆ›å»ºå­èŠ‚ç‚¹
                return;
            }
            int mid = node->l + (node->r - node->l) / 2;
            if (node->left == nullptr) {
                // å·¦å­èŠ‚ç‚¹ä¸ºç©ºï¼Œåˆ›å»ºå·¦å­èŠ‚ç‚¹
                node->left = new SegmentNode(node->l, mid, defaultValue);
            }
            if (node->right == nullptr) {
                // å³å­èŠ‚ç‚¹ä¸ºç©ºï¼Œåˆ›å»ºå³å­èŠ‚ç‚¹
                node->right = new SegmentNode(mid + 1, node->r, defaultValue);
            }
        }
    
        // å•ç‚¹æ›´æ–°ï¼šå°†ä¸‹æ ‡ index çš„å€¼æ›´æ–°ä¸º value
        void update(SegmentNode* node, int index, int value) {
            if (node->l == node->r) {
                node->mergeVal = value;
                return;
            }
            // åŠ¨æ€åˆ›å»ºå­èŠ‚ç‚¹
            initChildrenIfNeeded(node);
            int mid = node->l + (node->r - node->l) / 2;
            if (index <= mid) {
                update(node->left, index, value);
            } else {
                update(node->right, index, value);
            }
            node->mergeVal = merger(node->left->mergeVal, node->right->mergeVal);
        }
    
        // åŒºé—´æŸ¥è¯¢ï¼šè¿”å›åŒºé—´ [qL, qR] çš„èšåˆå€¼
        int query(SegmentNode* node, int qL, int qR) {
            if (node->r < qL || node->l > qR) {
                throw std::invalid_argument("Invalid query range");
            }
            if (qL <= node->l && node->r <= qR) {
                return node->mergeVal;
            }
            int mid = node->l + (node->r - node->l) / 2;
            if (qR <= mid) {
                return query(node->left, qL, qR);
            } else if (qL > mid) {
                return query(node->right, qL, qR);
            } else {
                return merger(query(node->left, qL, mid), query(node->right, mid + 1, qR));
            }
        }
    
        // è¾…åŠ©å‡½æ•°ï¼Œé€’å½’é‡Šæ”¾èŠ‚ç‚¹å†…å­˜
        void deleteTree(SegmentNode* node) {
            if (!node) return;
            deleteTree(node->left);
            deleteTree(node->right);
            delete node;
        }
    
    public:
        // æ„é€ å‡½æ•°
        DynamicSegmentTree(int start, int end, std::function<int(int, int)> merger, int defaultValue)
            : merger(merger), defaultValue(defaultValue) {
            // åªåˆ›å»ºæ ¹èŠ‚ç‚¹ï¼Œåˆå§‹å€¼å‡ä¸º defaultValue
            root = new SegmentNode(start, end, defaultValue);
        }
    
        // ææ„å‡½æ•°ï¼Œé‡Šæ”¾å†…å­˜
        ~DynamicSegmentTree() {
            deleteTree(root);
        }
    
        // å•ç‚¹æ›´æ–°æ¥å£
        void update(int index, int value) {
            update(root, index, value);
        }
    
        // åŒºé—´æŸ¥è¯¢æ¥å£ï¼šè¿”å›åŒºé—´ [qL, qR] çš„èšåˆå€¼
        int query(int qL, int qR) {
            if(qL > qR) {
                throw std::invalid_argument("Invalid query range");
            }
            return query(root, qL, qR);
        }
    };


ä½ å¯ä»¥åˆ©ç”¨åŠ›æ‰£ç¬¬ 307 é¢˜ã€Œ[åŒºåŸŸå’Œæ£€ç´¢ - æ•°ç»„å¯ä¿®æ”¹](https://leetcode.cn/problems/range-sum-query-mutable/)ã€æ¥éªŒè¯è¿™ä¸ªå®ç°çš„æ­£ç¡®æ€§ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒåŠ¨æ€çº¿æ®µæ ‘åˆå§‹åŒ–æ—¶åªæœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦åœ¨ä»£ç ä¸­æ‰‹åŠ¨è°ƒç”¨ `update` æ–¹æ³•æŠŠ `nums` æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ æ›´æ–°åˆ°çº¿æ®µæ ‘ä¸­ï¼š


cpp ğŸ¤–

    class NumArray {
    private:
        DynamicSegmentTree* segmentTree;
    
    public:
        NumArray(vector<int>& nums) {
            // åˆå§‹åŒ–çº¿æ®µæ ‘ï¼ŒåŒºé—´èŒƒå›´ä¸º [0, nums.length - 1]
            segmentTree = new DynamicSegmentTree(0, nums.size() - 1, 
                                               [](int a, int b) { return a + b; }, 0);
            // å°† nums æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ æ›´æ–°åˆ°çº¿æ®µæ ‘ä¸­
            for (int i = 0; i < nums.size(); i++) {
                segmentTree->update(i, nums[i]);
            }
        }
        
        ~NumArray() {
            delete segmentTree;
        }
        
        void update(int index, int val) {
            segmentTree->update(index, val);
        }
        
        int sumRange(int left, int right) {
            return segmentTree->query(left, right);
        }
    };


# ä¼˜åŒ–-æ‡’æ›´æ–°çº¿æ®µæ ‘

å‰ç½®çŸ¥è¯†

é˜…è¯»æœ¬æ–‡å‰ï¼Œä½ éœ€è¦å…ˆå­¦ä¹ ï¼š

*   [çº¿æ®µæ ‘åŸºæœ¬å®ç°](https://labuladong.online/algo/data-structure/segment-tree-implement/)
*   [ä¼˜åŒ–ï¼šåŠ¨æ€çº¿æ®µæ ‘](https://labuladong.online/algo/data-structure/segment-tree-dynamic/)

[çº¿æ®µæ ‘åŸºæœ¬å®ç°](https://labuladong.online/algo/data-structure/segment-tree-implement/) ä¸­ç”¨æ•°ç»„å’Œé“¾è¡¨åˆ†åˆ«å®ç°äº†çº¿æ®µæ ‘ï¼Œæ–‡æœ«ç•™äº†ä¸¤ä¸ªä¼˜åŒ–ç‚¹ï¼Œåˆ†åˆ«æ˜¯åŒºé—´æ›´æ–°é—®é¢˜å’Œç¨€ç–æ•°æ®çš„å†…å­˜ä¼˜åŒ–é—®é¢˜ã€‚

[ä¼˜åŒ–ï¼šåŠ¨æ€çº¿æ®µæ ‘](https://labuladong.online/algo/data-structure/segment-tree-dynamic/) è§£å†³äº†ç¨€ç–æ•°æ®çš„å†…å­˜ä¼˜åŒ–é—®é¢˜ï¼Œ**æœ¬æ–‡å°†åŸºäº `DynamicSegmentTree` çš„é“¾å¼å®ç°ï¼Œä½¿ç”¨ã€Œæ‡’æ›´æ–°ã€æŠ€æœ¯ï¼Œä¸ºçº¿æ®µæ ‘æ–°å¢ `rangeAdd/rangeUpdate` æ–¹æ³•ï¼Œåœ¨ O(logâ¡N)O(\\log N)O(logN) æ—¶é—´å¤æ‚åº¦å†…å®Œæˆä»»æ„é•¿åº¦çš„åŒºé—´æ›´æ–°**ã€‚

æœ¬æ–‡å®ç°çš„åŒºé—´æ›´æ–°çº¿æ®µæ ‘å’Œä¹‹å‰çš„å•ç‚¹æ›´æ–°çº¿æ®µæ ‘æœ‰å‡ ç‚¹åŒºåˆ«ï¼š

1ã€å› ä¸ºå•ç‚¹æ›´æ–°å¯ä»¥çœ‹ä½œæ˜¯é•¿åº¦ä¸º 1 çš„åŒºé—´æ›´æ–°ï¼Œå¤æ‚åº¦è¿˜æ˜¯ O(logâ¡N)O(\\log N)O(logN)ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸éœ€è¦å•ç‹¬å®ç°å•ç‚¹æ›´æ–°äº†ã€‚

2ã€æˆ‘ä»¬ä¸æ¥å— `merge` èšåˆå‡½æ•°äº†ï¼Œå› ä¸ºæ¶‰åŠåŒºé—´æ‡’æ›´æ–°ï¼Œå¦‚æœåŒæ—¶è€ƒè™‘ä¸åŒçš„èšåˆå‡½æ•°ï¼Œä¼šå¼•å…¥ä¸€äº›ç¼–ç¨‹è¯­è¨€å±‚é¢çš„ç»†èŠ‚é—®é¢˜ï¼Œå¯¹äºç®—æ³•çš„å­¦ä¹ æ²¡æœ‰ä»€ä¹ˆæ„ä¹‰ï¼Œæ‰€ä»¥æœ¬æ–‡ä»…ç»™å‡º**æ±‚å’Œçº¿æ®µæ ‘**çš„å®ç°ã€‚å¦‚æœä½ éœ€è¦æ±‚æœ€å€¼ç­‰å…¶ä»–åœºæ™¯ï¼Œå¯ä»¥è‡ªè¡Œä¿®æ”¹ä»£ç ä¸­çš„èšåˆè®¡ç®—é€»è¾‘ï¼Œæˆ–è€…ä½¿ç”¨æ–‡æœ«æä¾›çš„ `AllInOneSegmentTree` ä¸‡èƒ½æ¨¡æ¿ã€‚

3ã€çº¿æ®µæ ‘çš„åŒºé—´æ›´æ–°å¯ä»¥æ˜¯åŒºé—´èµ‹å€¼ï¼ˆAssignï¼‰ï¼Œä¹Ÿå¯ä»¥åŒºé—´ç´¯åŠ ï¼ˆIncrementï¼‰ã€‚

æ¯”æ–¹ `[1, 2, 3, 4, 5]` è¿™ä¸ªæ•°ç»„ï¼Œå°†ç´¢å¼•åŒºé—´ `[1, 3]` å†…çš„å…ƒç´ éƒ½èµ‹å€¼ä¸º 10 å«åšåŒºé—´èµ‹å€¼ï¼Œç»“æœæ˜¯ `[1, 10, 10, 10, 5]`ï¼›å°†ç´¢å¼•åŒºé—´ `[1, 3]` å†…çš„å…ƒç´ éƒ½å¢åŠ  1 å«åšåŒºé—´ç´¯åŠ ï¼Œç»“æœæ˜¯ `[1, 3, 4, 5, 5]`ã€‚

è¿™ä¸¤ç§åœºæ™¯éƒ½æ˜¯ç®—æ³•é¢˜ä¸­å¸¸è§çš„ï¼Œæœ¬æ–‡ä¼šåŒæ—¶ç»™å‡ºè¿™ä¸¤ç§å®ç°ã€‚

æˆ‘ä»¬ä¹‹å‰å®ç°çš„çº¿æ®µæ ‘ä¸»è¦ API å¦‚ä¸‹ï¼š

    class SegmentTree {
    
        // åˆå§‹åŒ–çº¿æ®µæ ‘
        public SegmentTree(int[] nums, Function<Integer, Integer> merge) {}
    
        // æŸ¥è¯¢é—­åŒºé—´ [qL, qR] çš„èšåˆå€¼ï¼Œæ—¶é—´å¤æ‚åº¦ O(logN)
        public int query(int qL, int qR) {}
        
        // å•ç‚¹æ›´æ–°ï¼Œè®¾ç½® nums[i] = valï¼Œæ—¶é—´å¤æ‚åº¦ O(logN)
        public void update(int i, int val) {}
    }

æœ¬æ–‡å°†å®ç°ä»¥ä¸‹ä¸¤ç§çº¿æ®µæ ‘ï¼š

    // åŒºé—´ç´¯åŠ çº¿æ®µæ ‘
    class IncrSegmentTree {
    
        // åˆå§‹åŒ–åŠ¨æ€çº¿æ®µæ ‘
        public IncrSegmentTree(int start, int end, int defaultValue) {}
    
        // å°†é—­åŒºé—´ [qL, qR] å¢åŠ  deltaï¼ˆå¯ä»¥æ˜¯è´Ÿæ•°ï¼‰ï¼Œæ—¶é—´å¤æ‚åº¦ O(logN)
        public void rangeAdd(int qL, int qR, int delta) {}
    
        // æŸ¥è¯¢é—­åŒºé—´ [qL, qR] çš„å…ƒç´ å’Œï¼Œæ—¶é—´å¤æ‚åº¦ O(logN)
        public int query(int qL, int qR) {}
    }
    
    // åŒºé—´èµ‹å€¼çº¿æ®µæ ‘
    class AssignSegmentTree {
    
        // åˆå§‹åŒ–åŠ¨æ€çº¿æ®µæ ‘
        public AssignSegmentTree(int start, int end, int defaultValue) {}
    
        // å°†é—­åŒºé—´ [qL, qR] èµ‹å€¼ä¸º valï¼Œæ—¶é—´å¤æ‚åº¦ O(logN)
        public void rangeUpdate(int qL, int qR, int val) {}
    
        // æŸ¥è¯¢é—­åŒºé—´ [qL, qR] çš„å…ƒç´ å’Œï¼Œæ—¶é—´å¤æ‚åº¦ O(logN)
        public int query(int qL, int qR) {}
    }

`rangeAdd` å’Œ `rangeUpdate` çš„å®ç°é€»è¾‘éå¸¸ç±»ä¼¼ï¼Œç†è®ºä¸Šå¯ä»¥åŒæ—¶å®ç°åˆ°ä¸€ä¸ªç±»ä¸Šï¼Œä½†æ˜¯ä¸¤ä¸ªé€»è¾‘æ··åœ¨ä¸€èµ·ä»£ç ä¼šæ›´å¤æ‚ï¼Œå¾’å¢ç†è§£æˆæœ¬ï¼Œè€Œä¸”å®é™…çš„ç®—æ³•é¢˜ä¸­ï¼Œä¸€èˆ¬åªä¼šç”¨åˆ°åŒºé—´ç´¯åŠ æˆ–åŒºé—´èµ‹å€¼ä¸­çš„ä¸€ç§ï¼Œä¸ä¼šåŒæ—¶ç”¨åˆ°ï¼Œæ‰€ä»¥æœ¬æ–‡è¿˜æ˜¯æŠŠå®ƒä»¬æ‹†åˆ°ä¸¤ä¸ªç±»åˆ†åˆ«å®ç°ï¼Œæ–¹ä¾¿å¤§å®¶ç†è§£å…¶åŸç†ã€‚

æœ¬æ–‡çš„æœ€åä¼šç»™å‡ºä¸€ä¸ªä¸‡èƒ½çº¿æ®µæ ‘æ¨¡æ¿ `AllInOneSegmentTree`ï¼ŒåŒæ—¶åŒ…å«ä¸Šè¿°æ‰€æœ‰ API å’Œçº¿æ®µæ ‘çš„æ‰€æœ‰ä¼˜åŒ–ï¼Œç¬”è¯•æ—¶å¯ä»¥ç›´æ¥æ‹¿æ¥ä½¿ç”¨ã€‚


[æ‡’æ›´æ–°çš„æ ¸å¿ƒåŸç†](#)
-------------

æˆ‘ä»¬å¯¹æ¯”ä¸€ä¸‹å•ç‚¹æ›´æ–°çš„ `update` æ–¹æ³•å’ŒåŒºé—´æ›´æ–°çš„ `rangeUpdate` æ–¹æ³•ï¼Œå°±èƒ½ç›´è§‚åœ°æ„Ÿå—åˆ°æ‡’æ›´æ–°çš„åŸç†ï¼Œä»¥åŠä¸ºä»€ä¹ˆæ‡’æ›´æ–°å¯ä»¥è®©åŒºé—´æ›´æ–°çš„æ—¶é—´å¤æ‚åº¦ä¾ç„¶ä¿æŒåœ¨ O(logâ¡N)O(\\log N)O(logN)ã€‚

å¯¹äºåŒºé—´æ›´æ–°çš„åœºæ™¯ï¼Œå¦‚æœä½¿ç”¨ `update` æ–¹æ³•å•ç‚¹æ›´æ–°ï¼Œæˆ‘ä»¬åªèƒ½ç”¨ä¸€ä¸ª for å¾ªç¯å»æ›´æ–°åŒºé—´å†…çš„æ¯ä¸ªå…ƒç´ ã€‚

è¯·ä½ ç‚¹å¼€ä¸‹é¢çš„å¯è§†åŒ–é¢æ¿ï¼Œå¤šæ¬¡ç‚¹å‡» `sumTree.update` è¿™ä¸€è¡Œä»£ç ï¼Œå¯ä»¥çœ‹åˆ°æ¯æ¬¡ `update` éƒ½è¦ä»æ ¹èŠ‚ç‚¹éå†åˆ°å¶å­èŠ‚ç‚¹ï¼š

æ‰€ä»¥åŒºé—´æ›´æ–°çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(Mlogâ¡N)O(M \\log N)O(MlogN)ï¼ŒMMM æ˜¯åŒºé—´ä¸­çš„å…ƒç´ ä¸ªæ•°ï¼Œlogâ¡N\\log NlogN æ˜¯çº¿æ®µæ ‘çš„é«˜åº¦ï¼ŒNNN æ˜¯æ•°ç»„ä¸­çš„å…ƒç´ ä¸ªæ•°ã€‚

ä¼˜åŒ–æ€è·¯åŠéš¾ç‚¹

**æ‡’æ›´æ–°çš„æ€è·¯æ˜¯ï¼Œæ²¡å¿…è¦ä¸Šæ¥å°±å»æ›´æ–°åŒºé—´çš„æ‰€æœ‰å¶å­èŠ‚ç‚¹ï¼Œè€Œæ˜¯å…ˆæŠŠæ›´æ–°è®°å½•åˆ°éå¶å­èŠ‚ç‚¹ï¼ˆæ‡’æ ‡è®°ï¼‰ã€‚ç­‰åˆ°ä¹‹åçš„æ“ä½œç»è¿‡æ‡’æ ‡è®°èŠ‚ç‚¹æ—¶ï¼Œå†é¡ºæ‰‹æŠŠæ‡’æ ‡è®°é€æ¸æ›´æ–°åˆ°å¶å­èŠ‚ç‚¹ï¼ˆæ‡’æ ‡è®°ä¸‹æ¨ï¼‰**ã€‚

å®ƒçš„éš¾ç‚¹åœ¨äºï¼Œä½ è¦æ­£ç¡®å¤„ç†æ‡’æ ‡è®°ï¼Œä¿è¯åœ¨æ‡’æ ‡è®°å­˜åœ¨æ—¶ï¼Œçº¿æ®µæ ‘çš„æŸ¥è¯¢ã€æ›´æ–°æ“ä½œä¾ç„¶èƒ½è¿”å›æ­£ç¡®çš„ç»“æœã€‚

å¯è§†åŒ–é¢æ¿å¯¹æ‡’æ›´æ–°çº¿æ®µæ ‘æœ‰ç‰¹æ®Šçš„æ”¯æŒï¼Œå¸¦æœ‰ã€Œæ‡’æ ‡è®°ã€çš„çº¿æ®µæ ‘èŠ‚ç‚¹ä¼šæ˜¾ç¤ºä¸ºåŠé€æ˜ï¼Œè€Œä¸”èŠ‚ç‚¹ä¸Šçš„æ˜¾ç¤ºå€¼ä¼šæœ‰ä¸€ä¸ª `*` å‰ç¼€ï¼Œä½ æŠŠé¼ æ ‡ç§»åŠ¨åˆ°å¯¹åº”çš„èŠ‚ç‚¹ä¸Šï¼Œä¼šæ˜¾ç¤ºæ‡’æ ‡è®°çš„å€¼ã€‚ä¸‹é¢æ¥ç»“åˆå¯è§†åŒ–é¢æ¿çœ‹çœ‹ `rangeUpdate` æ–¹æ³•æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚

è¯·ä½ ç‚¹å¼€ä¸‹é¢çš„å¯è§†åŒ–é¢æ¿ï¼Œç‚¹å‡» `sumTree.rangeUpdate` è¿™ä¸€è¡Œä»£ç ï¼Œå¯ä»¥çœ‹åˆ°ä»£ç å¹¶æ²¡æœ‰çœŸçš„æ›´æ–°äº†å¶å­èŠ‚ç‚¹ï¼Œè€Œæ˜¯åªæ›´æ–°äº† `[0, 4]` èŠ‚ç‚¹çš„å…ƒç´ å’Œï¼Œå¹¶ä¸”æ‰“äº†ä¸€ä¸ª `lazyAssign = 2` çš„æ ‡è®°ã€‚

ç‚¹å‡» `console.log(sumTree.query(0, 4))` è¿™ä¸€è¡Œä»£ç ï¼Œå¯ä»¥çœ‹åˆ°ç›´æ¥å‘½ä¸­äº† `[0, 4]` èŠ‚ç‚¹ï¼Œè¿”å›å…ƒç´ å’Œ `10`ã€‚

å½“æŸ¥è¯¢ `[0, 4]` èŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ—¶ï¼Œä¼šå°†è¿™ä¸ªæ‡’æ ‡è®°å‘ä¸‹ä¼ é€’ã€‚è¯·ä½ ç‚¹å‡» `console.log(sumTree.query(0, 1))` è¿™ä¸€è¡Œä»£ç ï¼Œå¯ä»¥çœ‹åˆ°æŸ¥è¯¢åˆ°äº†æ­£ç¡®çš„å…ƒç´ å’Œï¼Œå¹¶å°†æ‡’æ ‡è®°ä¸‹æ¨åˆ°äº† `[0, 1]` èŠ‚ç‚¹å’Œ `[3, 4]` èŠ‚ç‚¹ã€‚


å°è¯•ä¿®æ”¹ `rangeUpdate` å’Œ `query` æ–¹æ³•çš„å‚æ•°ï¼Œçœ‹çœ‹æ‡’æ ‡è®°çš„ä¸‹æ¨è¿‡ç¨‹ã€‚

æ ¹æ®ä¸Šé¢çš„å¯è§†åŒ–å±•ç¤ºå¯ä»¥ç›´è§‚åœ°çœ‹å‡ºæ¥ï¼š

1ã€`rangeUpdate` æ–¹æ³•ä¸éœ€è¦éå†æ›´æ–°åŒºé—´çš„æ‰€æœ‰å¶å­èŠ‚ç‚¹ï¼Œéå†çš„èŠ‚ç‚¹æ€»æ•°æ˜¯æ ‘é«˜ O(logâ¡N)O(\\log N)O(logN) çš„å¸¸æ•°å€ï¼Œä¸åŒºé—´çš„é•¿åº¦æ— å…³ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦æ˜¯ O(logâ¡N)O(\\log N)O(logN)ã€‚

2ã€`query` æ–¹æ³•åœ¨æŸ¥è¯¢æ—¶ï¼Œè™½ç„¶ä¼šé¢å¤–åšä¸€äº›æ‡’æ ‡è®°ä¸‹æ¨çš„å·¥ä½œï¼Œä½†éå†çš„èŠ‚ç‚¹æ€»æ•°ä¾ç„¶æ˜¯æ ‘é«˜ O(logâ¡N)O(\\log N)O(logN) çš„å¸¸æ•°å€ï¼Œä¸åŒºé—´çš„é•¿åº¦æ— å…³ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦æ˜¯ O(logâ¡N)O(\\log N)O(logN)ã€‚

æœ‰äº†è¿™äº›ç›´è§‚çš„è®¤è¯†ï¼Œæˆ‘ä»¬å°±å¯ä»¥å¼€å§‹å®ç°æ‡’æ›´æ–°çº¿æ®µæ ‘äº†ã€‚

[å®ç°åŒºé—´èµ‹å€¼çº¿æ®µæ ‘](#)
--------------

åŸºäº [åŠ¨æ€çº¿æ®µæ ‘](https://labuladong.online/algo/data-structure/segment-tree-dynamic/) å®ç°çš„åŠ¨æ€çº¿æ®µæ ‘ï¼Œåªéœ€æ”¹åŠ¨å°‘é‡ä»£ç å³å¯å®ç°æ‡’æ›´æ–°çº¿æ®µæ ‘ã€‚

é¦–å…ˆæ˜¯ç»™ `SegmentNode` æ·»åŠ  `hasLazyAssign` å’Œ `lazyAssign` å­—æ®µï¼Œè®°å½•å½“å‰èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨æ‡’æ ‡è®°ï¼Œä»¥åŠæ‡’æ ‡è®°çš„å€¼ã€‚

ç„¶åæ˜¯å¤šäº†ä¸€ä¸ª `pushDown` æ–¹æ³•ç”¨æ¥ä¸‹æ¨æ‡’æ ‡è®°ï¼Œåœ¨è°ƒç”¨ `query` å’Œ `updateRange` æ–¹æ³•æ—¶è°ƒç”¨ä¸€æ¬¡å°±è¡Œäº†ã€‚

å…·ä½“çœ‹ä»£ç å§ï¼Œæ³¨é‡Šéå¸¸è¯¦ç»†äº†ã€‚

cpp ğŸ¤–

    #include <iostream>
    #include <stdexcept>
    
    using namespace std;
    
    // çº¿æ®µæ ‘èŠ‚ç‚¹ï¼Œç»´æŠ¤åŒºé—´ [l, r] çš„å…ƒç´ å’Œä»¥åŠæ‡’æ ‡è®°ä¿¡æ¯
    class SegmentNode {
    public:
        int l, r;
        int sum;
        SegmentNode* left;
        SegmentNode* right;
        
        // è¡¨ç¤ºå½“å‰èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨èµ‹å€¼æ‡’æ ‡è®°
        bool hasLazyAssign;
        // æ‡’æ›´æ–°ä¸­èµ‹å€¼çš„å€¼
        int lazyAssign;
    
        SegmentNode(int l, int r, int value)
            : l(l), r(r), sum(value), left(nullptr), right(nullptr), hasLazyAssign(false) {
        }
        
        ~SegmentNode() {
            delete left;
            delete right;
        }
    };
    
    class AssignSegmentTree {
    private:
        SegmentNode* root;
        int defaultValue;
    
        // å½“éœ€è¦è®¿é—®å­èŠ‚ç‚¹æ—¶ï¼Œå¦‚æœå­èŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œåˆ™åŠ¨æ€åˆ›å»º
        void initChildrenIfNeeded(SegmentNode* node) {
            if (node->l == node->r) {
                // å¶å­èŠ‚ç‚¹ï¼Œæ— éœ€åˆ’åˆ†
                return;
            }
            if (node->left == nullptr || node->right == nullptr) {
                int mid = node->l + (node->r - node->l) / 2;
                if (node->left == nullptr) {
                    node->left = new SegmentNode(node->l, mid, defaultValue);
                }
                if (node->right == nullptr) {
                    node->right = new SegmentNode(mid + 1, node->r, defaultValue);
                }
            }
        }
    
        // ä¸‹ä¼ æ‡’æ ‡è®°ï¼Œå°†å½“å‰èŠ‚ç‚¹çš„èµ‹å€¼æ‡’æ ‡è®°ä¼ é€’ç»™å·¦å³å­èŠ‚ç‚¹
        void pushDown(SegmentNode* node) {
            if (!node->hasLazyAssign) {
                return;
            }
            
            // æŠŠæ‡’æ ‡è®°ä¸‹æ¨åˆ°å·¦å­èŠ‚ç‚¹
            if (node->left) {
                node->left->lazyAssign = node->lazyAssign;
                node->left->hasLazyAssign = true;
                node->left->sum = (node->left->r - node->left->l + 1) * node->lazyAssign;
            }
            
            // æŠŠæ‡’æ ‡è®°ä¸‹æ¨åˆ°å³å­èŠ‚ç‚¹
            if (node->right) {
                node->right->lazyAssign = node->lazyAssign;
                node->right->hasLazyAssign = true;
                node->right->sum = (node->right->r - node->right->l + 1) * node->lazyAssign;
            }
            
            // æ¸…é™¤å½“å‰èŠ‚ç‚¹çš„æ‡’æ ‡è®°
            node->hasLazyAssign = false;
        }
    
        // å°†é—­åŒºé—´ [qL, qR] èµ‹å€¼ä¸º valï¼Œæ—¶é—´å¤æ‚åº¦ O(logN)
        void _rangeUpdate(SegmentNode* node, int qL, int qR, int val) {
            if (node->r < qL || node->l > qR) {
                throw invalid_argument("Invalid update range");
            }
            // å½“å‰èŠ‚ç‚¹åŒºé—´å®Œå…¨è¢«æ›´æ–°åŒºé—´è¦†ç›–ï¼Œåˆ™æ›´æ–°è¯¥èŠ‚ç‚¹å¹¶æ‰“ä¸Šæ‡’æ ‡è®°
            if (qL <= node->l && node->r <= qR) {
                node->sum = (node->r - node->l + 1) * val;
                node->lazyAssign = val;
                node->hasLazyAssign = true;
                return;
            }
            
            initChildrenIfNeeded(node);
            
            // éƒ¨åˆ†è¦†ç›–ï¼Œéœ€è¦å…ˆä¸‹ä¼ æ‡’æ ‡è®°ï¼Œå†é€’å½’æ›´æ–°å·¦å³å­èŠ‚ç‚¹
            pushDown(node);
            
            int mid = node->l + (node->r - node->l) / 2;
            if (qR <= mid) {
                // ç›®æ ‡åŒºé—´å®Œå…¨åœ¨å·¦å­æ ‘ä¸­
                _rangeUpdate(node->left, qL, qR, val);
            } else if (qL > mid) {
                // ç›®æ ‡åŒºé—´å®Œå…¨åœ¨å³å­æ ‘ä¸­
                _rangeUpdate(node->right, qL, qR, val);
            } else {
                // ç›®æ ‡åŒºé—´è·¨è¶Šå·¦å³å­æ ‘
                _rangeUpdate(node->left, qL, mid, val);
                _rangeUpdate(node->right, mid + 1, qR, val);
            }
            // æ›´æ–°å½“å‰èŠ‚ç‚¹çš„åŒºé—´å’Œ
            node->sum = node->left->sum + node->right->sum;
        }
    
        int _query(SegmentNode* node, int qL, int qR) {
            if (node->r < qL || node->l > qR) {
                throw invalid_argument("Invalid query range");
            }
            // å½“å‰èŠ‚ç‚¹åŒºé—´å®Œå…¨åŒ…å«äºæŸ¥è¯¢åŒºé—´ï¼Œç›´æ¥è¿”å›åŒºé—´å’Œ
            if (qL <= node->l && node->r <= qR) {
                return node->sum;
            }
            
            initChildrenIfNeeded(node);
            // ä¸‹ä¼ æ‡’æ ‡è®°ä»¥ç¡®ä¿å·¦å³å­èŠ‚ç‚¹çš„æ•°æ®æ­£ç¡®
            pushDown(node);
            
            int mid = node->l + (node->r - node->l) / 2;
            if (qR <= mid) {
                // ç›®æ ‡åŒºé—´å®Œå…¨åœ¨å·¦å­æ ‘ä¸­
                return _query(node->left, qL, qR);
            } else if (qL > mid) {
                // ç›®æ ‡åŒºé—´å®Œå…¨åœ¨å³å­æ ‘ä¸­
                return _query(node->right, qL, qR);
            } else {
                // ç›®æ ‡åŒºé—´è·¨è¶Šå·¦å³å­æ ‘
                // å°†æŸ¥è¯¢åŒºé—´æ‹†åˆ†æˆ [qL, mid] å’Œ [mid + 1, qR] ä¸¤éƒ¨åˆ†ï¼Œåˆ†åˆ«å‘å·¦å³å­æ ‘æŸ¥è¯¢
                // æœ€åå°†å·¦å³å­æ ‘çš„æŸ¥è¯¢ç»“æœåˆå¹¶
                return _query(node->left, qL, mid) + _query(node->right, mid + 1, qR);
            }
        }
    
    public:
        // æ„é€ æ–¹æ³•
        // start, end è¡¨ç¤ºçº¿æ®µæ ‘çš„åŒºé—´èŒƒå›´ï¼ŒdefaultValue è¡¨ç¤ºæ¯ä¸ªåŒºé—´åˆå§‹çš„é»˜è®¤å€¼
        AssignSegmentTree(int start, int end, int defaultValue)
            : defaultValue(defaultValue) {
            int initSum = (end - start + 1) * defaultValue;
            root = new SegmentNode(start, end, initSum);
        }
        
        ~AssignSegmentTree() {
            delete root;
        }
        
        // å•ç‚¹èµ‹å€¼ valï¼Œæ—¶é—´å¤æ‚åº¦ O(logN)
        void assign(int index, int val) {
            // ç›´æ¥å¤ç”¨åŒºé—´èµ‹å€¼æ–¹æ³•
            rangeUpdate(index, index, val);
        }
        
        // å°†é—­åŒºé—´ [qL, qR] èµ‹å€¼ä¸º valï¼Œæ—¶é—´å¤æ‚åº¦ O(logN)
        void rangeUpdate(int qL, int qR, int val) {
            _rangeUpdate(root, qL, qR, val);
        }
        
        // æŸ¥è¯¢é—­åŒºé—´ [qL, qR] çš„å…ƒç´ å’Œï¼Œæ—¶é—´å¤æ‚åº¦ O(logN)
        int query(int qL, int qR) {
            return _query(root, qL, qR);
        }
    };
    
    int main() {
        // æ„å»ºåŒºé—´ [0, 9] çš„èµ‹å€¼çº¿æ®µæ ‘ï¼Œåˆå§‹å€¼å‡ä¸º 0
        AssignSegmentTree tree(0, 9, 0);
        // [0,0,0,0,0,0,0,0,0,0]
        
        tree.rangeUpdate(2, 5, 7);
        // [0,0,7,7,7,7,7,0,0,0]
        
        // 7 * 4 = 28
        cout << "sum of [0,9]: " << tree.query(0, 9) << " expected: 28" << endl;
        
        tree.rangeUpdate(0, 3, 5);
        // [5,5,5,5,7,7,0,0,0,0]
        
        // 5 * 4 + 7 * 2 = 34
        cout << "sum of [0,5]: " << tree.query(0, 5) << " expected: 34" << endl;
        
        tree.rangeUpdate(5, 9, 2);
        // [5,5,5,5,7,2,2,2,2,2]
        
        // 5 * 4 + 7 * 2 + 2 * 5 = 37
        cout << "sum of [0,9]: " << tree.query(0, 9) << " expected: 37" << endl;
        
        // å•ç‚¹æŸ¥è¯¢ç´¢å¼• 5 çš„å€¼
        cout << "value of index 5: " << tree.query(5, 5) << " expected: 2" << endl;
        
        // 5 + 5 = 10
        cout << "sum of [1,2]: " << tree.query(1, 2) << " expected: 10" << endl;
        
        return 0;
    }


[å®ç°åŒºé—´ç´¯åŠ çº¿æ®µæ ‘](#)
--------------

åŒºé—´ç´¯åŠ çº¿æ®µæ ‘å’Œä¸Šé¢å®ç°çš„åŒºé—´èµ‹å€¼çº¿æ®µæ ‘æ˜¯ç±»ä¼¼çš„ï¼Œåªä¸è¿‡æ‡’æ ‡è®°çš„å€¼å˜æˆäº† `lazyAdd` è¡¨ç¤ºç´¯åŠ çš„å€¼ï¼Œç„¶åç¨å¾®ä¿®æ”¹ `pushDown` æ–¹æ³•çš„é€»è¾‘å³å¯ã€‚

å…·ä½“çœ‹ä»£ç å§ï¼Œæ³¨é‡Šéå¸¸è¯¦ç»†äº†ï¼š

cpp ğŸ¤–

    #include <iostream>
    #include <stdexcept>
    
    
    // çº¿æ®µæ ‘èŠ‚ç‚¹ï¼Œç»´æŠ¤åŒºé—´ [l, r] çš„å…ƒç´ å’Œä»¥åŠæ‡’æ ‡è®°ä¿¡æ¯ï¼ˆåŒºé—´ç´¯åŠ çº¿æ®µæ ‘ï¼‰
    class SegmentNode {
    public:
        int l, r;
        int sum;
        SegmentNode* left;
        SegmentNode* right;
    
        // æ‡’æ›´æ–°ä¸­ç´¯åŠ çš„å€¼ï¼Œåˆå§‹ä¸º 0 è¡¨ç¤ºæ— æ‡’æ›´æ–°
        int lazyAdd;
    
        SegmentNode(int l, int r, int value)
            : l(l), r(r), sum(value), left(nullptr), right(nullptr), lazyAdd(0) {}
    };
    
    class IncrSegmentTree {
    private:
        SegmentNode* root;
        int defaultValue;
    
        // å½“éœ€è¦è®¿é—®å­èŠ‚ç‚¹æ—¶ï¼Œå¦‚æœå­èŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œåˆ™åŠ¨æ€åˆ›å»º
        void initChildrenIfNeeded(SegmentNode* node) {
            if (node->l == node->r) {
                // å¶å­èŠ‚ç‚¹ï¼Œæ— éœ€åˆ’åˆ†
                return;
            }
            if (node->left == nullptr || node->right == nullptr) {
                int mid = node->l + (node->r - node->l) / 2;
                if (node->left == nullptr) {
                    node->left = new SegmentNode(node->l, mid, defaultValue);
                }
                if (node->right == nullptr) {
                    node->right = new SegmentNode(mid + 1, node->r, defaultValue);
                }
            }
        }
    
        // ä¸‹ä¼ æ‡’æ ‡è®°ï¼Œå°†å½“å‰èŠ‚ç‚¹çš„ç´¯åŠ æ‡’æ ‡è®°ä¼ é€’ç»™å·¦å³å­èŠ‚ç‚¹
        void pushDown(SegmentNode* node) {
            if (node->lazyAdd != 0) {
                initChildrenIfNeeded(node);
                // å°†æ‡’æ ‡è®°ä¸‹ä¼ ç»™å·¦å­èŠ‚ç‚¹
                node->left->lazyAdd += node->lazyAdd;
                node->left->sum += (node->left->r - node->left->l + 1) * node->lazyAdd;
                // å°†æ‡’æ ‡è®°ä¸‹ä¼ ç»™å³å­èŠ‚ç‚¹
                node->right->lazyAdd += node->lazyAdd;
                node->right->sum += (node->right->r - node->right->l + 1) * node->lazyAdd;
                // æ¸…é™¤å½“å‰èŠ‚ç‚¹çš„æ‡’æ ‡è®°
                node->lazyAdd = 0;
            }
        }
    
        // åŒºé—´ç´¯åŠ è¾…åŠ©æ–¹æ³•
        void _rangeAdd(SegmentNode* node, int qL, int qR, int delta) {
            if (node->r < qL || node->l > qR) {
                throw std::invalid_argument("Invalid update range");
            }
            // å½“å‰èŠ‚ç‚¹åŒºé—´å®Œå…¨è¢«æ›´æ–°åŒºé—´è¦†ç›–ï¼Œåˆ™æ›´æ–°è¯¥èŠ‚ç‚¹å¹¶æ‰“ä¸Šæ‡’æ ‡è®°
            if (qL <= node->l && node->r <= qR) {
                node->sum += (node->r - node->l + 1) * delta;
                node->lazyAdd += delta;
                return;
            }
    
            initChildrenIfNeeded(node);
            // éƒ¨åˆ†è¦†ç›–ï¼Œéœ€è¦å…ˆä¸‹ä¼ æ‡’æ ‡è®°ï¼Œå†é€’å½’æ›´æ–°å·¦å³å­èŠ‚ç‚¹
            pushDown(node);
    
            int mid = node->l + (node->r - node->l) / 2;
            if (qR <= mid) {
                // node->l <= qL <= qR <= mid
                // ç›®æ ‡åŒºé—´å®Œå…¨åœ¨å·¦å­æ ‘ä¸­
                _rangeAdd(node->left, qL, qR, delta);
            } else if (qL > mid) {
                // node->l <= mid < qL <= qR <= node->r
                // ç›®æ ‡åŒºé—´å®Œå…¨åœ¨å³å­æ ‘ä¸­
                _rangeAdd(node->right, qL, qR, delta);
            } else {
                // node->l <= qL <= mid < qR <= node->r
                // ç›®æ ‡åŒºé—´è·¨è¶Šå·¦å³å­æ ‘ï¼Œåˆ†åˆ«æ›´æ–°
                _rangeAdd(node->left, qL, mid, delta);
                _rangeAdd(node->right, mid + 1, qR, delta);
            }
            // æ›´æ–°å½“å‰èŠ‚ç‚¹çš„åŒºé—´å’Œ
            node->sum = node->left->sum + node->right->sum;
        }
    
        // æŸ¥è¯¢åŒºé—´è¾…åŠ©æ–¹æ³•
        int _query(SegmentNode* node, int qL, int qR) {
            if (node->r < qL || node->l > qR) {
                throw std::invalid_argument("Invalid query range");
            }
            // å½“å‰èŠ‚ç‚¹åŒºé—´å®Œå…¨åŒ…å«äºæŸ¥è¯¢åŒºé—´ï¼Œç›´æ¥è¿”å›åŒºé—´å’Œ
            if (qL <= node->l && node->r <= qR) {
                return node->sum;
            }
    
            initChildrenIfNeeded(node);
            // ä¸‹ä¼ æ‡’æ ‡è®°ä»¥ç¡®ä¿å·¦å³å­èŠ‚ç‚¹çš„æ•°æ®æ­£ç¡®
            pushDown(node);
    
            int mid = node->l + (node->r - node->l) / 2;
            if (qR <= mid) {
                // node->l <= qL <= qR <= mid
                // ç›®æ ‡åŒºé—´å®Œå…¨åœ¨å·¦å­æ ‘ä¸­
                return _query(node->left, qL, qR);
            } else if (qL > mid) {
                // node->l <= mid < qL <= qR <= node->r
                // ç›®æ ‡åŒºé—´å®Œå…¨åœ¨å³å­æ ‘ä¸­
                return _query(node->right, qL, qR);
            } else {
                // node->l <= qL <= mid < qR <= node->r
                // ç›®æ ‡åŒºé—´è·¨è¶Šå·¦å³å­æ ‘
                return _query(node->left, qL, mid) + _query(node->right, mid + 1, qR);
            }
        }
    
        // é‡Šæ”¾èŠ‚ç‚¹å†…å­˜çš„é€’å½’å‡½æ•°
        void freeNode(SegmentNode* node) {
            if (node == nullptr) return;
            freeNode(node->left);
            freeNode(node->right);
            delete node;
        }
    
    public:
        // æ„é€ æ–¹æ³•
        // start, end è¡¨ç¤ºçº¿æ®µæ ‘çš„åŒºé—´èŒƒå›´ï¼ŒdefaultValue è¡¨ç¤ºæ¯ä¸ªåŒºé—´åˆå§‹çš„é»˜è®¤å€¼
        IncrSegmentTree(int start, int end, int defaultValue)
            : defaultValue(defaultValue) {
            int initSum = (end - start + 1) * defaultValue;
            root = new SegmentNode(start, end, initSum);
        }
    
        ~IncrSegmentTree() {
            freeNode(root);
        }
    
        // å•ç‚¹ç´¯åŠ  deltaï¼ˆå¯ä»¥ä¸ºè´Ÿæ•°ï¼‰ï¼Œæ—¶é—´å¤æ‚åº¦ O(logN)
        void add(int index, int delta) {
            // ç›´æ¥å¤ç”¨åŒºé—´ç´¯åŠ æ–¹æ³•
            rangeAdd(index, index, delta);
        }
    
        // å°†é—­åŒºé—´ [qL, qR] å¢åŠ  deltaï¼ˆå¯ä»¥ä¸ºè´Ÿæ•°ï¼‰ï¼Œæ—¶é—´å¤æ‚åº¦ O(logN)
        void rangeAdd(int qL, int qR, int delta) {
            _rangeAdd(root, qL, qR, delta);
        }
    
        // æŸ¥è¯¢é—­åŒºé—´ [qL, qR] çš„å…ƒç´ å’Œï¼Œæ—¶é—´å¤æ‚åº¦ O(logN)
        int query(int qL, int qR) {
            return _query(root, qL, qR);
        }
    };
    
    int main() {
        // æ„å»ºåŒºé—´ [0, 9] çš„ç´¯åŠ çº¿æ®µæ ‘ï¼Œåˆå§‹å€¼å‡ä¸º 0
        IncrSegmentTree tree(0, 9, 0);
        // [0,0,0,0,0,0,0,0,0,0]
    
        tree.rangeAdd(2, 5, 7);
        // [0,0,7,7,7,7,0,0,0,0]
        // 7 * 4 = 28
        std::cout << "sum of [0,9]: " << tree.query(0, 9) << " expected: 28" << std::endl;
    
        tree.rangeAdd(0, 3, 5);
        // [5,5,12,12,7,7,0,0,0,0]
        // 5 + 5 + 12 + 12 + 7 + 7 = 48
        std::cout << "sum of [0,5]: " << tree.query(0, 5) << " expected: 48" << std::endl;
    
        tree.rangeAdd(5, 9, 2);
        // [5,5,12,12,7,9,2,2,2,2]
        // 5 + 5 + 12 + 12 + 7 + 9 + 2 + 2 + 2 + 2 = 58
        std::cout << "sum of [0,9]: " << tree.query(0, 9) << " expected: 58" << std::endl;
    
        // å•ç‚¹æŸ¥è¯¢ç´¢å¼• 5 çš„å€¼
        std::cout << "value of index 5: " << tree.query(5, 5) << " expected: 9" << std::endl;
    
        // [5,5,12,12,7,9,2,2,2,2]
        // 5 + 12 = 17
        std::cout << "sum of [1,2]: " << tree.query(1, 2) << " expected: 17" << std::endl;
    
        return 0;
    }

    // ç¤ºä¾‹ç”¨æ³•
    // æ„å»ºåŒºé—´ [0, 9] çš„ç´¯åŠ çº¿æ®µæ ‘ï¼Œåˆå§‹å€¼å‡ä¸º 0
    const tree = new IncrSegmentTree(0, 9, 0);
    // [0,0,0,0,0,0,0,0,0,0]
    
    tree.rangeAdd(2, 5, 7);
    // [0,0,7,7,7,7,0,0,0,0]
    // 7 * 4 = 28
    console.log("sum of [0,9]: " + tree.query(0, 9) + " expected: 28");
    
    tree.rangeAdd(0, 3, 5);
    // [5,5,12,12,7,7,0,0,0,0]
    // 5 + 5 + 12 + 12 + 7 + 7 = 48
    console.log("sum of [0,5]: " + tree.query(0, 5) + " expected: 48");
    
    tree.rangeAdd(5, 9, 2);
    // [5,5,12,12,7,9,2,2,2,2]
    // 5 + 5 + 12 + 12 + 7 + 9 + 2 + 2 + 2 + 2 = 58
    console.log("sum of [0,9]: " + tree.query(0, 9) + " expected: 58");
    
    // å•ç‚¹æŸ¥è¯¢ç´¢å¼• 5 çš„å€¼
    console.log("value of index 5: " + tree.query(5, 5) + " expected: 9");
    
    // [5,5,12,12,7,9,2,2,2,2]
    // 5 + 12 = 17
    console.log("sum of [1,2]: " + tree.query(1, 2) + " expected: 17");

[ä¸‡èƒ½çº¿æ®µæ ‘æ¨¡æ¿](#)
------------

ä¸Šé¢çš„ä»£ç ä¸ºäº†æ–¹ä¾¿å¤§å®¶ç†è§£ï¼ŒæŠŠ `updateRange` å’Œ `addRange` åˆ†åˆ«æ”¾åˆ°äº† `AssignSegmentTree` å’Œ `IncrSegmentTree` ä¸¤ä¸ªç±»ä¸­å®ç°ã€‚

è€Œä¸”ä¸Šé¢å®ç°çš„ `AssignSegmentTree` å’Œ `IncrSegmentTree` éƒ½æ˜¯ç”¨äºåŒºé—´æ±‚å’Œåœºæ™¯çš„ï¼Œç®—æ³•é¢˜ä¸­ä¸€èˆ¬ä¼šå‡ºç°æ±‚å’Œã€æ±‚æœ€å¤§å€¼ã€æ±‚æœ€å°å€¼è¿™ä¸‰ç§åœºæ™¯ã€‚

ä¸‹é¢å®ç°ä¸€ä¸ªä¸‡èƒ½çš„çº¿æ®µæ ‘ç±» `AllInOneSegmentTree`ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

1ã€åŒæ—¶å®ç° `updateRange` å’Œ `addRange` æ–¹æ³•ï¼Œæ”¯æŒåŒºé—´èµ‹å€¼å’ŒåŒºé—´ç´¯åŠ çš„æ··åˆè°ƒç”¨ã€‚

2ã€åœ¨åˆ›å»ºçº¿æ®µæ ‘æ—¶ï¼Œå¯ä»¥æŒ‡å®šçº¿æ®µæ ‘æ¥è®¡ç®—åŒºé—´å’Œã€åŒºé—´æœ€å¤§å€¼æˆ–åŒºé—´æœ€å°å€¼ã€‚

æŠŠè¿™äº›åŠŸèƒ½éƒ½æ··åˆåœ¨ä¸€èµ·ï¼Œä»£ç ä¼šæ˜¾å¾—å¤æ‚è‡ƒè‚¿ï¼Œä½†å¥½å¤„æ˜¯å¼€ç®±å³ç”¨ã€‚**æ‰€ä»¥è¿™ä¸ªä¸‡èƒ½å®ç°ä¸å¤ªé€‚åˆç”¨æ¥å­¦ä¹ ç†è§£ï¼Œä»…é€‚åˆå­˜ä¸ºæ¨¡æ¿ï¼Œåœ¨å®æˆ˜ä¸­ç›´æ¥ä½¿ç”¨**ã€‚


cpp ğŸ¤–

    class AllInOneSegmentTree {
        struct SegmentNode {
            int l, r;
            int mergeValue;
            SegmentNode* left;
            SegmentNode* right;
    
            // ç´¯åŠ æ‡’æ ‡è®°, ä¸º 0 è¡¨ç¤ºæ— æ‡’æ›´æ–°
            int lazyAdd;
    
            // èµ‹å€¼æ‡’æ ‡è®°
            int lazyAssign;
            bool hasLazyAssign;
    
            SegmentNode(int l, int r, int mergeValue) : l(l), r(r), mergeValue(mergeValue), left(nullptr), right(nullptr), lazyAdd(0), lazyAssign(0), hasLazyAssign(false) {}
        };
    
    private:
        SegmentNode* root;
        int defaultValue;
        string type;
    
    public:
        AllInOneSegmentTree(int start, int end, int defaultValue, string type) {
            if (type == "sum" || type == "max" || type == "min") {
                this->type = type;
            } else {
                throw invalid_argument("Invalid type, must be sum, max, or min");
            }
            this->defaultValue = defaultValue;
            int rootMergeValue = computeRangeValue(start, end, defaultValue);
            this->root = new SegmentNode(start, end, rootMergeValue);
        }
    
        // è®¡ç®—åŒºé—´ [l, r] èµ‹å€¼ä¸º val åçš„ mergeValue
        int computeRangeValue(int l, int r, int val) {
            if (type == "sum") {
                return (r - l + 1) * val;
            } else {
                return val;
            }
        }
    
        // æ ¹æ®åŒºé—´é•¿åº¦æ›´æ–° mergeValueï¼ŒåŠ ä¸Š delta
        int applyAddToValue(SegmentNode* node, int delta) {
            if (type == "sum") {
                return node->mergeValue + (node->r - node->l + 1) * delta;
            } else {
                return node->mergeValue + delta;
            }
        }
    
        // æ ¹æ®ç±»å‹åˆå¹¶å·¦å³å­èŠ‚ç‚¹çš„å€¼
        int merge(int leftVal, int rightVal) {
            if (type == "sum") {
                return leftVal + rightVal;
            } else if (type == "max") {
                return max(leftVal, rightVal);
            } else if (type == "min") {
                return min(leftVal, rightVal);
            }
            throw invalid_argument("Invalid type");
        }
    
        // åŠ¨æ€åˆ›å»ºçº¿æ®µæ ‘èŠ‚ç‚¹
        void initChildrenIfNeeded(SegmentNode* node) {
            if (node->l == node->r) {
                return;
            }
            int mid = node->l + (node->r - node->l) / 2;
            if (node->left == nullptr) {
                int leftMergeValue = computeRangeValue(node->l, mid, defaultValue);
                node->left = new SegmentNode(node->l, mid, leftMergeValue);
            }
            if (node->right == nullptr) {
                int rightMergeValue = computeRangeValue(mid + 1, node->r, defaultValue);
                node->right = new SegmentNode(mid + 1, node->r, rightMergeValue);
            }
        }
    
        // ä¸‹ä¼ æ‡’æ ‡è®°ï¼Œä¿è¯å­èŠ‚ç‚¹çš„æ•°æ®æ­£ç¡®
        void pushDown(SegmentNode* node) {
            if (node->hasLazyAssign) {
                applyAssign(node->left, node->lazyAssign);
                applyAssign(node->right, node->lazyAssign);
                node->hasLazyAssign = false;
                node->lazyAssign = 0;
            }
            if (node->lazyAdd != 0) {
                applyAdd(node->left, node->lazyAdd);
                applyAdd(node->right, node->lazyAdd);
                node->lazyAdd = 0;
            }
        }
    
        // å°†èµ‹å€¼æ‡’æ ‡è®°ä¸‹ä¼ åˆ°å­èŠ‚ç‚¹
        void applyAssign(SegmentNode* child, int val) {
            child->hasLazyAssign = true;
            child->lazyAssign = val;
            child->lazyAdd = 0;
            child->mergeValue = computeRangeValue(child->l, child->r, val);
        }
    
        // å°†ç´¯åŠ æ‡’æ ‡è®°ä¸‹ä¼ åˆ°å­èŠ‚ç‚¹
        void applyAdd(SegmentNode* child, int delta) {
            if (child->hasLazyAssign) {
                child->lazyAssign += delta;
                child->mergeValue = computeRangeValue(child->l, child->r, child->lazyAssign);
            } else {
                child->lazyAdd += delta;
                child->mergeValue = applyAddToValue(child, delta);
            }
        }
    
        // å•ç‚¹èµ‹å€¼ï¼šå°†ç´¢å¼• index èµ‹å€¼ä¸º val
        void update(int index, int val) {
            rangeUpdate(index, index, val);
        }
    
        // åŒºé—´èµ‹å€¼ï¼šå°†é—­åŒºé—´ [qL, qR] èµ‹å€¼ä¸º val
        void rangeUpdate(int qL, int qR, int val) {
            _rangeUpdate(root, qL, qR, val);
        }
    
        void _rangeUpdate(SegmentNode* node, int qL, int qR, int val) {
            if (node->r < qL || node->l > qR) {
                throw invalid_argument("Invalid update range");
            }
            if (qL <= node->l && node->r <= qR) {
                node->hasLazyAssign = true;
                node->lazyAssign = val;
                node->lazyAdd = 0;
                node->mergeValue = computeRangeValue(node->l, node->r, val);
                return;
            }
    
            initChildrenIfNeeded(node);
            pushDown(node);
    
            int mid = node->l + (node->r - node->l) / 2;
            if (qR <= mid) {
                _rangeUpdate(node->left, qL, qR, val);
            } else if (qL > mid) {
                _rangeUpdate(node->right, qL, qR, val);
            } else {
                _rangeUpdate(node->left, qL, mid, val);
                _rangeUpdate(node->right, mid + 1, qR, val);
            }
            node->mergeValue = merge(node->left->mergeValue, node->right->mergeValue);
        }
    
        // å•ç‚¹ç´¯åŠ ï¼šå°†ç´¢å¼• index å¢åŠ  deltaï¼ˆå¯ä¸ºè´Ÿæ•°ï¼‰
        void add(int index, int delta) {
            rangeAdd(index, index, delta);
        }
    
        // åŒºé—´ç´¯åŠ ï¼šå°†é—­åŒºé—´ [qL, qR] å¢åŠ  deltaï¼ˆå¯ä¸ºè´Ÿæ•°ï¼‰
        void rangeAdd(int qL, int qR, int delta) {
            _rangeAdd(root, qL, qR, delta);
        }
    
        void _rangeAdd(SegmentNode* node, int qL, int qR, int delta) {
            if (node->r < qL || node->l > qR) {
                throw invalid_argument("Invalid update range");
            }
            if (qL <= node->l && node->r <= qR) {
                if (node->hasLazyAssign) {
                    node->lazyAssign += delta;
                    node->mergeValue = computeRangeValue(node->l, node->r, node->lazyAssign);
                } else {
                    node->lazyAdd += delta;
                    node->mergeValue = applyAddToValue(node, delta);
                }
                return;
            }
            initChildrenIfNeeded(node);
            pushDown(node);
    
            int mid = node->l + (node->r - node->l) / 2;
            if (qL <= mid) {
                _rangeAdd(node->left, qL, qR, delta);
            }
            if (qR > mid) {
                _rangeAdd(node->right, qL, qR, delta);
            }
            node->mergeValue = merge(node->left->mergeValue, node->right->mergeValue);
        }
    
        // æŸ¥è¯¢é—­åŒºé—´ [qL, qR] çš„èšåˆå€¼
        int query(int qL, int qR) {
            return _query(root, qL, qR);
        }
    
        int _query(SegmentNode* node, int qL, int qR) {
            if (node->r < qL || node->l > qR) {
                throw invalid_argument("Invalid query range");
            }
            if (qL <= node->l && node->r <= qR) {
                return node->mergeValue;
            }
    
            initChildrenIfNeeded(node);
            pushDown(node);
    
            int mid = node->l + (node->r - node->l) / 2;
            if (qR <= mid) {
                return _query(node->left, qL, qR);
            } else if (qL > mid) {
                return _query(node->right, qL, qR);
            } else {
                int leftResult = _query(node->left, qL, mid);
                int rightResult = _query(node->right, mid + 1, qR);
                return merge(leftResult, rightResult);
            }
        }
    };
