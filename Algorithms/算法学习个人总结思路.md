
# 灵府山

分享｜如何科学刷题？

![](https://pic.leetcode.cn/1720231746-FwkEem-%E5%BF%83%E6%B5%81.jpg)

> 合理运用心流通道，科学刷题，快乐刷题！

前言
--

怎么刷算法题？按照什么顺序刷题？如何科学地刷题训练？

如果你刚开始刷题，还不熟悉**基本编程语法**和**常用库函数**，推荐先刷力扣官方的**入门题单**：

*   [「新」动计划 · 编程入门](https://leetcode.cn/studyplan/primers-list/)（有两道数据库的题，可以直接跳过）

有了一些简单题的积累，就可以开始刷我的题单啦~

训练方法 A
------

#### 刷题要点

*   **按照专题刷题**，而不是随机刷题。同一个专题下的题目，套路是一样的，刷题效率杠杠滴~
*   **螺旋上升式学习**：先完成 1700 难度分以下的题目。把各个知识点的基础题刷一遍，再刷更难的题目。

#### 核心刷题路线

![](https://pic.leetcode.cn/1741315303-gDhXSh-%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E5%88%B7%E9%A2%98-3.png)

**完成上述核心内容后，可以自由地刷其他知识点**。例如字典树、并查集等。

请结合 [基础算法精讲](https://leetcode.cn/link/?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1bP411c7oJ%2F) 学习。

安装 [这个插件](https://leetcode.cn/link/?target=https%3A%2F%2Fscriptcat.org%2Fzh-CN%2Fscript-show-page%2F2778)，可以在题单中自动标记做过的题目。

#### 完整题单

1.  [滑动窗口与双指针（定长/不定长/单序列/双序列/三指针/分组循环）](https://leetcode.cn/circle/discuss/0viNMK/)
2.  [二分算法（二分答案/最小化最大值/最大化最小值/第K小）](https://leetcode.cn/circle/discuss/SqopEo/)
3.  [单调栈（基础/矩形面积/贡献法/最小字典序）](https://leetcode.cn/circle/discuss/9oZFK9/)
4.  [网格图（DFS/BFS/综合应用）](https://leetcode.cn/circle/discuss/YiXPXW/)
5.  [位运算（基础/性质/拆位/试填/恒等式/思维）](https://leetcode.cn/circle/discuss/dHn9Vk/)
6.  [图论算法（DFS/BFS/拓扑排序/最短路/最小生成树/二分图/基环树/欧拉路径）](https://leetcode.cn/circle/discuss/01LUak/)
7.  [动态规划（入门/背包/状态机/划分/区间/状压/数位/数据结构优化/树形/博弈/概率期望）](https://leetcode.cn/circle/discuss/tXLS3i/)
8.  [常用数据结构（前缀和/差分/栈/队列/堆/字典树/并查集/树状数组/线段树）](https://leetcode.cn/circle/discuss/mOr1u6/)
9.  [数学算法（数论/组合/概率期望/博弈/计算几何/随机算法）](https://leetcode.cn/circle/discuss/IYT3ss/)
10.  [贪心与思维（基本贪心策略/反悔/区间/字典序/数学/思维/脑筋急转弯/构造）](https://leetcode.cn/circle/discuss/g6KTKL/)
11.  [链表、二叉树与回溯（前后指针/快慢指针/DFS/BFS/直径/LCA/一般树）](https://leetcode.cn/circle/discuss/K0n2gO/)
12.  [字符串（KMP/Z函数/Manacher/字符串哈希/AC自动机/后缀数组/子序列自动机）](https://leetcode.cn/circle/discuss/SJFwQI/)

> 对于**动态规划**，至少要做 100 道才算入门。

#### 优缺点总结

**优点**：突击训练特定知识点，可以掌握常用算法套路。按照题单专题刷，一个套路可以解决多个题目，刷题效率高。此外，**做同一个专题下的题目，相当于在从不同的角度去观察、思考同一个算法，这能让你更加深刻地理解算法的本质**。

**缺点**：提前知道题目类型，跳过了一些思考步骤。但比赛/笔试是不会告诉你这题是什么类型的，把 DP 想成贪心的大有人在。可以结合下面的训练方法 B，锻炼自己判断题目类型的能力。

训练方法 B
------

和训练方法 A 互补，随机刷题。

1.  打开 [难度练习](https://leetcode.cn/link/?target=https%3A%2F%2Fhuxulm.github.io%2Flc-rating%2Fzen)。
2.  在设置中关闭算法标签。
3.  选择适合自己的难度范围。

#### 优缺点总结

**优点**：做题时不知道题目类型，可以增强实战能力；查漏补缺，检验自己的学习成果。

**缺点**：知识点有些零散，不如题单那么系统。

训练方法 C
------

![](https://pic.leetcode.cn/1740366413-ciMsTC-%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E5%88%B7%E9%A2%98-2.png)

如果时间很少，可以突击训练 [HOT 100](https://leetcode.cn/studyplan/top-100-liked/)，这些都是经典面试题。

另外还有一个 [面试 150](https://leetcode.cn/studyplan/top-interview-150/) 题单，其实它和 HOT 100 有很多重复题目，如果刷完 HOT 100 还有时间的话，可以刷这个 150 题单。

答疑
--

**问**：做题经常要看题解，怎么办？

**答**：看题解不丢人。甚至我觉得如果看题解的次数太少，说明做的题目太简单了，应该增加难度。

**问**：做题没思路，思考多久可以看题解？

**答**：10 分钟到数小时都可以。如果看完题解觉得题解很妙，那就学到了一个自己不会的技巧。如果看完题解觉得自己是xx，可以再多思考下，或者换个时间段（早/中/晚/洗澡的时候）思考，说不定就有思路了。（注：这在心理学上叫做**孵化效应**，即在离开问题后，大脑会在无意识中处理问题，从而在重返问题时突然产生新的思路。）

**问**：很多题目没有思路，很焦虑怎么办？

**答**：学算法是需要时间沉淀的，坚持刷题吧。现在不会的算法/题目，过段时间再来看，会有新的感悟。加油！

**问**：如何根据数据范围，估计题目允许的时间复杂度，从而估计要用什么算法？

**答**：一般每秒能执行约 10^8 次运算（Python 可能要除以 10），可以据此估计能通过的时间复杂度，如下表所示。
| 数据范围       | 允许的时间复杂度 | 适用算法举例       |
|----------------|------------------|--------------------|
| n≤10           | O(n!) 或 O(C(n)) | 回溯、暴力搜索     |
| n≤20           | O(2^n)           | 状态压缩 DP        |
| n≤10^2         | O(n^3)           | 三重循环的 DP、Floyd |
| n≤10^3         | O(n^2)           | 二重循环的 DP、背包 |
| n≤10^5         | O(nlogn)         | 大多数题目都是这个范围，所以各类算法都有 |
| n≤10^6         | O(n)             | 线性 DP、滑动窗口   |
| n≤10^9         | O(√n)            | 判断质数           |
| n≤10^18        | O(logn) 或 O(1)  | 二分、快速幂、数学公式 |

*   **n≤10**：对于阶乘级别的复杂度 O(n!) 和组合数级别的复杂度 O(C(n))，当 n=10 时，10! 约为 3.6×10^6，C(10) 也处于这个量级。计算机在 1 秒内可以完成 10^8 次运算，足以应对这种规模的运算，因此允许的时间复杂度可以是 O(n!) 或 O(C(n))，适用算法如回溯、暴力搜索。
    
*   **n≤20**：当 n=20 时，2^20 约为 10^6，计算机每秒可以执行 10^8 次运算，所以在 1 秒内可以完成 2^20 次运算，允许的时间复杂度为 O(2^n)，适用算法如状态压缩 DP。
    
*   **n≤10²**：10^2 的三次方是 10^6，计算机每秒可以执行 10^8 次运算，足以应对 10^6 次运算，因此允许的时间复杂度为 O(n³)，适用算法如三重循环的 DP、Floyd。
    
*   **n≤10³**：10^3 的平方是 10^6，计算机每秒可以执行 10^8 次运算，所以允许的时间复杂度为 O(n²)，适用算法如二重循环的 DP、背包。
    
*   **n≤10⁵**：10^5 乘以 log2​10^5 约为 10^6，计算机每秒可以执行 10^8 次运算，所以允许的时间复杂度为 O(nlogn)，大多数题目都在这个范围，各类算法都有。
    
*   **n≤10⁶**：10^6 次运算，计算机每秒可以执行 10^8 次运算，所以允许的时间复杂度为 O(n)，适用算法如线性 DP、滑动窗口。
    
*   **n≤10⁹**：10^9​ 约为 3×10^4，计算机每秒可以执行 10^8 次运算，所以允许的时间复杂度为 O(√n)，适用算法如判断质数。
    
*   **n≤10¹⁸**：log2 ​10^18 约为 60，计算机每秒可以执行 10^8 次运算，所以允许的时间复杂度为 O(logn) 或 O(1)，适用算法如二分、快速幂、数学公式。

**注**：实际做题时，注意常数因子的影响。例如哈希表比数组要慢。

* * 

# labuladong

[速成目录的原理](#)
------------

为什么速成目录能够在短时间内快速提升算法能力？

1、基于模板框架，统一的解法风格。

这个速成目录不是简单的题目列表，而是针对每个算法总结出一套框架模板，习题都使用统一的流程框架进行求解。你学会的是真正的算法解题能力而不是死记硬背，所以你不会局限于具体的题目列表，而是能够收发自如，独立解决没见过的题目。

2、循序渐进，由浅入深，同时包含数据结构和算法。

一个算法技巧 A，可能是算法 B 和算法 C 融合而来的，不给你任何背景铺垫直接讲 A，你就觉得算法高深莫测不可捉摸。但如果把 B 和 C 的基础补齐，你自己都能推导出 A，简直太简单了，有什么了不起的么。

比方很多读者畏惧递归算法，我就多次强调，算法的本质是穷举，递归是基于树结构的一种经典穷举手段，你只要把二叉树结构玩明白，就能玩明白一切递归算法。所以本目录会先从关键数据结构入手，然后再开始刷题。先把基础补齐，刷题就会顺畅高效。

3、科学的学习方法，丰富的辅助工具。例题和习题配合，先讲后练，结合刷题插件、可视化面板，尽一切努力帮助读者降低理解成本，提高学习效率。

**再次强调，我非常理解有些读者时间紧迫，但是你不要图省事，不学框架就直接刷题**。

只刷题单的问题在于过度依赖运气。运气好遇到原题的话，也许你能默写出解法；一旦没有运气加持，就得靠算法框架解题，你没学过就凉凉了。所谓基础不牢地动山摇，一开始先花时间把基础夯实，算总账反而是最省时间的。

下面就开始吧，速成目录主要分「数据结构」部分和「算法刷题」部分：数据结构部分基本不涉及算法题，相对较简单；刷题部分是重点，一定要认真思考，亲自动手实践。

## 数据结构
---------

### [数组链表](#)

介绍基本的数组链表概念，比较简单。主要是环形数组这个技巧是重点，可以用 O(1)的时间复杂度在数组头部进行插入删除操作。

关键基础，建议用时 1 天

*   [数组（顺序存储）基本原理](https://labuladong.online/algo/data-structure-basic/array-basic/)
*   [链表（链式存储）基本原理](https://labuladong.online/algo/data-structure-basic/linkedlist-basic/)
*   [环形数组技巧](https://labuladong.online/algo/data-structure-basic/cycle-array/)

### [哈希表原理及应用](#)

作为速成教程，我们可以跳过哈希表的两种解决哈希冲突的代码实现，但是哈希表的原理是必须掌握的。

哈希表可以和数组、双链表进行结合，形成更强大的数据结构 `LinkedHashMap` 和 `ArrayHashMap`，它们可以给哈希表增加新的特性，需要了解其中的原理。

关键基础，建议用时 1~2 天

*   [哈希表核心原理](https://labuladong.online/algo/data-structure-basic/hashmap-basic/)
*   [用链表加强哈希表（LinkedHashMap）](https://labuladong.online/algo/data-structure-basic/hashtable-with-linked-list/)
*   [用数组加强哈希表（ArrayHashMap）](https://labuladong.online/algo/data-structure-basic/hashtable-with-array/)

### [二叉树基础及遍历](#)

虽然现在只是基础知识章节，但是二叉树部分必须重视起来，**尤其是二叉树的遍历**，是入门递归思维关键。后面开始刷题后，所有递归算法的本质上都是二叉树的遍历。

关键基础，建议用时 1~2 天

*   [二叉树基础及常见类型](https://labuladong.online/algo/data-structure-basic/binary-tree-basic/)
*   [二叉树的递归/层序遍历](https://labuladong.online/algo/data-structure-basic/binary-tree-traverse-basic/)
*   [多叉树的递归/层序遍历](https://labuladong.online/algo/data-structure-basic/n-ary-tree-traverse-basic/)
*   

关键基础，建议用时 0.5 天

二叉搜索树是一种特殊的二叉树，这里只需要大致了解它的应用场景，后面会有习题带你掌握它的解题技巧。

*   [二叉搜索树的应用及可视化](https://labuladong.online/algo/data-structure-basic/tree-map-basic/)

#### [层序遍历的三种写法模板](#)


第一种，最简单的写法：


cpp 🤖

    void levelOrderTraverse(TreeNode* root) {
        if (root == nullptr) {
            return;
        }
        std::queue<TreeNode*> q;
        q.push(root);
        while (!q.empty()) {
            TreeNode* cur = q.front();
            q.pop();
            // 访问 cur 节点
            std::cout << cur->val << std::endl;
            
            // 把 cur 的左右子节点加入队列
            if (cur->left != nullptr) {
                q.push(cur->left);
            }
            if (cur->right != nullptr) {
                q.push(cur->right);
            }
        }
    }


第二种，可以利用 `step` 记录层数信息，较常用：



cpp 🤖

    void levelOrderTraverse(TreeNode* root) {
        if (root == nullptr) {
            return;
        }
        queue<TreeNode*> q;
        q.push(root);
        // 记录当前遍历到的层数（根节点视为第 1 层）
        int depth = 1;
    
        while (!q.empty()) {
            int sz = q.size();
            for (int i = 0; i < sz; i++) {
                TreeNode* cur = q.front();
                q.pop();
                // 访问 cur 节点，同时知道它所在的层数
                cout << "depth = " << depth << ", val = " << cur->val << endl;
    
                // 把 cur 的左右子节点加入队列
                if (cur->left != nullptr) {
                    q.push(cur->left);
                }
                if (cur->right != nullptr) {
                    q.push(cur->right);
                }
            }
            depth++;
        }
    }


第三种，使用自定义 `State` 类维护每个节点的信息，复杂一些但最灵活，会在图算法或复杂 BFS 算法中见到：

cpp 🤖

    class State {
    public:
        TreeNode* node;
        int depth;
    
        State(TreeNode* node, int depth) : node(node), depth(depth) {}
    };
    
    void levelOrderTraverse(TreeNode* root) {
        if (root == nullptr) {
            return;
        }
        queue<State> q;
        // 根节点的路径权重和是 1
        q.push(State(root, 1));
    
        while (!q.empty()) {
            State cur = q.front();
            q.pop();
            // 访问 cur 节点，同时知道它的路径权重和
            cout << "depth = " << cur.depth << ", val = " << cur.node->val << endl;
    
            // 把 cur 的左右子节点加入队列
            if (cur.node->left != nullptr) {
                q.push(State(cur.node->left, cur.depth + 1));
            }
            if (cur.node->right != nullptr) {
                q.push(State(cur.node->right, cur.depth + 1));
            }
        }
    }




### [二叉堆原理](#)

二叉堆的关键应用是优先级队列。作为速成教程，我们可以跳过优先级队列的实现，但是要理解以下关键点：

1、优先级队列是一种能够自动排序的数据结构，增删元素的复杂度是 O(log⁡N)O(\\log N)O(logN)，底层使用二叉堆实现。

2、二叉堆是一种拥有特殊性质的完全二叉树。

3、优先级队列（二叉堆）的核心方法是 `swim, sink`，用来维护二叉堆的性质。

关键基础，建议用时 0.5 天

*   [二叉堆核心原理及可视化](https://labuladong.online/algo/data-structure-basic/binary-heap-basic/)

### [线段树使用场景](#)

线段树是算法笔试中可能用到的一种数据结构，可以在 O(log⁡N)O(\\log N)O(logN) 的时间复杂度内完成区间查询和单点更新操作。

关键基础，建议用时 0.5 天

*   [线段树的核心原理及可视化](https://labuladong.online/algo/data-structure-basic/segment-tree-basic/)

上面这篇文章主要讲明白以下几点：

1、线段树的功能以及使用场景。你遇到类似的场景时，就知道可以用这么一种特殊数据结构来高效解决问题。

2、线段树的查询、更新复杂度为什么是 O(log⁡N)，这一点在面试中可能会问到。结合本站的可视化面板很好理解其中的原理。

3、线段树可以用链式结构实现，也可以用数组实现，数组实现的线段树在初始化时为什么要开 4 倍空间。

至于具体的代码实现，一般不会需要你从头写出来，可以参考 [线段树代码实现](https://labuladong.online/algo/data-structure/segment-tree-implement/) 给出的代码模板，需要时直接拿来使用即可。

### [图结构](#)

图论算法时一个很大的话题，但是作为数据结构基础章节，我们目前只需要了解图的逻辑表示和具体实现，以及图的遍历算法。

其实也不算复杂，本质上还是前文二叉树结构的延伸，下面这两篇文章给出了图结构的通用实现和遍历算法模板。

关键基础，建议用时 1 天

*   [图结构基础及通用代码实现](https://labuladong.online/algo/data-structure-basic/graph-basic/)
*   [图结构的 DFS/BFS 遍历](https://labuladong.online/algo/data-structure-basic/graph-traverse-basic/)

[开始刷题](#)
---------

### 关于题单
---------


**速成目录包含必知必会的算法套路 + 经典算法题，不局限于具体某家公司的题单**。

本目录的目的是从根本上搞定算法这个硬骨头，让你随心运用算法框架独立解决中等难度的常考算法题，而不是依赖运气和记忆，死记硬背某个题单。
学完下面的文章后顺手就能全部做完，不用单独去刷。**此题单仅为了方便刷完本目录的读者进行复习**：

| 链表双指针技巧 | 力扣 | 难度 |
|----------------|------|------|
| [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/?show=1) | 21 | 🟢 |
| [86. 分隔链表](https://leetcode.cn/problems/partition-list/?show=1) | 86 | 🟠 |
| [23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/?show=1) | 23 | 🔴 |
| [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/?show=1) | 141 | 🟢 |
| [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/?show=1) | 142 | 🟠 |
| [876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/?show=1) | 876 | 🟢 |
| [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/?show=1) | 19 | 🟠 |
| [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/?show=1) | 160 | 🟢 |
| [264. 丑数 II](https://leetcode.cn/problems/ugly-number-ii/?show=1) | 264 | 🟠 |
| [378. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/?show=1) | 378 | 🟠 |
| [373. 查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/?show=1) | 373 | 🟠 |
| [82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/?show=1) | 82 | 🟠 |
| [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/?show=1) | 2 | 🟠 |
| [445. 两数相加 II](https://leetcode.cn/problems/add-two-numbers-ii/?show=1) | 445 | 🟠 |

| 递归操作链表 | 力扣 | 难度 |
|--------------|------|------|
| [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/?show=1) | 234 | 🟢 |
| [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/?show=1) | 206 | 🟢 |
| [92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/?show=1) | 92 | 🟠 |
| [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/?show=1) | 25 | 🔴 |

| 数组双指针技巧 | 力扣 | 难度 |
|---------------|------|------|
| [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/?show=1) | 26 | 🟢 |
| [83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/?show=1) | 83 | 🟢 |
| [27. 移除元素](https://leetcode.cn/problems/remove-element/?show=1) | 27 | 🟢 |
| [283. 移动零](https://leetcode.cn/problems/move-zeroes/?show=1) | 283 | 🟢 |
| [167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/?show=1) | 167 | 🟠 |
| [344. 反转字符串](https://leetcode.cn/problems/reverse-string/?show=1) | 344 | 🟢 |
| [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/?show=1) | 5 | 🟠 |
| [80. 删除有序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/?show=1) | 80 | 🟠 |
| [125. 验证回文串](https://leetcode.cn/problems/valid-palindrome/?show=1) | 125 | 🟢 |
| [75. 颜色分类](https://leetcode.cn/problems/sort-colors/?show=1) | 75 | 🟠 |
| [88. 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/?show=1) | 88 | 🟢 |
| [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/?show=1) | 977 | 🟢 |

| 二维数组操作技巧 | 力扣 | 难度 |
|-----------------|------|------|
| [151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/?show=1) | 151 | 🟠 |
| [48. 旋转图像](https://leetcode.cn/problems/rotate-image/?show=1) | 48 | 🟠 |
| [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/?show=1) | 54 | 🟠 |
| [59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/?show=1) | 59 | 🟠 |
| [1329. 将矩阵按对角线排序](https://leetcode.cn/problems/sort-the-matrix-diagonally/?show=1) | 1329 | 🟠 |
| [1260. 二维网格迁移](https://leetcode.cn/problems/shift-2d-grid/?show=1) | 1260 | 🟢 |
| [867. 转置矩阵](https://leetcode.cn/problems/transpose-matrix/?show=1) | 867 | 🟢 |
| [14. 最长公共前缀](https://leetcode.cn/problems/longest-common-prefix/?show=1) | 14 | 🟢 |

| 滑动窗口算法 | 力扣 | 难度 |
|-------------|------|------|
| [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/?show=1) | 76 | 🔴 |
| [567. 字符串的排列](https://leetcode.cn/problems/permutation-in-string/?show=1) | 567 | 🟠 |
| [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/?show=1) | 438 | 🟠 |
| [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/?show=1) | 3 | 🟠 |
| [1658. 将 x 减到 0 的最小操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/?show=1) | 1658 | 🟠 |
| [713. 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/?show=1) | 713 | 🟠 |
| [219. 存在重复元素 II](https://leetcode.cn/problems/contains-duplicate-ii/?show=1) | 219 | 🟢 |
| [220. 存在重复元素 III](https://leetcode.cn/problems/contains-duplicate-iii/?show=1) | 220 | 🔴 |
| [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/?show=1) | 209 | 🟠 |

| 二分搜索算法 | 力扣 | 难度 |
|-------------|------|------|
| [704. 二分查找](https://leetcode.cn/problems/binary-search/?show=1) | 704 | 🟢 |
| [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/?show=1) | 34 | 🟠 |
| [875. 爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/?show=1) | 875 | 🟠 |
| [1011. 在 D 天内送达包裹的能力](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/?show=1) | 1011 | 🟠 |
| [410. 分割数组的最大值](https://leetcode.cn/problems/split-array-largest-sum/?show=1) | 410 | 🔴 |

| 前缀和/差分技巧 | 力扣 | 难度 |
|----------------|------|------|
| [303. 区域和检索 - 数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/?show=1) | 303 | 🟢 |
| [304. 二维区域和检索 - 矩阵不可变](https://leetcode.cn/problems/range-sum-query-2d-immutable/?show=1) | 304 | 🟠 |
| [1109. 航班预订统计](https://leetcode.cn/problems/corporate-flight-bookings/?show=1) | 1109 | 🟠 |
| [1094. 拼车](https://leetcode.cn/problems/car-pooling/?show=1) | 1094 | 🟠 |

| 栈 | 力扣 | 难度 |
|---|------|------|
| [71. 简化路径](https://leetcode.cn/problems/simplify-path/?show=1) | 71 | 🟠 |
| [143. 重排链表](https://leetcode.cn/problems/reorder-list/?show=1) | 143 | 🟠 |
| [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/?show=1) | 20 | 🟢 |
| [150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/?show=1) | 150 | 🟠 |
| [225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/?show=1) | 225 | 🟢 |
| [388. 文件的最长绝对路径](https://leetcode.cn/problems/longest-absolute-file-path/?show=1) | 388 | 🟠 |

| 队列 | 力扣 | 难度 |
|-----|------|------|
| [933. 最近的请求次数](https://leetcode.cn/problems/number-of-recent-calls/?show=1) | 933 | 🟢 |
| [622. 设计循环队列](https://leetcode.cn/problems/design-circular-queue/?show=1) | 622 | 🟠 |
| [641. 设计循环双端队列](https://leetcode.cn/problems/design-circular-deque/?show=1) | 641 | 🟠 |
| [1670. 设计前中后队列](https://leetcode.cn/problems/design-front-middle-back-queue/?show=1) | 1670 | 🟠 |
| [2073. 买票需要的时间](https://leetcode.cn/problems/time-needed-to-buy-tickets/?show=1) | 2073 | 🟢 |

| 单调栈技巧 | 力扣 | 难度 |
|-----------|------|------|
| [1019. 链表中的下一个更大节点](https://leetcode.cn/problems/next-greater-node-in-linked-list/?show=1) | 1019 | 🟠 |
| [1944. 队列中可以看到的人数](https://leetcode.cn/problems/number-of-visible-people-in-a-queue/?show=1) | 1944 | 🔴 |
| [1475. 商品折扣后的最终价格](https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/?show=1) | 1475 | 🟢 |
| [901. 股票价格跨度](https://leetcode.cn/problems/online-stock-span/?show=1) | 901 | 🟠 |
| [402. 移掉 K 位数字](https://leetcode.cn/problems/remove-k-digits/?show=1) | 402 | 🟠 |
| [853. 车队](https://leetcode.cn/problems/car-fleet/?show=1) | 853 | 🟠 |
| [581. 最短无序连续子数组](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/?show=1) | 581 | 🟠 |

| 单调队列技巧 | 力扣 | 难度 |
|-------------|------|------|
| [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/?show=1) | 239 | 🔴 |
| [1438. 绝对差不超过限制的最长连续子数组](https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/?show=1) | 1438 | 🟠 |
| [862. 和至少为 K 的最短子数组](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/?show=1) | 862 | 🔴 |
| [918. 环形子数组的最大和](https://leetcode.cn/problems/maximum-sum-circular-subarray/?show=1) | 918 | 🟠 |

| 二叉树 | 力扣 | 难度 |
|-------|------|------|
| [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/?show=1) | 226 | 🟢 |
| [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/?show=1) | 114 | 🟠 |
| [116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/?show=1) | 116 | 🟠 |
| [654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/?show=1) | 654 | 🟠 |
| [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/?show=1) | 105 | 🟠 |
| [106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/?show=1) | 106 | 🟠 |
| [889. 根据前序和后序遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/?show=1) | 889 | 🟠 |
| [297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/?show=1) | 297 | 🔴 |
| [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/?show=1) | 236 | 🟠 |
| [235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/?show=1) | 235 | 🟠 |
| [222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/?show=1) | 222 | 🟠 |

| 二叉搜索树 | 力扣 | 难度 |
|-----------|------|------|
| [230. 二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/?show=1) | 230 | 🟠 |
| [538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/?show=1) | 538 | 🟠 |
| [1038. 从二叉搜索树到更大和树](https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/?show=1) | 1038 | 🟠 |
| [450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/?show=1) | 450 | 🟠 |
| [701. 二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/?show=1) | 701 | 🟠 |
| [700. 二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/?show=1) | 700 | 🟢 |
| [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/?show=1) | 98 | 🟠 |
| [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/?show=1) | 96 | 🟠 |
| [95. 不同的二叉搜索树 II](https://leetcode.cn/problems/unique-binary-search-trees-ii/?show=1) | 95 | 🟠 |

| 数据结构设计 | 力扣 | 难度 |
|-------------|------|------|
| [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/?show=1) | 146 | 🟠 |
| [460. LFU 缓存](https://leetcode.cn/problems/lfu-cache/?show=1) | 460 | 🔴 |
| [729. 我的日程安排表 I](https://leetcode.cn/problems/my-calendar-i/?show=1) | 729 | 🟠 |
| [950. 按递增顺序显示卡牌](https://leetcode.cn/problems/reveal-cards-in-increasing-order/?show=1) | 950 | 🟠 |
| [1700. 无法吃午餐的学生数量](https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/?show=1) | 1700 | 🟢 |
| [155. 最小栈](https://leetcode.cn/problems/min-stack/?show=1) | 155 | 🟠 |
| [1670. 设计前中后队列](https://leetcode.cn/problems/design-front-middle-back-queue/?show=1) | 1670 | 🟠 |
| [895. 最大频率栈](https://leetcode.cn/problems/maximum-frequency-stack/?show=1) | 895 | 🔴 |
| [224. 基本计算器](https://leetcode.cn/problems/basic-calculator/?show=1) | 224 | 🔴 |
| [227. 基本计算器 II](https://leetcode.cn/problems/basic-calculator-ii/?show=1) | 227 | 🟠 |

| 图相关算法 | 力扣 | 难度 |
|-----------|------|------|
| [207. 课程表](https://leetcode.cn/problems/course-schedule/?show=1) | 207 | 🟠 |
| [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/?show=1) | 210 | 🟠 |
| [990. 等式方程的可满足性](https://leetcode.cn/problems/satisfiability-of-equality-equations/?show=1) | 990 | 🟠 |
| [684. 冗余连接](https://leetcode.cn/problems/redundant-connection/?show=1) | 684 | 🟠 |
| [1584. 连接所有点的最小费用](https://leetcode.cn/problems/min-cost-to-connect-all-points/?show=1) | 1584 | 🟠 |
| [743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/?show=1) | 743 | 🟠 |
| [1631. 最小体力消耗路径](https://leetcode.cn/problems/path-with-minimum-effort/?show=1) | 1631 | 🟠 |
| [1514. 概率最大的路径](https://leetcode.cn/problems/path-with-maximum-probability/?show=1) | 1514 | 🟠 |

| DFS/回溯算法 | 力扣 | 难度 |
|-------------|------|------|
| [78. 子集](https://leetcode.cn/problems/subsets/?show=1) | 78 | 🟠 |
| [90. 子集 II](https://leetcode.cn/problems/subsets-ii/?show=1) | 90 | 🟠 |
| [77. 组合](https://leetcode.cn/problems/combinations/?show=1) | 77 | 🟠 |
| [39. 组合总和](https://leetcode.cn/problems/combination-sum/?show=1) | 39 | 🟠 |
| [40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/?show=1) | 40 | 🟠 |
| [216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/?show=1) | 216 | 🟠 |
| [46. 全排列](https://leetcode.cn/problems/permutations/?show=1) | 46 | 🟠 |
| [47. 全排列 II](https://leetcode.cn/problems/permutations-ii/?show=1) | 47 | 🟠 |
| [37. 解数独](https://leetcode.cn/problems/sudoku-solver/?show=1) | 37 | 🔴 |
| [51. N 皇后](https://leetcode.cn/problems/n-queens/?show=1) | 51 | 🔴 |
| [52. N皇后 II](https://leetcode.cn/problems/n-queens-ii/?show=1) | 52 | 🔴 |
| [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/?show=1) | 200 | 🟠 |
| [1254. 统计封闭岛屿的数目](https://leetcode.cn/problems/number-of-closed-islands/?show=1) | 1254 | 🟠 |
| [695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/?show=1) | 695 | 🟠 |
| [1905. 统计子岛屿](https://leetcode.cn/problems/count-sub-islands/?show=1) | 1905 | 🟠 |
| [967. 连续差相同的数字](https://leetcode.cn/problems/numbers-with-same-consecutive-differences/?show=1) | 967 | 🟠 |
| [491. 递增子序列](https://leetcode.cn/problems/non-decreasing-subsequences/?show=1) | 491 | 🟠 |
| [980. 不同路径 III](https://leetcode.cn/problems/unique-paths-iii/?show=1) | 980 | 🔴 |
| [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/?show=1) | 131 | 🟠 |
| [93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/?show=1) | 93 | 🟠 |
| [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/?show=1) | 17 | 🟠 |
| [79. 单词搜索](https://leetcode.cn/problems/word-search/?show=1) | 79 | 🟠 |

| BFS 算法 | 力扣 | 难度 |
|---------|------|------|
| [752. 打开转盘锁](https://leetcode.cn/problems/open-the-lock/?show=1) | 752 | 🟠 |
| [773. 滑动谜题](https://leetcode.cn/problems/sliding-puzzle/?show=1) | 773 | 🔴 |
| [919. 完全二叉树插入器](https://leetcode.cn/problems/complete-binary-tree-inserter/?show=1) | 919 | 🟠 |
| [841. 钥匙和房间](https://leetcode.cn/problems/keys-and-rooms/?show=1) | 841 | 🟠 |
| [433. 最小基因变化](https://leetcode.cn/problems/minimum-genetic-mutation/?show=1) | 433 | 🟠 |
| [1926. 迷宫中离入口最近的出口](https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/?show=1) | 1926 | 🟠 |
| [1091. 二进制矩阵中的最短路径](https://leetcode.cn/problems/shortest-path-in-binary-matrix/?show=1) | 1091 | 🟠 |
| [994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/?show=1) | 994 | 🟠 |
| [721. 账户合并](https://leetcode.cn/problems/accounts-merge/?show=1) | 721 | 🟠 |
| [127. 单词接龙](https://leetcode.cn/problems/word-ladder/?show=1) | 127 | 🔴 |
| [365. 水壶问题](https://leetcode.cn/problems/water-and-jug-problem/?show=1) | 365 | 🟠 |

| 动态规划 | 力扣 | 难度 |
|---------|------|------|
| [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/?show=1) | 509 | 🟢 |
| [322. 零钱兑换](https://leetcode.cn/problems/coin-change/?show=1) | 322 | 🟠 |
| [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/?show=1) | 300 | 🟠 |
| [354. 俄罗斯套娃信封问题](https://leetcode.cn/problems/russian-doll-envelopes/?show=1) | 354 | 🔴 |
| [72. 编辑距离](https://leetcode.cn/problems/edit-distance/?show=1) | 72 | 🔴 |
| [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/?show=1) | 53 | 🟠 |
| [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/?show=1) | 1143 | 🟠 |
| [583. 两个字符串的删除操作](https://leetcode.cn/problems/delete-operation-for-two-strings/?show=1) | 583 | 🟠 |
| [712. 两个字符串的最小ASCII删除和](https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/?show=1) | 712 | 🟠 |
| [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/?show=1) | 416 | 🟠 |
| [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/?show=1) | 518 | 🟠 |

| 贪心算法 | 力扣 | 难度 |
|---------|------|------|
| [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/?show=1) | 55 | 🟠 |
| [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/?show=1) | 45 | 🟠 |
| [134. 加油站](https://leetcode.cn/problems/gas-station/?show=1) | 134 | 🟠 |

| 分治算法 | 力扣 | 难度 |
|---------|------|------|
| [23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/?show=1) | 23 | 🔴 |
| [241. 为运算表达式设计优先级](https://leetcode.cn/problems/different-ways-to-add-parentheses/?show=1) | 241 | 🟠 |

| 数学算法 | 力扣 | 难度 |
|---------|------|------|
| [292. Nim 游戏](https://leetcode.cn/problems/nim-game/?show=1) | 292 | 🟢 |
| [877. 石子游戏](https://leetcode.cn/problems/stone-game/?show=1) | 877 | 🟠 |
| [319. 灯泡开关](https://leetcode.cn/problems/bulb-switcher/?show=1) | 319 | 🟠 |
| [382. 链表随机节点](https://leetcode.cn/problems/linked-list-random-node/?show=1) | 382 | 🟠 |
| [398. 随机数索引](https://leetcode.cn/problems/random-pick-index/?show=1) | 398 | 🟠 |
| [384. 打乱数组](https://leetcode.cn/problems/shuffle-an-array/?show=1) | 384 | 🟠 |
| [204. 计数质数](https://leetcode.cn/problems/count-primes/?show=1) | 204 | 🟠 |
| [372. 超级次方](https://leetcode.cn/problems/super-pow/?show=1) | 372 | 🟠 |

| 其他经典面试题 | 力扣 | 难度 |
|--------------|------|------|
| [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/?show=1) | 42 | 🔴 |
| [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/?show=1) | 11 | 🟠 |
| [263. 丑数](https://leetcode.cn/problems/ugly-number/?show=1) | 263 | 🟢 |
| [264. 丑数 II](https://leetcode.cn/problems/ugly-number-ii/?show=1) | 264 | 🟠 |
| [1201. 丑数 III](https://leetcode.cn/problems/ugly-number-iii/?show=1) | 1201 | 🟠 |
| [313. 超级丑数](https://leetcode.cn/problems/super-ugly-number/?show=1) | 313 | 🟠 |
| [528. 按权重随机选择](https://leetcode.cn/problems/random-pick-with-weight/?show=1) | 528 | 🟠 |
| [1. 两数之和](https://leetcode.cn/problems/two-sum/?show=1) | 1 | 🟢 |
| [167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/?show=1) | 167 | 🟠 |
| [15. 三数之和](https://leetcode.cn/problems/3sum/?show=1) | 15 | 🟠 |
| [18. 四数之和](https://leetcode.cn/problems/4sum/?show=1) | 18 | 🟠 |



这篇文章是本站全站内容的纲领，不仅会对上面介绍的数据结构进行总结，还会直接指出所有算法的本质。

其中会出现大量其他文章的链接引用，初次阅读肯定不容易完全理解，但是不必死磕，只要大致了解文中介绍的思维方法即可，在学习后面内容的时候你将会逐渐领会到本文的精髓。

*   [学习数据结构和算法的框架思维](./数据结构与算法框架导论.md)

### [链表](#)

链表相关的题目套路比较固定，主要是双指针技巧。

- 核心框架，建议用时 1 天

  *   [双指针技巧秒杀七道链表题目](./链表算法题解/双指针-链表.md)

- 习题，建议用时 1 天

  *   [【强化练习】链表双指针经典习题](./链表算法题解/双指针-链表.md)

单链表的一个进阶技巧是递归操作单链表，不过这种思路一般用于面试时说一下就行，笔试时就用标准的指针操作即可。

- 核心框架，建议用时 1 天

  *   [如何判断回文链表](https://labuladong.online/algo/data-structure/palindrome-linked-list/)
  *   [单链表的花式反转方法汇总](https://labuladong.online/algo/data-structure/reverse-linked-list-recursion/)

### [数组](#)

#### 双指针
数组相关的技巧也主要是双指针，只不过可以分为快慢指针、左右指针几种不同的类型。经典的数组双指针算法有二分搜索、滑动窗口。

有些读者问我为什么不出字符串算法的专题，因为字符串就是字符数组，字符串算法本质上还是数组算法。

- 核心框架，建议用时 0.5 天

  *   [双指针技巧秒杀七道数组题目](https://labuladong.online/algo/essential-technique/array-two-pointers-summary/)

- 习题，建议用时 1~2 天

  *   [二维数组的花式遍历技巧](https://labuladong.online/algo/practice-in-action/2d-array-traversal-summary/)
  *   [【强化练习】数组双指针经典习题](https://labuladong.online/algo/problem-set/array-two-pointers/)

#### 滑动窗口
- 核心框架，建议用时 1 天

  *   [滑动窗口算法核心代码模板](https://labuladong.online/algo/essential-technique/sliding-window-framework/)

- 滑动窗口代码模板（伪码）


    ```c++


        // 滑动窗口算法伪码框架
        void slidingWindow(string s) {
            // 用合适的数据结构记录窗口中的数据，根据具体场景变通
            // 比如说，我想记录窗口中元素出现的次数，就用 map
            // 如果我想记录窗口中的元素和，就可以只用一个 int
            auto window = ...
        
            int left = 0, right = 0;
            while (right < s.size()) {
                // c 是将移入窗口的字符
                char c = s[right];
                window.add(c);
                // 增大窗口
                right++;
        
                // 进行窗口内数据的一系列更新
                ...
        
                // *** debug 输出的位置 ***
                printf("window: [%d, %d)\n", left, right);
                // 注意在最终的解法代码中不要 print
                // 因为 IO 操作很耗时，可能导致超时
        
                // 判断左侧窗口是否要收缩
                while (window needs shrink) {
                    // d 是将移出窗口的字符
                    char d = s[left];
                    window.remove(d);
                    // 缩小窗口
                    left++;
        
                    // 进行窗口内数据的一系列更新
                    ...
                }
            }
        }
    ```


- 习题，建议用时 1 天

  *   [【强化练习】滑动窗口算法经典习题](https://labuladong.online/algo/problem-set/sliding-window/)

#### 二分搜索
- 核心框架，建议用时 1~2 天

  *   [二分搜索算法核心代码模板](https://labuladong.online/algo/essential-technique/binary-search-framework/)
  *   [实际运用二分搜索时的思维框架](https://labuladong.online/algo/frequency-interview/binary-search-in-action/)

- 二分搜索代码模板

    ```c++

        int binary_search(vector<int>& nums, int target) {
            int left = 0, right = nums.size()-1; 
            while(left <= right) {
                int mid = left + (right - left) / 2;
                if (nums[mid] < target) {
                    left = mid + 1;
                } else if (nums[mid] > target) {
                    right = mid - 1; 
                } else if(nums[mid] == target) {
                    // 直接返回
                    return mid;
                }
            }
            // 直接返回
            return -1;
        }
        
        int left_bound(vector<int>& nums, int target) {
            int left = 0, right = nums.size()-1;
            while (left <= right) {
                int mid = left + (right - left) / 2;
                if (nums[mid] < target) {
                    left = mid + 1;
                } else if (nums[mid] > target) {
                    right = mid - 1;
                } else if (nums[mid] == target) {
                    // 别返回，锁定左侧边界
                    right = mid - 1;
                }
            }
            // 判断 target 是否存在于 nums 中
            if (left < 0 || left >= nums.size()) {
                return -1;
            }
            // 判断一下 nums[left] 是不是 target
            return nums[left] == target ? left : -1;
        }
        
        int right_bound(vector<int>& nums, int target) {
            int left = 0, right = nums.size()-1;
            while (left <= right) {
                int mid = left + (right - left) / 2;
                if (nums[mid] < target) {
                    left = mid + 1;
                } else if (nums[mid] > target) {
                    right = mid - 1;
                } else if (nums[mid] == target) {
                    // 别返回，锁定右侧边界
                    left = mid + 1;
                }
            }
            // 由于 while 的结束条件是 right == left - 1，且现在在求右边界
            // 所以用 right 替代 left - 1 更好记
            if (right < 0 || right >= nums.size()) {
                return -1;
            }
            return nums[right] == target ? right : -1;
        }
    ```

#### 前缀和、差分

- 核心框架，建议用时 1~2 天

  *   [小而美的算法技巧：前缀和数组](https://labuladong.online/algo/data-structure/prefix-sum/)
  *   [小而美的算法技巧：差分数组](https://labuladong.online/algo/data-structure/diff-array/)

- 前缀和数组代码模板

    一维前缀和：




    ```c++

        #include <vector>
        
        class NumArray {
            // 前缀和数组
            std::vector<int> preSum;
        
            // 输入一个数组，构造前缀和
            public:
            NumArray(std::vector<int>& nums) {
                // preSum[0] = 0，便于计算累加和
                preSum.resize(nums.size() + 1);
                // 计算 nums 的累加和
                for (int i = 1; i < preSum.size(); i++) {
                    preSum[i] = preSum[i - 1] + nums[i - 1];
                }
            }
        
            // 查询闭区间 [left, right] 的累加和
            int sumRange(int left, int right) {
                return preSum[right + 1] - preSum[left];
            }
        };
    ```


- 差分数组代码模板


    ```c++

        // 差分数组工具类
        class Difference {
            // 差分数组
            private:
                vector<int> diff;
            
            // 输入一个初始数组，区间操作将在这个数组上进行
            public:
                Difference(vector<int>& nums) {
                    diff = vector<int>(nums.size());
                    // 根据初始数组构造差分数组
                    diff[0] = nums[0];
                    for (int i = 1; i < nums.size(); i++) {
                        diff[i] = nums[i] - nums[i - 1];
                    }
                }
        
                // 给闭区间 [i, j] 增加 val（可以是负数）
                void increment(int i, int j, int val) {
                    diff[i] += val;
                    if (j + 1 < diff.size()) {
                        diff[j + 1] -= val;
                    }
                }
        
                // 返回结果数组
                vector<int> result() {
                    vector<int> res(diff.size());
                    // 根据差分数组构造结果数组
                    res[0] = diff[0];
                    for (int i = 1; i < diff.size(); i++) {
                        res[i] = res[i - 1] + diff[i];
                    }
                    return res;
                }
        };
    ```


### [队列/栈](#)

队列和栈本身是比较简单的数据结构，但是它们在算法题中的运用需要专门练习。
#### 基础队列/栈

- 核心框架，建议用时 0.5 天

  *   [队列实现栈以及栈实现队列](https://labuladong.online/algo/data-structure/stack-queue/)

- 习题，建议用时 1~2 天

    *   [【强化练习】栈的经典习题](https://labuladong.online/algo/problem-set/stack/)
    *   [【强化练习】队列的经典习题](https://labuladong.online/algo/problem-set/queue/)

#### 单调队列/栈

单调栈和单调队列是基于栈和队列的两种变体，它们能够解决一些特殊的问题，需要掌握。

- 核心框架，建议用时 1~2 天

    *   [单调栈算法模板解决三道例题](https://labuladong.online/algo/data-structure/monotonic-stack/)
    *   [单调队列结构解决滑动窗口问题](https://labuladong.online/algo/data-structure/monotonic-queue/)

- 习题，建议用时 1~2 天

    *   [【强化练习】单调栈的几种变体及经典习题](https://labuladong.online/algo/problem-set/monotonic-stack/)
    *   [【强化练习】单调队列的通用实现及经典习题](https://labuladong.online/algo/problem-set/monotonic-queue/)

### [二叉树](#)

所有递归算法的本质上都是二叉树的遍历，而且二叉树算法经常出现在面试/笔试中，所以二叉树章节我多放几篇文章，希望大家认真学习理解，亲自动手实践。

- 核心框架，建议用时 0.5 天

这篇文章结合几道简单的经典算法题，从树的视角来理解一切递归算法，并把所有递归算法归为两种思维模式。

    *   [一个视角 + 两种思维模式搞定递归](https://labuladong.online/algo/essential-technique/understand-recursion/)

- 核心框架，建议用时 1 天

这篇核心纲领是一个总纲，主要有两部分内容：第一部分是如何在实际的算法题中理解二叉树的前中后序位置；第二部分是从二叉树的角度介绍回溯/动态规划等算法。

现在你已经了解了二叉树遍历算法，所以请认真学习第一部分。第二部分讲到的高级算法目前还没有学习，你只要有个印象就行了，等到后面学习了回溯/动态规划再回来看就会有更深的理解。

    *   [二叉树系列算法核心纲领](https://labuladong.online/algo/essential-technique/binary-tree-summary/)

- 核心框架，建议用时 2~3 天

这几篇教程中的例题是必知必会的二叉树经典考题，需要学习掌握。

    *   [二叉树心法（思路篇）](https://labuladong.online/algo/data-structure/binary-tree-part1/)
    *   [二叉树心法（构造篇）](https://labuladong.online/algo/data-structure/binary-tree-part2/)
    *   [二叉树心法（序列化篇）](https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/)

- 习题，建议用时 1 天

    *   [拓展：最近公共祖先系列解题框架](https://labuladong.online/algo/practice-in-action/lowest-common-ancestor-summary/)
    *   [拓展：如何计算完全二叉树的节点数](https://labuladong.online/algo/data-structure/count-complete-tree-nodes/)

- 习题，建议用时 2 天

我非常强调二叉树相关算法题的重要性，因为算法的本质是穷举，树结构是所有暴力穷举算法的核心抽象。你把二叉树玩明白了，后面的高级算法都能很容易理解。

本站的 [二叉树算法习题集](https://labuladong.online/algo/intro/binary-tree-practice/) 专门用一整个章节近 100 道题来练习二叉树算法，依照 [二叉树算法（纲领篇）](https://labuladong.online/algo/essential-technique/binary-tree-summary/) 的分类，把二叉树的习题分为三大部分：

1、递归，用「遍历」的思维模式解题。

2、递归，用「分级问题」的思维模式解题。

3、非递归，用「层序遍历」的思维模式解题。

其中「遍历」的思维模式就是后面讲的 DFS 算法、回溯算法的原型，「分解问题」的思维模式就是后面讲的动态规划、分治算法的原型，「层序遍历」就是后面讲的 BFS 算法的原型。

所以这里必须要对这几种二叉树算法进行练习。[二叉树算法习题集](https://labuladong.online/algo/intro/binary-tree-practice/) 总量比较多，下面仅为速成读者列出难度适中且考察频率高的习题：

    *   [【强化练习】用「遍历」思维解题 I](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/)
    *   [【强化练习】用「分解问题」思维解题 I](https://labuladong.online/algo/problem-set/binary-tree-divide-i/)
    *   [【强化练习】运用层序遍历解题 I](https://labuladong.online/algo/problem-set/binary-tree-level-i/)

如果你有时间和兴趣，可以自行查看其他习题章节进行练习。

### [二叉搜索树](#)

二叉搜索树是特殊的二叉树，你就记住它的特点是「左小右大」，好好利用这个特点，来优化二叉树的遍历过程。

- 核心框架，建议用时 1~2 天

    *   [二叉搜索树心法（特性篇）](https://labuladong.online/algo/data-structure/bst-part1/)
    *   [二叉搜索树心法（基操篇）](https://labuladong.online/algo/data-structure/bst-part2/)

- 核心框架，建议用时 1 天

  *   [二叉搜索树心法（构造篇）](https://labuladong.online/algo/data-structure/bst-part3/)

### [数据结构设计](#)

LRU 是经典的数据结构设计问题，必须掌握；LFU 难度更大一些，可以作为选学。

- 习题，建议用时 1 天

    *   [算法就像搭乐高：手撸 LRU 算法](https://labuladong.online/algo/data-structure/lru-cache/)
    *   [算法就像搭乐高：手撸 LFU 算法（选学）](https://labuladong.online/algo/frequency-interview/lfu/)

- 习题，建议用时 1 天

实现计算器是一个经典的数据结构设计题目，没时间的话可以把最后给出的计算器代码保存下来，如果笔试遇到字符串计算相关的题目，可以直接复制粘贴拿去用。

    *   [拓展：如何实现一个计算器](https://labuladong.online/algo/data-structure/implement-calculator/)

- 通用计算器代码实现

    ```c++

        class Solution {
        public:
            int calculate(string s) {
                // key 是左括号的索引，value 是对应的右括号的索引
                unordered_map<int, int> rightIndex;
                // 利用栈结构来找到对应的括号
                stack<int> stack;
                for (int i = 0; i < s.length(); i++) {
                    if (s[i] == '(') {
                        stack.push(i);
                    } else if (s[i] == ')') {
                        rightIndex[stack.top()] = i;
                        stack.pop();
                    }
                }
                return _calculate(s, 0, s.length() - 1, rightIndex);
            }
        
        private:
            // 定义：返回 s[start..end] 内的表达式的计算结果
            int _calculate(string s, int start, int end, unordered_map<int, int> &rightIndex) {
                // 需要把字符串转成双端队列方便操作
                stack<int> stk;
                // 记录算式中的数字
                int num = 0;
                // 记录 num 前的符号，初始化为 +
                char sign = '+';
                for (int i = start; i <= end; i++) {
                    char c = s[i];
                    if (isdigit(c)) {
                        num = 10 * num + (c - '0');
                    }
                    if (c == '(') {
                        // 递归计算括号内的表达式
                        num = _calculate(s, i + 1, rightIndex[i] - 1, rightIndex);
                        i = rightIndex[i];
                    }
                    if (c == '+' || c == '-' || c == '*' || c == '/' || i == end) {
                        int pre;
                        switch (sign) {
                            case '+':
                                stk.push(num);
                                break;
                            case '-':
                                stk.push(-num);
                                break;
                            // 只要拿出前一个数字做对应运算即可
                            case '*':
                                pre = stk.top(); stk.pop();
                                stk.push(pre * num);
                                break;
                            case '/':
                                pre = stk.top(); stk.pop();
                                stk.push(pre / num);
                                break;
                        }
                        // 更新符号为当前符号，数字清零
                        sign = c;
                        num = 0;
                    }
                }
                // 将栈中所有结果求和就是答案
                int res = 0;
                while (!stk.empty()) {
                    res += stk.top();
                    stk.pop();
                }
                return res;
            }
        };

    ```

- 习题，建议用时 1 天

  *   [【强化练习】更多经典设计习题](https://labuladong.online/algo/problem-set/ds-design/)

### [图算法](#)

环检测、拓扑排序、二分图判定是经典的图算法，本质上就是对图的遍历，并不难掌握。

- 核心框架，建议用时 1~2 天

    *   [环检测及拓扑排序算法](https://labuladong.online/algo/data-structure/topological-sort/)
    *   [二分图判定算法](https://labuladong.online/algo/data-structure/bipartite-graph/)

Union Find 算法是比较实用的图算法，你需要大致了解它的原理和 API。如果没有时间仔细阅读，可以把最后给出的 `UF` 类保存下来，笔试时可以直接拿去用。

- 核心框架，建议用时 1 天

    *   [Union Find 并查集原理](https://labuladong.online/algo/data-structure-basic/union-find-basic/)
    *   [Union-Find 并查集算法](https://labuladong.online/algo/data-structure/union-find/)

- Union Find 代码模板

这里直接给出效率最高的路径压缩代码实现：

    ```c++


            class UF {
            private:
                // 连通分量个数
                int _count;
                // 存储每个节点的父节点
                vector<int> parent;
            
            public:
                // n 为图中节点的个数
                UF(int n) {
                    this->_count = n;
                    this->parent.resize(n);
                    for (int i = 0; i < n; i++) {
                        parent[i] = i;
                    }
                }
                
                // 将节点 p 和节点 q 连通
                void union_(int p, int q) {
                    int rootP = find(p);
                    int rootQ = find(q);
                    
                    if (rootP == rootQ)
                        return;
                    
                    parent[rootQ] = rootP;
                    // 两个连通分量合并成一个连通分量
                    _count--;
                }
            
                // 判断节点 p 和节点 q 是否连通
                bool connected(int p, int q) {
                    int rootP = find(p);
                    int rootQ = find(q);
                    return rootP == rootQ;
                }
            
                int find(int x) {
                    if (parent[x] != x) {
                        parent[x] = find(parent[x]);
                    }
                    return parent[x];
                }
            
                // 返回图中的连通分量个数
                int count() {
                    return _count;
                }
            };
    ```


你需要知道最小生成树的定义。Kruskal 和 Prim 是两种经典的最小生成树算法，可以了解下 Kruskal 算法，因为它其实就是 Union Find 算法 + 排序，比较简单。

- 核心框架，建议用时 1 天

  *   [Kruskal 最小生成树算法](https://labuladong.online/algo/data-structure/kruskal/)

Dijkstra 最短路径算法属于经典图论算法，需要掌握。它的本质就经过改良的二叉树 BFS 算法，你可以把模板保存下来，以便笔试时快速运用。

- 核心框架，建议用时 1 天

    *   [Dijkstra 算法模板](https://labuladong.online/algo/data-structure/dijkstra/)
    *   [Dijkstra 算法习题](https://labuladong.online/algo/problem-set/dijkstra/)

- Dijkstra 算法模板（伪码）


    ```c++

        // 输入一幅图和一个起点 start，计算 start 到其他节点的最短距离
        vector<int> dijkstra(int start, Graph* graph) {
            // 图中节点的个数
            int V = graph.size();
            // 记录最短路径的权重，你可以理解为 dp table
            // 定义：distTo[i] 的值就是节点 start 到达节点 i 的最短路径权重
            int distTo[V];
            // 求最小值，所以 dp table 初始化为正无穷
            memset(distTo, INT_MAX, sizeof(distTo));
            // base case，start 到 start 的最短距离就是 0
            distTo[start] = 0;
        
            // 优先级队列，distFromStart 较小的排在前面
            priority_queue<State, vector<State>, decltype(&comparator)> pq(&comparator);
        
            // 从起点 start 开始进行 BFS
            pq.push(State(start, 0));
        
            while (!pq.empty()) {
                State curState = pq.top();
                pq.pop();
                int curNodeID = curState.id;
                int curDistFromStart = curState.distFromStart;
        
                if (curDistFromStart > distTo[curNodeID]) {
                    // 已经有一条更短的路径到达 curNode 节点了
                    continue;
                }
                // 将 curNode 的相邻节点装入队列
                for (int nextNodeID: graph.neighbors(curNodeID)) {
                    // 看看从 curNode 达到 nextNode 的距离是否会更短
                    int distToNextNode = distTo[curNodeID] + graph.weight(curNodeID, nextNodeID);
                    if (distTo[nextNodeID] > distToNextNode) {
                        // 更新 dp table
                        distTo[nextNodeID] = distToNextNode;
                        // 将这个节点以及距离放入队列
                        pq.push(State(nextNodeID, distToNextNode));
                    }
                }
            }
            vector<int> result;
            for (int i = 0; i < V; i++) {
                result.push_back(distTo[i]);
            }
            return result;
        }
    ```


### [DFS/回溯算法](#)

回溯算法是一种纯粹的暴力穷举算法，必须掌握。

因为笔试时是按照通过的测试用例数量来算分的，如果有些题目你实在写不出最优解，写一个回溯算法暴力穷举一下，虽然过不了所有测试用例，但是能过一部分，也能捞到一点分数。

下面列举的文章中的例题都是经典的回溯算法题目，必知必会，一定要透彻地掌握。

- 核心框架，建议用时 1~2 天

    *   [回溯算法解题套路框架](https://labuladong.online/algo/essential-technique/backtrack-framework/)
    *   [回溯算法实践：数独和 N 皇后问题](https://labuladong.online/algo/practice-in-action/sudoku-nqueue/)

- 核心框架，建议用时 1~2 天

    *   [回溯算法秒杀所有排列/组合/子集问题](https://labuladong.online/algo/essential-technique/permutation-combination-subset-all-in-one/)

- 核心框架，建议用时 1 天

    这篇文章讲的是 DFS 算法：

  *   [一文秒杀所有岛屿题目](https://labuladong.online/algo/frequency-interview/island-dfs-summary/)

    DFS 算法和回溯算法有一点点区别，这篇文章介绍，并给出一些代码风格的建议：

  *   [回答 DFS 和回溯算法的若干疑问](https://labuladong.online/algo/essential-technique/backtrack-vs-dfs/)

- 习题，建议用时 2 天

大部分回溯算法的本质就是排列组合，你把 [回溯算法秒杀所有排列/组合/子集问题](https://labuladong.online/algo/essential-technique/permutation-combination-subset-all-in-one/) 想明白，很多回溯题目都可以直接秒。

本站的回溯算法习题章节如下：

    *   [【强化练习】回溯算法经典习题 I](https://labuladong.online/algo/problem-set/backtrack-i/)
    *   [【强化练习】回溯算法经典习题 II](https://labuladong.online/algo/problem-set/backtrack-ii/)
    *   [【强化练习】回溯算法经典习题 III](https://labuladong.online/algo/problem-set/backtrack-iii/)

不过习题章节的题目比较多，如果你有时间可以都看一看，时间紧的话我帮你精选几道。

| 力扣 | 题目链接 |
|------|----------|
| 967 | [连续差相同的数字](https://leetcode.cn/problems/numbers-with-same-consecutive-differences/?show=1) |
| 491 | [非递减子序列](https://leetcode.cn/problems/non-decreasing-subsequences/?show=1) |
| 980 | [不同路径 III](https://leetcode.cn/problems/unique-paths-iii/?show=1) |
| 131 | [分割回文串](https://leetcode.cn/problems/palindrome-partitioning/?show=1) |
| 93 | [复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/?show=1) |
| 17 | [电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/?show=1) |
| 79 | [单词搜索](https://leetcode.cn/problems/word-search/?show=1) |

### [BFS 算法](#)

BFS 也是一种暴力穷举算法，必须掌握。它的本质就是二叉树的层序遍历，适合解决最短路径问题。

- 核心框架，建议用时 1 天

  *   [BFS 算法解题套路框架](https://labuladong.online/algo/essential-technique/bfs-framework/)

- 习题，建议用时 2 天

本站的 BFS 习题章节如下：

  *   [【强化练习】BFS 经典习题 I](https://labuladong.online/algo/problem-set/bfs/)
  *   [【强化练习】BFS 经典习题 II](https://labuladong.online/algo/problem-set/bfs-ii/)

不过这两章习题比较多，如果你有时间可以都刷完，时间紧的话我帮你精选几道做一做。建议安装 [Chrome 插件](https://labuladong.online/algo/intro/chrome/)，在题目页面可以查看本站的思路和解法代码：

| 力扣 | 题目链接 |
|------|----------|
| 919 | [完全二叉树插入器](https://leetcode.cn/problems/complete-binary-tree-inserter/?show=1) |
| 841 | [钥匙和房间](https://leetcode.cn/problems/keys-and-rooms/?show=1) |
| 433 | [最小基因变化](https://leetcode.cn/problems/minimum-genetic-mutation/?show=1) |
| 1926 | [迷宫中离入口最近的出口](https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/?show=1) |
| 1091 | [二进制矩阵中的最短路径](https://leetcode.cn/problems/shortest-path-in-binary-matrix/?show=1) |
| 994 | [腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/?show=1) |
| 721 | [账户合并](https://leetcode.cn/problems/accounts-merge/?show=1) |
| 127 | [单词接龙](https://leetcode.cn/problems/word-ladder/?show=1) |
| 365 | [水壶问题](https://leetcode.cn/problems/water-and-jug-problem/?show=1) |


### [动态规划](#)

动态规划本质上也是暴力穷举，只不过有些问题的穷举过程中存在重叠子问题，所以可以通过备忘录进行优化，对于这类算法，我们通常称为动态规划算法。

动态规划的暴力穷举解法一般是递归形式，优化方法非常固定，要么就是添加备忘录，要么就是改写成迭代形式。

动态规划的难点在于那个暴力解（状态转移方程）怎么写，请你阅读下面的文章，尤其注意得到状态转移方程的思维过程。

- 核心框架，建议用时 1~2 天

    *   [动态规划解题套路框架](https://labuladong.online/algo/essential-technique/dynamic-programming-framework/)
    *   [动态规划设计：最长递增子序列](https://labuladong.online/algo/dynamic-programming/longest-increasing-subsequence/)

- 核心框架，建议用时 1~2 天

    *   [base case 和备忘录的初始值怎么定？](https://labuladong.online/algo/dynamic-programming/memo-fundamental/)
    *   [最优子结构原理和 dp 数组遍历方向](https://labuladong.online/algo/dynamic-programming/faq-summary/)

- 习题，建议用时 1~2 天

    *   [经典动态规划：编辑距离](https://labuladong.online/algo/dynamic-programming/edit-distance/)
    *   [动态规划设计：最大子数组](https://labuladong.online/algo/dynamic-programming/maximum-subarray/)
    *   [经典动态规划：最长公共子序列](https://labuladong.online/algo/dynamic-programming/longest-common-subsequence/)

- 习题，建议用时 1~2 天

    *   [经典动态规划：0-1 背包问题](https://labuladong.online/algo/dynamic-programming/knapsack1/)
    *   [经典动态规划：子集背包问题](https://labuladong.online/algo/dynamic-programming/knapsack2/)
    *   [经典动态规划：完全背包问题](https://labuladong.online/algo/dynamic-programming/knapsack3/)

### [贪心算法](#)

一般的算法问题，需要暴力穷举所有解，从中找到最优解。

而有些算法问题，如果你充分利用信息，不需要用暴力穷举所有解，就能找到最优解，这就叫贪心选择性质，这种算法叫贪心算法。

所以贪心算法没有固定的套路，它的关键在于细心观察，看看是否能够充分利用信息，提前排除一些不可能是最优解的情况。

- 核心框架，建议用时 1 天

  *   [贪心算法原理及应用](https://labuladong.online/algo/essential-technique/greedy/)

### [分治算法](#)

有一部分算法问题，分而治之会有更高的效率，下面这篇分治算法教程所讲的例题是前面讲过的一道链表题目。

- 核心框架，建议用时 1 天

  *   [分治算法详解](https://labuladong.online/algo/essential-technique/divide-and-conquer/)

### [数学](#)

一般笔试中数学相关算法比较少，不过一些经典的技巧还是有必要掌握。

- 习题，建议用时 1~2 天

*   [一行代码就能解决的算法题](https://labuladong.online/algo/frequency-interview/one-line-solutions/)
*   [谈谈游戏中的随机算法](https://labuladong.online/algo/frequency-interview/random-algorithm/)

- 习题，建议用时 1 天

*   [如何高效寻找素数](https://labuladong.online/algo/frequency-interview/print-prime-number/)
*   [如何高效进行模幂运算](https://labuladong.online/algo/frequency-interview/quick-power/)

### [其他经典面试题](#)

这里列出一些经典算法题，它们本质上都是上面介绍的算法的运用。掌握了上面的所有算法后，一般难度的面试题你应该都能够解决了。

- 习题，建议用时 1~2 天

*   [扫描线技巧：安排会议室](https://labuladong.online/algo/frequency-interview/scan-line-technique/)
*   [如何高效解决接雨水问题](https://labuladong.online/algo/frequency-interview/trapping-rain-water/)
*   [一文秒杀所有丑数系列问题](https://labuladong.online/algo/frequency-interview/ugly-number-summary/)

- 习题，建议用时 1~2 天

*   [带权重的随机选择算法](https://labuladong.online/algo/frequency-interview/random-pick-with-weight/)
*   [一个方法团灭 nSum 问题](https://labuladong.online/algo/practice-in-action/nsum/)

- nSum 万能函数

    ```c++

        // 注意：调用这个函数之前一定要先给 nums 排序
        // n 填写想求的是几数之和，start 从哪个索引开始计算（一般填 0），target 填想凑出的目标和
        vector<vector<int>> nSumTarget(vector<int>& nums, int n, int start, long target) {
            int sz = nums.size();
            vector<vector<int>> res;
            // 至少是 2Sum，且数组大小不应该小于 n
            if (n < 2 || sz < n) return res;
            // 2Sum 是 base case
            if (n == 2) {
                // 双指针那一套操作
                int lo = start, hi = sz - 1;
                while (lo < hi) {
                    int sum = nums[lo] + nums[hi];
                    int left = nums[lo], right = nums[hi];
                    if (sum < target) {
                        while (lo < hi && nums[lo] == left) lo++;
                    } else if (sum > target) {
                        while (lo < hi && nums[hi] == right) hi--;
                    } else {
                        res.push_back({left, right});
                        while (lo < hi && nums[lo] == left) lo++;
                        while (lo < hi && nums[hi] == right) hi--;
                    }
                }
            } else {
                // n > 2 时，递归计算 (n-1)Sum 的结果
                for (int i = start; i < sz; i++) {
                    vector<vector<int>> sub = nSumTarget(nums, n - 1, i + 1, target - nums[i]);
                    for (vector<int>& arr : sub) {
                        // (n-1)Sum 加上 nums[i] 就是 nSum
                        arr.push_back(nums[i]);
                        res.push_back(arr);
                    }
                    while (i < sz - 1 && nums[i] == nums[i + 1]) i++;
                }
            }
            return res;
        }
    ```


### [排序算法](#)

在笔试和面试中，一般不会出现排序算法的题目让你写代码；但是在面试中可能会问到经典排序算法的原理、时间复杂度和适用场景，所以你需要对十大经典排序算法有所了解。

排序算法串讲，建议用时 1 天

建议观看 [十大排序算法导读](https://labuladong.online/algo/intro/sorting/) 中的视频，了解十大排序算法的核心原理、复杂度分析和适用场景。